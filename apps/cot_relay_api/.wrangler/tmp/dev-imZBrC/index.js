var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// .wrangler/tmp/bundle-PqeCQB/checked-fetch.js
function checkURL(request, init) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  ".wrangler/tmp/bundle-PqeCQB/checked-fetch.js"() {
    "use strict";
    urls = /* @__PURE__ */ new Set();
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init] = argArray;
        checkURL(request, init);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/.pnpm/wrangler@3.31.0_@cloudflare+workers-types@4.20240222.0/node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/.pnpm/wrangler@3.31.0_@cloudflare+workers-types@4.20240222.0/node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/.pnpm/@whatwg-node+fetch@0.9.17/node_modules/@whatwg-node/fetch/dist/global-ponyfill.js
var require_global_ponyfill = __commonJS({
  "node_modules/.pnpm/@whatwg-node+fetch@0.9.17/node_modules/@whatwg-node/fetch/dist/global-ponyfill.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports.fetch = globalThis.fetch;
    module.exports.Headers = globalThis.Headers;
    module.exports.Request = globalThis.Request;
    module.exports.Response = globalThis.Response;
    module.exports.FormData = globalThis.FormData;
    module.exports.ReadableStream = globalThis.ReadableStream;
    module.exports.WritableStream = globalThis.WritableStream;
    module.exports.TransformStream = globalThis.TransformStream;
    module.exports.Blob = globalThis.Blob;
    module.exports.File = globalThis.File;
    module.exports.crypto = globalThis.crypto;
    module.exports.btoa = globalThis.btoa;
    module.exports.TextEncoder = globalThis.TextEncoder;
    module.exports.TextDecoder = globalThis.TextDecoder;
    module.exports.URLPattern = globalThis.URLPattern;
    module.exports.URL = globalThis.URL;
    module.exports.URLSearchParams = globalThis.URLSearchParams;
    module.exports.createFetch = () => globalThis;
  }
});

// node_modules/.pnpm/xmlbuilder2@3.1.1/node_modules/xmlbuilder2/lib/xmlbuilder2.min.js
var require_xmlbuilder2_min = __commonJS({
  "node_modules/.pnpm/xmlbuilder2@3.1.1/node_modules/xmlbuilder2/lib/xmlbuilder2.min.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.xmlbuilder2 = t() : e.xmlbuilder2 = t();
    }(exports, function() {
      return function(e) {
        var t = {};
        function r(n) {
          if (t[n])
            return t[n].exports;
          var i = t[n] = { i: n, l: false, exports: {} };
          return e[n].call(i.exports, i, i.exports, r), i.l = true, i.exports;
        }
        return r.m = e, r.c = t, r.d = function(e2, t2, n) {
          r.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: n });
        }, r.r = function(e2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        }, r.t = function(e2, t2) {
          if (1 & t2 && (e2 = r(e2)), 8 & t2)
            return e2;
          if (4 & t2 && "object" == typeof e2 && e2 && e2.__esModule)
            return e2;
          var n = /* @__PURE__ */ Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: e2 }), 2 & t2 && "string" != typeof e2)
            for (var i in e2)
              r.d(n, i, function(t3) {
                return e2[t3];
              }.bind(null, i));
          return n;
        }, r.n = function(e2) {
          var t2 = e2 && e2.__esModule ? function() {
            return e2.default;
          } : function() {
            return e2;
          };
          return r.d(t2, "a", t2), t2;
        }, r.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, r.p = "", r(r.s = 184);
      }([function(e, t, r) {
        "use strict";
        function n(e2) {
          for (var r2 in e2)
            t.hasOwnProperty(r2) || (t[r2] = e2[r2]);
        }
        Object.defineProperty(t, "__esModule", { value: true }), n(r(240)), n(r(251)), n(r(175)), n(r(107)), n(r(29)), n(r(73)), n(r(106)), n(r(30)), n(r(252)), n(r(52)), n(r(97)), n(r(253)), n(r(37)), n(r(51)), n(r(173)), n(r(176)), n(r(172)), n(r(108)), n(r(254)), n(r(255)), n(r(256)), n(r(72)), n(r(177)), n(r(105)), n(r(17)), n(r(257)), n(r(12)), n(r(174));
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), function(e2) {
          e2[e2.Before = 0] = "Before", e2[e2.Equal = 1] = "Equal", e2[e2.After = 2] = "After";
        }(t.BoundaryPosition || (t.BoundaryPosition = {})), function(e2) {
          e2[e2.None = 0] = "None", e2[e2.Capturing = 1] = "Capturing", e2[e2.AtTarget = 2] = "AtTarget", e2[e2.Bubbling = 3] = "Bubbling";
        }(t.EventPhase || (t.EventPhase = {})), function(e2) {
          e2[e2.Element = 1] = "Element", e2[e2.Attribute = 2] = "Attribute", e2[e2.Text = 3] = "Text", e2[e2.CData = 4] = "CData", e2[e2.EntityReference = 5] = "EntityReference", e2[e2.Entity = 6] = "Entity", e2[e2.ProcessingInstruction = 7] = "ProcessingInstruction", e2[e2.Comment = 8] = "Comment", e2[e2.Document = 9] = "Document", e2[e2.DocumentType = 10] = "DocumentType", e2[e2.DocumentFragment = 11] = "DocumentFragment", e2[e2.Notation = 12] = "Notation";
        }(t.NodeType || (t.NodeType = {})), function(e2) {
          e2[e2.Disconnected = 1] = "Disconnected", e2[e2.Preceding = 2] = "Preceding", e2[e2.Following = 4] = "Following", e2[e2.Contains = 8] = "Contains", e2[e2.ContainedBy = 16] = "ContainedBy", e2[e2.ImplementationSpecific = 32] = "ImplementationSpecific";
        }(t.Position || (t.Position = {})), function(e2) {
          e2[e2.Accept = 1] = "Accept", e2[e2.Reject = 2] = "Reject", e2[e2.Skip = 3] = "Skip";
        }(t.FilterResult || (t.FilterResult = {})), function(e2) {
          e2[e2.All = 4294967295] = "All", e2[e2.Element = 1] = "Element", e2[e2.Attribute = 2] = "Attribute", e2[e2.Text = 4] = "Text", e2[e2.CDataSection = 8] = "CDataSection", e2[e2.EntityReference = 16] = "EntityReference", e2[e2.Entity = 32] = "Entity", e2[e2.ProcessingInstruction = 64] = "ProcessingInstruction", e2[e2.Comment = 128] = "Comment", e2[e2.Document = 256] = "Document", e2[e2.DocumentType = 512] = "DocumentType", e2[e2.DocumentFragment = 1024] = "DocumentFragment", e2[e2.Notation = 2048] = "Notation";
        }(t.WhatToShow || (t.WhatToShow = {})), function(e2) {
          e2[e2.StartToStart = 0] = "StartToStart", e2[e2.StartToEnd = 1] = "StartToEnd", e2[e2.EndToEnd = 2] = "EndToEnd", e2[e2.EndToStart = 3] = "EndToStart";
        }(t.HowToCompare || (t.HowToCompare = {}));
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(212);
        t.FixedSizeSet = i.FixedSizeSet;
        var o = r(213);
        t.ObjectCache = o.ObjectCache;
        var a = r(214);
        t.CompareCache = a.CompareCache;
        var s = r(215);
        t.Lazy = s.Lazy;
        var u = r(216);
        function l(e2, t2, r2) {
          if (m(e2))
            e2.forEach(function(e3, n3) {
              return t2.call(r2, n3, e3);
            });
          else
            for (var n2 in e2)
              e2.hasOwnProperty(n2) && t2.call(r2, n2, e2[n2]);
        }
        function c(e2) {
          var t2, r2;
          if (h(e2))
            return e2;
          if (f(e2)) {
            var i2 = [];
            try {
              for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                i2.push(c(s2));
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
              } finally {
                if (t2)
                  throw t2.error;
              }
            }
            return i2;
          }
          if (p(e2)) {
            i2 = {};
            for (var u2 in e2)
              if (e2.hasOwnProperty(u2)) {
                var l2 = e2[u2];
                i2[u2] = c(l2);
              }
            return i2;
          }
          return e2;
        }
        function h(e2) {
          return !!e2 && "[object Function]" === Object.prototype.toString.call(e2);
        }
        function p(e2) {
          var t2 = typeof e2;
          return !!e2 && ("function" === t2 || "object" === t2);
        }
        function f(e2) {
          return Array.isArray(e2);
        }
        function d(e2) {
          return e2 instanceof Set;
        }
        function m(e2) {
          return e2 instanceof Map;
        }
        function y(e2) {
          if (p(e2)) {
            var t2 = Object.getPrototypeOf(e2), r2 = t2.constructor;
            return t2 && r2 && "function" == typeof r2 && r2 instanceof r2 && Function.prototype.toString.call(r2) === Function.prototype.toString.call(Object);
          }
          return false;
        }
        t.StringWalker = u.StringWalker, t.applyMixin = function(e2, t2) {
          for (var r2 = [], n2 = 2; n2 < arguments.length; n2++)
            r2[n2 - 2] = arguments[n2];
          Object.getOwnPropertyNames(t2.prototype).forEach(function(n3) {
            if ("constructor" !== n3) {
              if (-1 !== r2.indexOf(n3)) {
                var i2 = Object.getOwnPropertyDescriptor(e2.prototype, n3);
                i2 && Object.defineProperty(e2.prototype, "_" + n3, i2);
              }
              var o2 = Object.getOwnPropertyDescriptor(t2.prototype, n3);
              o2 && Object.defineProperty(e2.prototype, n3, o2);
            }
          });
        }, t.applyDefaults = function e2(t2, r2, n2) {
          void 0 === n2 && (n2 = false);
          var i2 = c(t2 || {});
          return l(r2, function(t3, r3) {
            y(r3) ? i2[t3] = e2(i2[t3], r3, n2) : (n2 || void 0 === i2[t3]) && (i2[t3] = r3);
          }), i2;
        }, t.forEachArray = function(e2, t2, r2) {
          e2.forEach(t2, r2);
        }, t.forEachObject = l, t.arrayLength = function(e2) {
          return d(e2) ? e2.size : e2.length;
        }, t.objectLength = function(e2) {
          return m(e2) ? e2.size : Object.keys(e2).length;
        }, t.getObjectValue = function(e2, t2) {
          return m(e2) ? e2.get(t2) : e2[t2];
        }, t.removeObjectValue = function(e2, t2) {
          m(e2) ? e2.delete(t2) : delete e2[t2];
        }, t.clone = c, t.isBoolean = function(e2) {
          return "boolean" == typeof e2;
        }, t.isNumber = function(e2) {
          return "number" == typeof e2;
        }, t.isString = function(e2) {
          return "string" == typeof e2;
        }, t.isFunction = h, t.isObject = p, t.isArray = f, t.isSet = d, t.isMap = m, t.isEmpty = function(e2) {
          if (f(e2))
            return !e2.length;
          if (d(e2))
            return !e2.size;
          if (m(e2))
            return !e2.size;
          if (p(e2)) {
            for (var t2 in e2)
              if (e2.hasOwnProperty(t2))
                return false;
            return true;
          }
          return false;
        }, t.isPlainObject = y, t.isIterable = function(e2) {
          return e2 && "function" == typeof e2[Symbol.iterator];
        }, t.getValue = function(e2) {
          return h(e2.valueOf) ? e2.valueOf() : e2;
        }, t.utf8Encode = function(e2) {
          for (var t2 = new Uint8Array(4 * e2.length), r2 = 0, n2 = 0; n2 < e2.length; n2++) {
            var i2 = e2.charCodeAt(n2);
            if (i2 < 128)
              t2[r2++] = i2;
            else {
              if (i2 < 2048)
                t2[r2++] = i2 >> 6 | 192;
              else {
                if (i2 > 55295 && i2 < 56320) {
                  if (++n2 >= e2.length)
                    throw new Error("Incomplete surrogate pair.");
                  var o2 = e2.charCodeAt(n2);
                  if (o2 < 56320 || o2 > 57343)
                    throw new Error("Invalid surrogate character.");
                  i2 = 65536 + ((1023 & i2) << 10) + (1023 & o2), t2[r2++] = i2 >> 18 | 240, t2[r2++] = i2 >> 12 & 63 | 128;
                } else
                  t2[r2++] = i2 >> 12 | 224;
                t2[r2++] = i2 >> 6 & 63 | 128;
              }
              t2[r2++] = 63 & i2 | 128;
            }
          }
          return t2.subarray(0, r2);
        }, t.utf8Decode = function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; ) {
            var n2 = e2[r2++];
            if (n2 > 127)
              if (n2 > 191 && n2 < 224) {
                if (r2 >= e2.length)
                  throw new Error("Incomplete 2-byte sequence.");
                n2 = (31 & n2) << 6 | 63 & e2[r2++];
              } else if (n2 > 223 && n2 < 240) {
                if (r2 + 1 >= e2.length)
                  throw new Error("Incomplete 3-byte sequence.");
                n2 = (15 & n2) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++];
              } else {
                if (!(n2 > 239 && n2 < 248))
                  throw new Error("Unknown multi-byte start.");
                if (r2 + 2 >= e2.length)
                  throw new Error("Incomplete 4-byte sequence.");
                n2 = (7 & n2) << 18 | (63 & e2[r2++]) << 12 | (63 & e2[r2++]) << 6 | 63 & e2[r2++];
              }
            if (n2 <= 65535)
              t2 += String.fromCharCode(n2);
            else {
              if (!(n2 <= 1114111))
                throw new Error("Code point exceeds UTF-16 limit.");
              n2 -= 65536, t2 += String.fromCharCode(n2 >> 10 | 55296), t2 += String.fromCharCode(1023 & n2 | 56320);
            }
          }
          return t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(241);
        t.Cast = n.Cast;
        var i = r(150);
        t.Guard = i.Guard;
        var o = r(242);
        t.EmptySet = o.EmptySet;
      }, function(e, t, r) {
        var n = r(11), i = r(55).f, o = r(21), a = r(25), s = r(80), u = r(119), l = r(123);
        e.exports = function(e2, t2) {
          var r2, c, h, p, f, d = e2.target, m = e2.global, y = e2.stat;
          if (r2 = m ? n : y ? n[d] || s(d, {}) : (n[d] || {}).prototype)
            for (c in t2) {
              if (p = t2[c], h = e2.noTargetGet ? (f = i(r2, c)) && f.value : r2[c], !l(m ? c : d + (y ? "." : "#") + c, e2.forced) && void 0 !== h) {
                if (typeof p == typeof h)
                  continue;
                u(p, h);
              }
              (e2.sham || h && h.sham) && o(p, "sham", true), a(r2, c, p, e2);
            }
        };
      }, function(e, t, r) {
        var n = r(11), i = r(81), o = r(14), a = r(58), s = r(86), u = r(124), l = i("wks"), c = n.Symbol, h = u ? c : c && c.withoutSetter || a;
        e.exports = function(e2) {
          return o(l, e2) || (s && o(c, e2) ? l[e2] = c[e2] : l[e2] = h("Symbol." + e2)), l[e2];
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = r(29), o = function() {
          function e2() {
            this._features = { mutationObservers: true, customElements: true, slots: true, steps: true }, this._window = null, this._compareCache = new n.CompareCache(), this._rangeList = new n.FixedSizeSet();
          }
          return e2.prototype.setFeatures = function(e3) {
            if (void 0 === e3 && (e3 = true), n.isObject(e3))
              for (var t2 in e3)
                this._features[t2] = e3[t2] || false;
            else
              for (var t2 in this._features)
                this._features[t2] = e3;
          }, Object.defineProperty(e2.prototype, "features", { get: function() {
            return this._features;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "window", { get: function() {
            return null === this._window && (this._window = i.create_window()), this._window;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "compareCache", { get: function() {
            return this._compareCache;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "rangeList", { get: function() {
            return this._rangeList;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2, "instance", { get: function() {
            return e2._instance || (e2._instance = new e2()), e2._instance;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.dom = o.instance;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var r2 in e2)
              Object.hasOwnProperty.call(e2, r2) && (t2[r2] = e2[r2]);
          return t2.default = e2, t2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = n(r(228));
        t.base64 = i;
        var o = n(r(146));
        t.byte = o;
        var a = n(r(147));
        t.byteSequence = a;
        var s = n(r(96));
        t.codePoint = s;
        var u = n(r(232));
        t.json = u;
        var l = n(r(233));
        t.list = l;
        var c = n(r(234));
        t.map = c;
        var h = n(r(235));
        t.namespace = h;
        var p = n(r(236));
        t.queue = p;
        var f = n(r(237));
        t.set = f;
        var d = n(r(238));
        t.stack = d;
        var m = n(r(239));
        t.string = m;
      }, function(e, t) {
        e.exports = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        };
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = e2.call(this, r2) || this;
            return n2.name = t3, n2;
          }
          return i(t2, e2), t2;
        }(Error);
        t.DOMException = o;
        var a = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "DOMStringSizeError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.DOMStringSizeError = a;
        var s = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "WrongDocumentError", "The object is in the wrong document. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.WrongDocumentError = s;
        var u = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NoDataAllowedError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NoDataAllowedError = u;
        var l = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NoModificationAllowedError", "The object can not be modified. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NoModificationAllowedError = l;
        var c = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NotSupportedError", "The operation is not supported. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NotSupportedError = c;
        var h = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InUseAttributeError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InUseAttributeError = h;
        var p = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidStateError", "The object is in an invalid state. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidStateError = p;
        var f = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidModificationError", "The object can not be modified in this way. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidModificationError = f;
        var d = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NamespaceError = d;
        var m = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidAccessError", "The object does not support the operation or argument. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidAccessError = m;
        var y = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "ValidationError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.ValidationError = y;
        var v = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "TypeMismatchError", t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.TypeMismatchError = v;
        var _ = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "SecurityError", "The operation is insecure. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.SecurityError = _;
        var g = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NetworkError", "A network error occurred. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NetworkError = g;
        var b = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "AbortError", "The operation was aborted. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.AbortError = b;
        var x = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "URLMismatchError", "The given URL does not match another URL. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.URLMismatchError = x;
        var w = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "QuotaExceededError", "The quota has been exceeded. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.QuotaExceededError = w;
        var E = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "TimeoutError", "The operation timed out. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.TimeoutError = E;
        var D = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidNodeTypeError = D;
        var S = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "DataCloneError", "The object can not be cloned. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.DataCloneError = S;
        var C = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NotImplementedError", "The DOM method is not implemented by this module. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NotImplementedError = C;
        var A = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "HierarchyRequestError", "The operation would yield an incorrect node tree. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.HierarchyRequestError = A;
        var N = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "NotFoundError", "The object can not be found here. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.NotFoundError = N;
        var T = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "IndexSizeError", "The index is not in the allowed range. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.IndexSizeError = T;
        var O = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "SyntaxError", "The string did not match the expected pattern. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.SyntaxError = O;
        var F = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, "InvalidCharacterError", "The string contains invalid characters. " + t3) || this;
          }
          return i(t2, e2), t2;
        }(o);
        t.InvalidCharacterError = F;
      }, function(e, t, r) {
        "use strict";
        var n = r(53), i = ["kind", "resolve", "construct", "instanceOf", "predicate", "represent", "defaultStyle", "styleAliases"], o = ["scalar", "sequence", "mapping"];
        e.exports = function(e2, t2) {
          var r2, a;
          if (t2 = t2 || {}, Object.keys(t2).forEach(function(t3) {
            if (-1 === i.indexOf(t3))
              throw new n('Unknown option "' + t3 + '" is met in definition of "' + e2 + '" YAML type.');
          }), this.tag = e2, this.kind = t2.kind || null, this.resolve = t2.resolve || function() {
            return true;
          }, this.construct = t2.construct || function(e3) {
            return e3;
          }, this.instanceOf = t2.instanceOf || null, this.predicate = t2.predicate || null, this.represent = t2.represent || null, this.defaultStyle = t2.defaultStyle || null, this.styleAliases = (r2 = t2.styleAliases || null, a = {}, null !== r2 && Object.keys(r2).forEach(function(e3) {
            r2[e3].forEach(function(t3) {
              a[String(t3)] = e3;
            });
          }), a), -1 === o.indexOf(this.kind))
            throw new n('Unknown kind "' + this.kind + '" is specified for "' + e2 + '" YAML type.');
        };
      }, function(e, t, r) {
        (function(t2) {
          var r2 = function(e2) {
            return e2 && e2.Math == Math && e2;
          };
          e.exports = r2("object" == typeof globalThis && globalThis) || r2("object" == typeof window && window) || r2("object" == typeof self && self) || r2("object" == typeof t2 && t2) || Function("return this")();
        }).call(this, r(78));
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.idl_defineConst = function(e2, t2, r2) {
          Object.defineProperty(e2, t2, { writable: false, enumerable: true, configurable: false, value: r2 });
        };
      }, function(e, t) {
        e.exports = function(e2) {
          return "object" == typeof e2 ? null !== e2 : "function" == typeof e2;
        };
      }, function(e, t) {
        var r = {}.hasOwnProperty;
        e.exports = function(e2, t2) {
          return r.call(e2, t2);
        };
      }, function(e, t, r) {
        var n = r(16), i = r(115), o = r(18), a = r(56), s = Object.defineProperty;
        t.f = n ? s : function(e2, t2, r2) {
          if (o(e2), t2 = a(t2, true), o(r2), i)
            try {
              return s(e2, t2, r2);
            } catch (e3) {
            }
          if ("get" in r2 || "set" in r2)
            throw TypeError("Accessors not supported");
          return "value" in r2 && (e2[t2] = r2.value), e2;
        };
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !n(function() {
          return 7 != Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1];
        });
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(3), o = r(1);
        function a(e2, t2, r2) {
          if (void 0 === r2 && (r2 = false), r2 && i.Guard.isElementNode(t2) && i.Guard.isShadowRoot(t2.shadowRoot) && t2.shadowRoot._firstChild)
            return t2.shadowRoot._firstChild;
          if (t2._firstChild)
            return t2._firstChild;
          if (t2 === e2)
            return null;
          if (t2._nextSibling)
            return t2._nextSibling;
          for (var n2 = t2._parent; n2 && n2 !== e2; ) {
            if (n2._nextSibling)
              return n2._nextSibling;
            n2 = n2._parent;
          }
          return null;
        }
        function s() {
          var e2;
          return (e2 = {})[Symbol.iterator] = function() {
            return { next: function() {
              return { done: true, value: null };
            } };
          }, e2;
        }
        function u(e2, t2, r2, n2) {
          void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false);
          for (var i2 = t2 ? e2 : a(e2, e2, r2); i2 && n2 && !n2(i2); )
            i2 = a(e2, i2, r2);
          return i2;
        }
        function l(e2, t2, r2, n2, i2) {
          void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
          for (var o2 = a(e2, t2, n2); o2 && i2 && !i2(o2); )
            o2 = a(e2, o2, n2);
          return o2;
        }
        function c(e2, t2, r2, n2) {
          var i2;
          return void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false), t2 || 0 !== e2._children.size ? ((i2 = {})[Symbol.iterator] = function() {
            var i3 = t2 ? e2 : a(e2, e2, r2);
            return { next: function() {
              for (; i3 && n2 && !n2(i3); )
                i3 = a(e2, i3, r2);
              if (null === i3)
                return { done: true, value: null };
              var t3 = { done: false, value: i3 };
              return i3 = a(e2, i3, r2), t3;
            } };
          }, i2) : s();
        }
        function h(e2, t2, r2) {
          void 0 === t2 && (t2 = false);
          for (var n2 = t2 ? e2 : e2._parent; n2 && r2 && !r2(n2); )
            n2 = n2._parent;
          return n2;
        }
        function p(e2, t2, r2, n2) {
          void 0 === r2 && (r2 = false);
          for (var i2 = t2._parent; i2 && n2 && !n2(i2); )
            i2 = i2._parent;
          return i2;
        }
        function f(e2) {
          return i.Guard.isDocumentTypeNode(e2) ? 0 : i.Guard.isCharacterDataNode(e2) ? e2._data.length : e2._children.size;
        }
        function d(e2, t2) {
          if (void 0 === t2 && (t2 = false), t2) {
            var r2 = d(e2, false);
            return i.Guard.isShadowRoot(r2) ? d(r2._host, true) : r2;
          }
          return e2._parent ? d(e2._parent) : e2;
        }
        function m(e2, t2, r2, n2) {
          void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
          for (var o2 = r2 ? e2 : n2 && i.Guard.isShadowRoot(e2) ? e2._host : e2._parent; null !== o2; ) {
            if (o2 === t2)
              return true;
            o2 = n2 && i.Guard.isShadowRoot(o2) ? o2._host : o2._parent;
          }
          return false;
        }
        function y(e2) {
          for (var t2 = d(e2), r2 = 0, n2 = u(t2); null !== n2; ) {
            if (r2++, n2 === e2)
              return r2;
            n2 = l(t2, n2);
          }
          return -1;
        }
        t.tree_getFirstDescendantNode = u, t.tree_getNextDescendantNode = l, t.tree_getDescendantNodes = c, t.tree_getDescendantElements = function(e2, t2, r2, n2) {
          var o2;
          return void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false), t2 || 0 !== e2._children.size ? ((o2 = {})[Symbol.iterator] = function() {
            var o3 = c(e2, t2, r2, function(e3) {
              return i.Guard.isElementNode(e3);
            })[Symbol.iterator](), a2 = o3.next().value;
            return { next: function() {
              for (; a2 && n2 && !n2(a2); )
                a2 = o3.next().value;
              if (null === a2)
                return { done: true, value: null };
              var e3 = { done: false, value: a2 };
              return a2 = o3.next().value, e3;
            } };
          }, o2) : s();
        }, t.tree_getSiblingNodes = function(e2, t2, r2) {
          var n2;
          return void 0 === t2 && (t2 = false), e2._parent && 0 !== e2._parent._children.size ? ((n2 = {})[Symbol.iterator] = function() {
            var n3 = e2._parent ? e2._parent._firstChild : null;
            return { next: function() {
              for (; n3 && (r2 && !r2(n3) || !t2 && n3 === e2); )
                n3 = n3._nextSibling;
              if (null === n3)
                return { done: true, value: null };
              var i2 = { done: false, value: n3 };
              return n3 = n3._nextSibling, i2;
            } };
          }, n2) : s();
        }, t.tree_getFirstAncestorNode = h, t.tree_getNextAncestorNode = p, t.tree_getAncestorNodes = function(e2, t2, r2) {
          var n2;
          return void 0 === t2 && (t2 = false), t2 || e2._parent ? ((n2 = {})[Symbol.iterator] = function() {
            var n3 = h(e2, t2, r2);
            return { next: function() {
              if (null === n3)
                return { done: true, value: null };
              var e3 = { done: false, value: n3 };
              return n3 = p(0, n3, t2, r2), e3;
            } };
          }, n2) : s();
        }, t.tree_getCommonAncestor = function(e2, t2) {
          if (e2 === t2)
            return e2._parent;
          for (var r2 = [], n2 = [], i2 = h(e2, true); null !== i2; )
            r2.push(i2), i2 = p(0, i2, true);
          for (var o2 = h(t2, true); null !== o2; )
            n2.push(o2), o2 = p(0, o2, true);
          for (var a2 = r2.length, s2 = n2.length, u2 = null, l2 = Math.min(a2, s2); l2 > 0; l2--) {
            var c2 = r2[--a2];
            if (c2 !== n2[--s2])
              break;
            u2 = c2;
          }
          return u2;
        }, t.tree_getFollowingNode = function(e2, t2) {
          if (t2._firstChild)
            return t2._firstChild;
          if (t2._nextSibling)
            return t2._nextSibling;
          for (; ; ) {
            var r2 = t2._parent;
            if (null === r2 || r2 === e2)
              return null;
            if (r2._nextSibling)
              return r2._nextSibling;
            t2 = r2;
          }
        }, t.tree_getPrecedingNode = function(e2, t2) {
          return t2 === e2 ? null : t2._previousSibling ? (t2 = t2._previousSibling)._lastChild ? t2._lastChild : t2 : t2._parent;
        }, t.tree_isConstrained = function e2(t2) {
          var r2, i2, a2, s2, u2, l2;
          switch (t2._nodeType) {
            case o.NodeType.Document:
              var c2 = false, h2 = false;
              try {
                for (var p2 = n(t2._children), f2 = p2.next(); !f2.done; f2 = p2.next()) {
                  switch (f2.value._nodeType) {
                    case o.NodeType.ProcessingInstruction:
                    case o.NodeType.Comment:
                      break;
                    case o.NodeType.DocumentType:
                      if (c2 || h2)
                        return false;
                      c2 = true;
                      break;
                    case o.NodeType.Element:
                      if (h2)
                        return false;
                      h2 = true;
                      break;
                    default:
                      return false;
                  }
                }
              } catch (e3) {
                r2 = { error: e3 };
              } finally {
                try {
                  f2 && !f2.done && (i2 = p2.return) && i2.call(p2);
                } finally {
                  if (r2)
                    throw r2.error;
                }
              }
              break;
            case o.NodeType.DocumentFragment:
            case o.NodeType.Element:
              try {
                for (var d2 = n(t2._children), m2 = d2.next(); !m2.done; m2 = d2.next()) {
                  switch (m2.value._nodeType) {
                    case o.NodeType.Element:
                    case o.NodeType.Text:
                    case o.NodeType.ProcessingInstruction:
                    case o.NodeType.CData:
                    case o.NodeType.Comment:
                      break;
                    default:
                      return false;
                  }
                }
              } catch (e3) {
                a2 = { error: e3 };
              } finally {
                try {
                  m2 && !m2.done && (s2 = d2.return) && s2.call(d2);
                } finally {
                  if (a2)
                    throw a2.error;
                }
              }
              break;
            case o.NodeType.DocumentType:
            case o.NodeType.Text:
            case o.NodeType.ProcessingInstruction:
            case o.NodeType.CData:
            case o.NodeType.Comment:
              return !t2.hasChildNodes();
          }
          try {
            for (var y2 = n(t2._children), v = y2.next(); !v.done; v = y2.next()) {
              if (!e2(v.value))
                return false;
            }
          } catch (e3) {
            u2 = { error: e3 };
          } finally {
            try {
              v && !v.done && (l2 = y2.return) && l2.call(y2);
            } finally {
              if (u2)
                throw u2.error;
            }
          }
          return true;
        }, t.tree_nodeLength = f, t.tree_isEmpty = function(e2) {
          return 0 === f(e2);
        }, t.tree_rootNode = d, t.tree_isDescendantOf = function(e2, t2, r2, n2) {
          void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
          for (var i2 = u(e2, r2, n2); null !== i2; ) {
            if (i2 === t2)
              return true;
            i2 = l(e2, i2, r2, n2);
          }
          return false;
        }, t.tree_isAncestorOf = m, t.tree_isHostIncludingAncestorOf = function e2(t2, r2, n2) {
          if (void 0 === n2 && (n2 = false), m(t2, r2, n2))
            return true;
          var o2 = d(t2);
          return !(!i.Guard.isDocumentFragmentNode(o2) || null === o2._host || !e2(o2._host, r2, n2));
        }, t.tree_isSiblingOf = function(e2, t2, r2) {
          return void 0 === r2 && (r2 = false), e2 !== t2 ? null !== e2._parent && e2._parent === t2._parent : !!r2;
        }, t.tree_isPreceding = function(e2, t2) {
          var r2 = y(e2), n2 = y(t2);
          return -1 !== r2 && -1 !== n2 && (d(e2) === d(t2) && n2 < r2);
        }, t.tree_isFollowing = function(e2, t2) {
          var r2 = y(e2), n2 = y(t2);
          return -1 !== r2 && -1 !== n2 && (d(e2) === d(t2) && n2 > r2);
        }, t.tree_isParentOf = function(e2, t2) {
          return e2._parent === t2;
        }, t.tree_isChildOf = function(e2, t2) {
          return t2._parent === e2;
        }, t.tree_previousSibling = function(e2) {
          return e2._previousSibling;
        }, t.tree_nextSibling = function(e2) {
          return e2._nextSibling;
        }, t.tree_firstChild = function(e2) {
          return e2._firstChild;
        }, t.tree_lastChild = function(e2) {
          return e2._lastChild;
        }, t.tree_treePosition = y, t.tree_index = function(e2) {
          for (var t2 = 0; null !== e2._previousSibling; )
            t2++, e2 = e2._previousSibling;
          return t2;
        }, t.tree_retarget = function(e2, t2) {
          for (; ; ) {
            if (!e2 || !i.Guard.isNode(e2))
              return e2;
            var r2 = d(e2);
            if (!i.Guard.isShadowRoot(r2))
              return e2;
            if (t2 && i.Guard.isNode(t2) && m(r2, t2, true, true))
              return e2;
            e2 = r2.host;
          }
        };
      }, function(e, t, r) {
        var n = r(13);
        e.exports = function(e2) {
          if (!n(e2))
            throw TypeError(String(e2) + " is not an object");
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(24), i = r(130), o = r(49), a = r(43), s = r(88), u = a.set, l = a.getterFor("Array Iterator");
        e.exports = s(Array, "Array", function(e2, t2) {
          u(this, { type: "Array Iterator", target: n(e2), index: 0, kind: t2 });
        }, function() {
          var e2 = l(this), t2 = e2.target, r2 = e2.kind, n2 = e2.index++;
          return !t2 || n2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : "keys" == r2 ? { value: n2, done: false } : "values" == r2 ? { value: t2[n2], done: false } : { value: [n2, t2[n2]], done: false };
        }, "values"), o.Arguments = o.Array, i("keys"), i("values"), i("entries");
      }, function(e, t, r) {
        var n = r(90), i = r(25), o = r(202);
        n || i(Object.prototype, "toString", o, { unsafe: true });
      }, function(e, t, r) {
        var n = r(16), i = r(15), o = r(40);
        e.exports = n ? function(e2, t2, r2) {
          return i.f(e2, t2, o(1, r2));
        } : function(e2, t2, r2) {
          return e2[t2] = r2, e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(137).charAt, i = r(43), o = r(88), a = i.set, s = i.getterFor("String Iterator");
        o(String, "String", function(e2) {
          a(this, { type: "String Iterator", string: String(e2), index: 0 });
        }, function() {
          var e2, t2 = s(this), r2 = t2.string, i2 = t2.index;
          return i2 >= r2.length ? { value: void 0, done: true } : (e2 = n(r2, i2), t2.index += e2.length, { value: e2, done: false });
        });
      }, function(e, t, r) {
        var n = r(11), i = r(203), o = r(19), a = r(21), s = r(5), u = s("iterator"), l = s("toStringTag"), c = o.values;
        for (var h in i) {
          var p = n[h], f = p && p.prototype;
          if (f) {
            if (f[u] !== c)
              try {
                a(f, u, c);
              } catch (e2) {
                f[u] = c;
              }
            if (f[l] || a(f, l, h), i[h]) {
              for (var d in o)
                if (f[d] !== o[d])
                  try {
                    a(f, d, o[d]);
                  } catch (e2) {
                    f[d] = o[d];
                  }
            }
          }
        }
      }, function(e, t, r) {
        var n = r(41), i = r(35);
        e.exports = function(e2) {
          return n(i(e2));
        };
      }, function(e, t, r) {
        var n = r(11), i = r(21), o = r(14), a = r(80), s = r(117), u = r(43), l = u.get, c = u.enforce, h = String(String).split("String");
        (e.exports = function(e2, t2, r2, s2) {
          var u2 = !!s2 && !!s2.unsafe, l2 = !!s2 && !!s2.enumerable, p = !!s2 && !!s2.noTargetGet;
          "function" == typeof r2 && ("string" != typeof t2 || o(r2, "name") || i(r2, "name", t2), c(r2).source = h.join("string" == typeof t2 ? t2 : "")), e2 !== n ? (u2 ? !p && e2[t2] && (l2 = true) : delete e2[t2], l2 ? e2[t2] = r2 : i(e2, t2, r2)) : l2 ? e2[t2] = r2 : a(t2, r2);
        })(Function.prototype, "toString", function() {
          return "function" == typeof this && l(this).source || s(this);
        });
      }, function(e, t, r) {
        var n = r(47), i = Math.min;
        e.exports = function(e2) {
          return e2 > 0 ? i(n(e2), 9007199254740991) : 0;
        };
      }, function(e, t, r) {
        var n = r(35);
        e.exports = function(e2) {
          return Object(n(e2));
        };
      }, function(e, t, r) {
        var n = r(16), i = r(8), o = r(14), a = Object.defineProperty, s = {}, u = function(e2) {
          throw e2;
        };
        e.exports = function(e2, t2) {
          if (o(s, e2))
            return s[e2];
          t2 || (t2 = {});
          var r2 = [][e2], l = !!o(t2, "ACCESSORS") && t2.ACCESSORS, c = o(t2, 0) ? t2[0] : u, h = o(t2, 1) ? t2[1] : void 0;
          return s[e2] = !!r2 && !i(function() {
            if (l && !n)
              return true;
            var e3 = { length: -1 };
            l ? a(e3, 1, { enumerable: true, get: u }) : e3[1] = 1, r2.call(e3, c, h);
          });
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(148), i = r(149), o = r(151), a = r(98), s = r(153), u = r(154), l = r(155), c = r(99), h = r(100), p = r(156), f = r(157), d = r(101), m = r(158), y = r(159), v = r(160), _ = r(161), g = r(162), b = r(163), x = r(164), w = r(165), E = r(166), D = r(167), S = r(168), C = r(169), A = r(170);
        t.create_domImplementation = function(e2) {
          return n.DOMImplementationImpl._create(e2);
        }, t.create_window = function() {
          return i.WindowImpl._create();
        }, t.create_xmlDocument = function() {
          return new o.XMLDocumentImpl();
        }, t.create_document = function() {
          return new a.DocumentImpl();
        }, t.create_abortController = function() {
          return new s.AbortControllerImpl();
        }, t.create_abortSignal = function() {
          return u.AbortSignalImpl._create();
        }, t.create_documentType = function(e2, t2, r2, n2) {
          return l.DocumentTypeImpl._create(e2, t2, r2, n2);
        }, t.create_element = function(e2, t2, r2, n2) {
          return c.ElementImpl._create(e2, t2, r2, n2);
        }, t.create_htmlElement = function(e2, t2, r2, n2) {
          return c.ElementImpl._create(e2, t2, r2, n2);
        }, t.create_htmlUnknownElement = function(e2, t2, r2, n2) {
          return c.ElementImpl._create(e2, t2, r2, n2);
        }, t.create_documentFragment = function(e2) {
          return h.DocumentFragmentImpl._create(e2);
        }, t.create_shadowRoot = function(e2, t2) {
          return p.ShadowRootImpl._create(e2, t2);
        }, t.create_attr = function(e2, t2) {
          return f.AttrImpl._create(e2, t2);
        }, t.create_text = function(e2, t2) {
          return d.TextImpl._create(e2, t2);
        }, t.create_cdataSection = function(e2, t2) {
          return m.CDATASectionImpl._create(e2, t2);
        }, t.create_comment = function(e2, t2) {
          return y.CommentImpl._create(e2, t2);
        }, t.create_processingInstruction = function(e2, t2, r2) {
          return v.ProcessingInstructionImpl._create(e2, t2, r2);
        }, t.create_htmlCollection = function(e2, t2) {
          return void 0 === t2 && (t2 = function() {
            return true;
          }), _.HTMLCollectionImpl._create(e2, t2);
        }, t.create_nodeList = function(e2) {
          return g.NodeListImpl._create(e2);
        }, t.create_nodeListStatic = function(e2, t2) {
          return b.NodeListStaticImpl._create(e2, t2);
        }, t.create_namedNodeMap = function(e2) {
          return x.NamedNodeMapImpl._create(e2);
        }, t.create_range = function(e2, t2) {
          return w.RangeImpl._create(e2, t2);
        }, t.create_nodeIterator = function(e2, t2, r2) {
          return E.NodeIteratorImpl._create(e2, t2, r2);
        }, t.create_treeWalker = function(e2, t2) {
          return D.TreeWalkerImpl._create(e2, t2);
        }, t.create_nodeFilter = function() {
          return S.NodeFilterImpl._create();
        }, t.create_mutationRecord = function(e2, t2, r2, n2, i2, o2, a2, s2, u2) {
          return C.MutationRecordImpl._create(e2, t2, r2, n2, i2, o2, a2, s2, u2);
        }, t.create_domTokenList = function(e2, t2) {
          return A.DOMTokenListImpl._create(e2, t2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(17), a = r(3), s = r(72), u = /* @__PURE__ */ new Map();
        function l(e2, t2) {
          if (t2 !== e2._root && o.tree_isAncestorOf(e2._reference, t2, true)) {
            if (e2._pointerBeforeReference)
              for (; ; ) {
                var r2 = o.tree_getFollowingNode(e2._root, t2);
                if (null !== r2 && o.tree_isDescendantOf(e2._root, r2, true) && !o.tree_isDescendantOf(t2, r2, true))
                  return void (e2._reference = r2);
                if (null === r2)
                  return void (e2._pointerBeforeReference = false);
              }
            if (null === t2._previousSibling)
              null !== t2._parent && (e2._reference = t2._parent);
            else {
              for (var n2 = t2._previousSibling, i2 = o.tree_getFirstDescendantNode(t2._previousSibling, true, false); null !== i2; )
                null !== i2 && (n2 = i2), i2 = o.tree_getNextDescendantNode(t2._previousSibling, i2, true, false);
              e2._reference = n2;
            }
          }
        }
        function c(e2, t2, r2, n2, i2) {
          if (a.Guard.isSlot(e2) && "name" === t2 && null === i2) {
            if (n2 === r2)
              return;
            if (null === n2 && "" === r2)
              return;
            if ("" === n2 && null === r2)
              return;
            e2._name = null === n2 || "" === n2 ? "" : n2, s.shadowTree_assignSlotablesForATree(o.tree_rootNode(e2));
          }
        }
        function h(e2, t2, r2, n2, i2) {
          if (a.Guard.isSlotable(e2) && "slot" === t2 && null === i2) {
            if (n2 === r2)
              return;
            if (null === n2 && "" === r2)
              return;
            if ("" === n2 && null === r2)
              return;
            e2._name = null === n2 || "" === n2 ? "" : n2, s.shadowTree_isAssigned(e2) && s.shadowTree_assignSlotables(e2._assignedSlot), s.shadowTree_assignASlot(e2);
          }
        }
        function p(e2, t2, r2, n2) {
          "id" === t2 && null === n2 && (e2._uniqueIdentifier = r2 || void 0);
        }
        t.dom_runRemovingSteps = function(e2, t2) {
        }, t.dom_runCloningSteps = function(e2, t2, r2, n2) {
        }, t.dom_runAdoptingSteps = function(e2, t2) {
        }, t.dom_runAttributeChangeSteps = function(e2, t2, r2, o2, a2) {
          var s2, u2;
          i.dom.features.slots && (h.call(e2, e2, t2, r2, o2, a2), c.call(e2, e2, t2, r2, o2, a2)), p.call(e2, e2, t2, o2, a2);
          try {
            for (var l2 = n(e2._attributeChangeSteps), f = l2.next(); !f.done; f = l2.next()) {
              f.value.call(e2, e2, t2, r2, o2, a2);
            }
          } catch (e3) {
            s2 = { error: e3 };
          } finally {
            try {
              f && !f.done && (u2 = l2.return) && u2.call(l2);
            } finally {
              if (s2)
                throw s2.error;
            }
          }
        }, t.dom_runInsertionSteps = function(e2) {
        }, t.dom_runNodeIteratorPreRemovingSteps = function(e2, t2) {
          l.call(e2, e2, t2);
        }, t.dom_hasSupportedTokens = function(e2) {
          return u.has(e2);
        }, t.dom_getSupportedTokens = function(e2) {
          return u.get(e2) || /* @__PURE__ */ new Set();
        }, t.dom_runEventConstructingSteps = function(e2) {
        }, t.dom_runChildTextContentChangeSteps = function(e2) {
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(11), o = r(46), a = r(44), s = r(16), u = r(86), l = r(124), c = r(8), h = r(14), p = r(59), f = r(13), d = r(18), m = r(27), y = r(24), v = r(56), _ = r(40), g = r(60), b = r(61), x = r(82), w = r(190), E = r(85), D = r(55), S = r(15), C = r(79), A = r(21), N = r(25), T = r(81), O = r(57), F = r(45), k = r(58), P = r(5), I = r(125), L = r(126), M = r(62), B = r(43), j = r(36).forEach, R = O("hidden"), z = P("toPrimitive"), U = B.set, G = B.getterFor("Symbol"), X = Object.prototype, q = i.Symbol, W = o("JSON", "stringify"), H = D.f, J = S.f, Y = w.f, V = C.f, K = T("symbols"), $ = T("op-symbols"), Q = T("string-to-symbol-registry"), Z = T("symbol-to-string-registry"), ee = T("wks"), te = i.QObject, re = !te || !te.prototype || !te.prototype.findChild, ne = s && c(function() {
          return 7 != g(J({}, "a", { get: function() {
            return J(this, "a", { value: 7 }).a;
          } })).a;
        }) ? function(e2, t2, r2) {
          var n2 = H(X, t2);
          n2 && delete X[t2], J(e2, t2, r2), n2 && e2 !== X && J(X, t2, n2);
        } : J, ie = function(e2, t2) {
          var r2 = K[e2] = g(q.prototype);
          return U(r2, { type: "Symbol", tag: e2, description: t2 }), s || (r2.description = t2), r2;
        }, oe = l ? function(e2) {
          return "symbol" == typeof e2;
        } : function(e2) {
          return Object(e2) instanceof q;
        }, ae = function(e2, t2, r2) {
          e2 === X && ae($, t2, r2), d(e2);
          var n2 = v(t2, true);
          return d(r2), h(K, n2) ? (r2.enumerable ? (h(e2, R) && e2[R][n2] && (e2[R][n2] = false), r2 = g(r2, { enumerable: _(0, false) })) : (h(e2, R) || J(e2, R, _(1, {})), e2[R][n2] = true), ne(e2, n2, r2)) : J(e2, n2, r2);
        }, se = function(e2, t2) {
          d(e2);
          var r2 = y(t2), n2 = b(r2).concat(he(r2));
          return j(n2, function(t3) {
            s && !ue.call(r2, t3) || ae(e2, t3, r2[t3]);
          }), e2;
        }, ue = function(e2) {
          var t2 = v(e2, true), r2 = V.call(this, t2);
          return !(this === X && h(K, t2) && !h($, t2)) && (!(r2 || !h(this, t2) || !h(K, t2) || h(this, R) && this[R][t2]) || r2);
        }, le = function(e2, t2) {
          var r2 = y(e2), n2 = v(t2, true);
          if (r2 !== X || !h(K, n2) || h($, n2)) {
            var i2 = H(r2, n2);
            return !i2 || !h(K, n2) || h(r2, R) && r2[R][n2] || (i2.enumerable = true), i2;
          }
        }, ce = function(e2) {
          var t2 = Y(y(e2)), r2 = [];
          return j(t2, function(e3) {
            h(K, e3) || h(F, e3) || r2.push(e3);
          }), r2;
        }, he = function(e2) {
          var t2 = e2 === X, r2 = Y(t2 ? $ : y(e2)), n2 = [];
          return j(r2, function(e3) {
            !h(K, e3) || t2 && !h(X, e3) || n2.push(K[e3]);
          }), n2;
        };
        (u || (N((q = function() {
          if (this instanceof q)
            throw TypeError("Symbol is not a constructor");
          var e2 = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, t2 = k(e2), r2 = function(e3) {
            this === X && r2.call($, e3), h(this, R) && h(this[R], t2) && (this[R][t2] = false), ne(this, t2, _(1, e3));
          };
          return s && re && ne(X, t2, { configurable: true, set: r2 }), ie(t2, e2);
        }).prototype, "toString", function() {
          return G(this).tag;
        }), N(q, "withoutSetter", function(e2) {
          return ie(k(e2), e2);
        }), C.f = ue, S.f = ae, D.f = le, x.f = w.f = ce, E.f = he, I.f = function(e2) {
          return ie(P(e2), e2);
        }, s && (J(q.prototype, "description", { configurable: true, get: function() {
          return G(this).description;
        } }), a || N(X, "propertyIsEnumerable", ue, { unsafe: true }))), n({ global: true, wrap: true, forced: !u, sham: !u }, { Symbol: q }), j(b(ee), function(e2) {
          L(e2);
        }), n({ target: "Symbol", stat: true, forced: !u }, { for: function(e2) {
          var t2 = String(e2);
          if (h(Q, t2))
            return Q[t2];
          var r2 = q(t2);
          return Q[t2] = r2, Z[r2] = t2, r2;
        }, keyFor: function(e2) {
          if (!oe(e2))
            throw TypeError(e2 + " is not a symbol");
          if (h(Z, e2))
            return Z[e2];
        }, useSetter: function() {
          re = true;
        }, useSimple: function() {
          re = false;
        } }), n({ target: "Object", stat: true, forced: !u, sham: !s }, { create: function(e2, t2) {
          return void 0 === t2 ? g(e2) : se(g(e2), t2);
        }, defineProperty: ae, defineProperties: se, getOwnPropertyDescriptor: le }), n({ target: "Object", stat: true, forced: !u }, { getOwnPropertyNames: ce, getOwnPropertySymbols: he }), n({ target: "Object", stat: true, forced: c(function() {
          E.f(1);
        }) }, { getOwnPropertySymbols: function(e2) {
          return E.f(m(e2));
        } }), W) && n({ target: "JSON", stat: true, forced: !u || c(function() {
          var e2 = q();
          return "[null]" != W([e2]) || "{}" != W({ a: e2 }) || "{}" != W(Object(e2));
        }) }, { stringify: function(e2, t2, r2) {
          for (var n2, i2 = [e2], o2 = 1; arguments.length > o2; )
            i2.push(arguments[o2++]);
          if (n2 = t2, (f(t2) || void 0 !== e2) && !oe(e2))
            return p(t2) || (t2 = function(e3, t3) {
              if ("function" == typeof n2 && (t3 = n2.call(this, e3, t3)), !oe(t3))
                return t3;
            }), i2[1] = t2, W.apply(null, i2);
        } });
        q.prototype[z] || A(q.prototype, z, q.prototype.valueOf), M(q, "Symbol"), F[R] = true;
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(16), o = r(11), a = r(14), s = r(13), u = r(15).f, l = r(119), c = o.Symbol;
        if (i && "function" == typeof c && (!("description" in c.prototype) || void 0 !== c().description)) {
          var h = {}, p = function() {
            var e2 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]), t2 = this instanceof p ? new c(e2) : void 0 === e2 ? c() : c(e2);
            return "" === e2 && (h[t2] = true), t2;
          };
          l(p, c);
          var f = p.prototype = c.prototype;
          f.constructor = p;
          var d = f.toString, m = "Symbol(test)" == String(c("test")), y = /^Symbol\((.*)\)[^)]+$/;
          u(f, "description", { configurable: true, get: function() {
            var e2 = s(this) ? this.valueOf() : this, t2 = d.call(e2);
            if (a(h, e2))
              return "";
            var r2 = m ? t2.slice(7, -1) : t2.replace(y, "$1");
            return "" === r2 ? void 0 : r2;
          } }), n({ global: true, forced: true }, { Symbol: p });
        }
      }, function(e, t, r) {
        r(126)("iterator");
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(1), u = r(70), l = r(3), c = r(9), h = r(0), p = r(152), f = r(12), d = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._parent = null, t3._firstChild = null, t3._lastChild = null, t3._previousSibling = null, t3._nextSibling = null, t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "_childNodes", { get: function() {
            return this.__childNodes || (this.__childNodes = h.create_nodeList(this));
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_nodeDocument", { get: function() {
            return this._nodeDocumentOverride || a.dom.window._associatedDocument;
          }, set: function(e3) {
            this._nodeDocumentOverride = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_registeredObserverList", { get: function() {
            return this.__registeredObserverList || (this.__registeredObserverList = []);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nodeType", { get: function() {
            return this._nodeType;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nodeName", { get: function() {
            return l.Guard.isElementNode(this) ? this._htmlUppercasedQualifiedName : l.Guard.isAttrNode(this) ? this._qualifiedName : l.Guard.isExclusiveTextNode(this) ? "#text" : l.Guard.isCDATASectionNode(this) ? "#cdata-section" : l.Guard.isProcessingInstructionNode(this) ? this._target : l.Guard.isCommentNode(this) ? "#comment" : l.Guard.isDocumentNode(this) ? "#document" : l.Guard.isDocumentTypeNode(this) ? this._name : l.Guard.isDocumentFragmentNode(this) ? "#document-fragment" : "";
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "baseURI", { get: function() {
            return p.urlSerializer(this._nodeDocument._URL);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "isConnected", { get: function() {
            return l.Guard.isElementNode(this) && h.shadowTree_isConnected(this);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "ownerDocument", { get: function() {
            return this._nodeType === s.NodeType.Document ? null : this._nodeDocument;
          }, enumerable: true, configurable: true }), t2.prototype.getRootNode = function(e3) {
            return h.tree_rootNode(this, !!e3 && e3.composed);
          }, Object.defineProperty(t2.prototype, "parentNode", { get: function() {
            return this._nodeType === s.NodeType.Attribute ? null : this._parent;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "parentElement", { get: function() {
            return this._parent && l.Guard.isElementNode(this._parent) ? this._parent : null;
          }, enumerable: true, configurable: true }), t2.prototype.hasChildNodes = function() {
            return null !== this._firstChild;
          }, Object.defineProperty(t2.prototype, "childNodes", { get: function() {
            return this._childNodes;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstChild", { get: function() {
            return this._firstChild;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastChild", { get: function() {
            return this._lastChild;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "previousSibling", { get: function() {
            return this._previousSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nextSibling", { get: function() {
            return this._nextSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nodeValue", { get: function() {
            return l.Guard.isAttrNode(this) ? this._value : l.Guard.isCharacterDataNode(this) ? this._data : null;
          }, set: function(e3) {
            null === e3 && (e3 = ""), l.Guard.isAttrNode(this) ? h.attr_setAnExistingAttributeValue(this, e3) : l.Guard.isCharacterDataNode(this) && h.characterData_replaceData(this, 0, this._data.length, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "textContent", { get: function() {
            return l.Guard.isDocumentFragmentNode(this) || l.Guard.isElementNode(this) ? h.text_descendantTextContent(this) : l.Guard.isAttrNode(this) ? this._value : l.Guard.isCharacterDataNode(this) ? this._data : null;
          }, set: function(e3) {
            null === e3 && (e3 = ""), l.Guard.isDocumentFragmentNode(this) || l.Guard.isElementNode(this) ? h.node_stringReplaceAll(e3, this) : l.Guard.isAttrNode(this) ? h.attr_setAnExistingAttributeValue(this, e3) : l.Guard.isCharacterDataNode(this) && h.characterData_replaceData(this, 0, h.tree_nodeLength(this), e3);
          }, enumerable: true, configurable: true }), t2.prototype.normalize = function() {
            for (var e3, t3, r2, n2, i2 = [], s2 = h.tree_getFirstDescendantNode(this, false, false, function(e4) {
              return l.Guard.isExclusiveTextNode(e4);
            }); null !== s2; )
              i2.push(s2), s2 = h.tree_getNextDescendantNode(this, s2, false, false, function(e4) {
                return l.Guard.isExclusiveTextNode(e4);
              });
            for (var u2 = 0; u2 < i2.length; u2++) {
              var c2 = i2[u2];
              if (null !== c2._parent) {
                var p2 = h.tree_nodeLength(c2);
                if (0 !== p2) {
                  var f2 = [], d2 = "";
                  try {
                    for (var m = (e3 = void 0, o(h.text_contiguousExclusiveTextNodes(c2))), y = m.next(); !y.done; y = m.next()) {
                      var v = y.value;
                      f2.push(v), d2 += v._data;
                    }
                  } catch (t4) {
                    e3 = { error: t4 };
                  } finally {
                    try {
                      y && !y.done && (t3 = m.return) && t3.call(m);
                    } finally {
                      if (e3)
                        throw e3.error;
                    }
                  }
                  if (h.characterData_replaceData(c2, p2, 0, d2), 0 !== a.dom.rangeList.size)
                    for (var _ = c2._nextSibling; null !== _ && l.Guard.isExclusiveTextNode(_); ) {
                      var g = _, b = h.tree_index(g);
                      try {
                        for (var x = (r2 = void 0, o(a.dom.rangeList)), w = x.next(); !w.done; w = x.next()) {
                          var E = w.value;
                          E._start[0] === g && (E._start[0] = c2, E._start[1] += p2), E._end[0] === g && (E._end[0] = c2, E._end[1] += p2), E._start[0] === g._parent && E._start[1] === b && (E._start[0] = c2, E._start[1] = p2), E._end[0] === g._parent && E._end[1] === b && (E._end[0] = c2, E._end[1] = p2);
                        }
                      } catch (e4) {
                        r2 = { error: e4 };
                      } finally {
                        try {
                          w && !w.done && (n2 = x.return) && n2.call(x);
                        } finally {
                          if (r2)
                            throw r2.error;
                        }
                      }
                      p2 += h.tree_nodeLength(_), _ = _._nextSibling;
                    }
                  for (var D = 0; D < f2.length; D++) {
                    null !== (v = f2[D])._parent && h.mutation_remove(v, v._parent);
                  }
                } else
                  h.mutation_remove(c2, c2._parent);
              }
            }
          }, t2.prototype.cloneNode = function(e3) {
            if (void 0 === e3 && (e3 = false), l.Guard.isShadowRoot(this))
              throw new c.NotSupportedError();
            return h.node_clone(this, null, e3);
          }, t2.prototype.isEqualNode = function(e3) {
            return void 0 === e3 && (e3 = null), null !== e3 && h.node_equals(this, e3);
          }, t2.prototype.isSameNode = function(e3) {
            return void 0 === e3 && (e3 = null), this === e3;
          }, t2.prototype.compareDocumentPosition = function(e3) {
            if (e3 === this)
              return 0;
            var t3 = e3, r2 = this, n2 = null, i2 = null;
            if (l.Guard.isAttrNode(t3) && (t3 = (n2 = t3)._element), l.Guard.isAttrNode(r2) && (r2 = (i2 = r2)._element, n2 && t3 && t3 === r2))
              for (var o2 = 0; o2 < r2._attributeList.length; o2++) {
                var u2 = r2._attributeList[o2];
                if (h.node_equals(u2, n2))
                  return s.Position.ImplementationSpecific | s.Position.Preceding;
                if (h.node_equals(u2, i2))
                  return s.Position.ImplementationSpecific | s.Position.Following;
              }
            return null === t3 || null === r2 || h.tree_rootNode(t3) !== h.tree_rootNode(r2) ? s.Position.Disconnected | s.Position.ImplementationSpecific | (a.dom.compareCache.check(this, e3) ? s.Position.Preceding : s.Position.Following) : !n2 && h.tree_isAncestorOf(r2, t3) || i2 && t3 === r2 ? s.Position.Contains | s.Position.Preceding : !i2 && h.tree_isDescendantOf(r2, t3) || n2 && t3 === r2 ? s.Position.ContainedBy | s.Position.Following : h.tree_isPreceding(r2, t3) ? s.Position.Preceding : s.Position.Following;
          }, t2.prototype.contains = function(e3) {
            return null !== e3 && h.tree_isDescendantOf(this, e3, true);
          }, t2.prototype.lookupPrefix = function(e3) {
            return e3 ? l.Guard.isElementNode(this) ? h.node_locateANamespacePrefix(this, e3) : l.Guard.isDocumentNode(this) ? null === this.documentElement ? null : h.node_locateANamespacePrefix(this.documentElement, e3) : l.Guard.isDocumentTypeNode(this) || l.Guard.isDocumentFragmentNode(this) ? null : l.Guard.isAttrNode(this) ? null === this._element ? null : h.node_locateANamespacePrefix(this._element, e3) : null !== this._parent && l.Guard.isElementNode(this._parent) ? h.node_locateANamespacePrefix(this._parent, e3) : null : null;
          }, t2.prototype.lookupNamespaceURI = function(e3) {
            return h.node_locateANamespace(this, e3 || null);
          }, t2.prototype.isDefaultNamespace = function(e3) {
            return e3 || (e3 = null), h.node_locateANamespace(this, null) === e3;
          }, t2.prototype.insertBefore = function(e3, t3) {
            return h.mutation_preInsert(e3, this, t3);
          }, t2.prototype.appendChild = function(e3) {
            return h.mutation_append(e3, this);
          }, t2.prototype.replaceChild = function(e3, t3) {
            return h.mutation_replace(t3, e3, this);
          }, t2.prototype.removeChild = function(e3) {
            return h.mutation_preRemove(e3, this);
          }, t2.prototype._getTheParent = function(e3) {
            return l.Guard.isSlotable(this) && h.shadowTree_isAssigned(this) ? this._assignedSlot : this._parent;
          }, t2.ELEMENT_NODE = 1, t2.ATTRIBUTE_NODE = 2, t2.TEXT_NODE = 3, t2.CDATA_SECTION_NODE = 4, t2.ENTITY_REFERENCE_NODE = 5, t2.ENTITY_NODE = 6, t2.PROCESSING_INSTRUCTION_NODE = 7, t2.COMMENT_NODE = 8, t2.DOCUMENT_NODE = 9, t2.DOCUMENT_TYPE_NODE = 10, t2.DOCUMENT_FRAGMENT_NODE = 11, t2.NOTATION_NODE = 12, t2.DOCUMENT_POSITION_DISCONNECTED = 1, t2.DOCUMENT_POSITION_PRECEDING = 2, t2.DOCUMENT_POSITION_FOLLOWING = 4, t2.DOCUMENT_POSITION_CONTAINS = 8, t2.DOCUMENT_POSITION_CONTAINED_BY = 16, t2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32, t2;
        }(u.EventTargetImpl);
        t.NodeImpl = d, d.prototype._children = new l.EmptySet(), f.idl_defineConst(d.prototype, "ELEMENT_NODE", 1), f.idl_defineConst(d.prototype, "ATTRIBUTE_NODE", 2), f.idl_defineConst(d.prototype, "TEXT_NODE", 3), f.idl_defineConst(d.prototype, "CDATA_SECTION_NODE", 4), f.idl_defineConst(d.prototype, "ENTITY_REFERENCE_NODE", 5), f.idl_defineConst(d.prototype, "ENTITY_NODE", 6), f.idl_defineConst(d.prototype, "PROCESSING_INSTRUCTION_NODE", 7), f.idl_defineConst(d.prototype, "COMMENT_NODE", 8), f.idl_defineConst(d.prototype, "DOCUMENT_NODE", 9), f.idl_defineConst(d.prototype, "DOCUMENT_TYPE_NODE", 10), f.idl_defineConst(d.prototype, "DOCUMENT_FRAGMENT_NODE", 11), f.idl_defineConst(d.prototype, "NOTATION_NODE", 12), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_DISCONNECTED", 1), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_PRECEDING", 2), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_FOLLOWING", 4), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_CONTAINS", 8), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 16), f.idl_defineConst(d.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
      }, function(e, t) {
        e.exports = function(e2) {
          if (null == e2)
            throw TypeError("Can't call method on " + e2);
          return e2;
        };
      }, function(e, t, r) {
        var n = r(87), i = r(41), o = r(27), a = r(26), s = r(128), u = [].push, l = function(e2) {
          var t2 = 1 == e2, r2 = 2 == e2, l2 = 3 == e2, c = 4 == e2, h = 6 == e2, p = 5 == e2 || h;
          return function(f, d, m, y) {
            for (var v, _, g = o(f), b = i(g), x = n(d, m, 3), w = a(b.length), E = 0, D = y || s, S = t2 ? D(f, w) : r2 ? D(f, 0) : void 0; w > E; E++)
              if ((p || E in b) && (_ = x(v = b[E], E, g), e2)) {
                if (t2)
                  S[E] = _;
                else if (_)
                  switch (e2) {
                    case 3:
                      return true;
                    case 5:
                      return v;
                    case 6:
                      return E;
                    case 2:
                      u.call(S, v);
                  }
                else if (c)
                  return false;
              }
            return h ? -1 : l2 || c ? c : S;
          };
        };
        e.exports = { forEach: l(0), map: l(1), filter: l(2), some: l(3), every: l(4), find: l(5), findIndex: l(6) };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(9), u = r(1), l = r(3), c = r(2), h = r(7), p = r(73), f = r(17), d = r(172), m = r(72), y = r(51), v = r(30), _ = r(106);
        function g(e2, t2, r2) {
          var i2, o2, a2, l2, c2, h2, p2, d2, m2 = t2._nodeType, y2 = e2._nodeType, v2 = r2 ? r2._nodeType : null;
          if (m2 !== u.NodeType.Document && m2 !== u.NodeType.DocumentFragment && m2 !== u.NodeType.Element)
            throw new s.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + t2.nodeName + ".");
          if (f.tree_isHostIncludingAncestorOf(t2, e2, true))
            throw new s.HierarchyRequestError("The node to be inserted cannot be an inclusive ancestor of parent node. Node is " + e2.nodeName + ", parent node is " + t2.nodeName + ".");
          if (null !== r2 && r2._parent !== t2)
            throw new s.NotFoundError("The reference child node cannot be found under parent node. Child node is " + r2.nodeName + ", parent node is " + t2.nodeName + ".");
          if (y2 !== u.NodeType.DocumentFragment && y2 !== u.NodeType.DocumentType && y2 !== u.NodeType.Element && y2 !== u.NodeType.Text && y2 !== u.NodeType.ProcessingInstruction && y2 !== u.NodeType.CData && y2 !== u.NodeType.Comment)
            throw new s.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + e2.nodeName + ".");
          if (y2 === u.NodeType.Text && m2 === u.NodeType.Document)
            throw new s.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + e2.nodeName + ".");
          if (y2 === u.NodeType.DocumentType && m2 !== u.NodeType.Document)
            throw new s.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + t2.nodeName + ".");
          if (m2 === u.NodeType.Document) {
            if (y2 === u.NodeType.DocumentFragment) {
              var _2 = 0;
              try {
                for (var g2 = n(e2._children), b2 = g2.next(); !b2.done; b2 = g2.next()) {
                  var x2 = b2.value;
                  if (x2._nodeType === u.NodeType.Element)
                    _2++;
                  else if (x2._nodeType === u.NodeType.Text)
                    throw new s.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + x2.nodeName + ".");
                }
              } catch (e3) {
                i2 = { error: e3 };
              } finally {
                try {
                  b2 && !b2.done && (o2 = g2.return) && o2.call(g2);
                } finally {
                  if (i2)
                    throw i2.error;
                }
              }
              if (_2 > 1)
                throw new s.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + _2 + " element nodes.");
              if (1 === _2) {
                try {
                  for (var w2 = n(t2._children), E = w2.next(); !E.done; E = w2.next()) {
                    if (E.value._nodeType === u.NodeType.Element)
                      throw new s.HierarchyRequestError("The document node already has a document element node.");
                  }
                } catch (e3) {
                  a2 = { error: e3 };
                } finally {
                  try {
                    E && !E.done && (l2 = w2.return) && l2.call(w2);
                  } finally {
                    if (a2)
                      throw a2.error;
                  }
                }
                if (r2) {
                  if (v2 === u.NodeType.DocumentType)
                    throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");
                  for (var D = r2._nextSibling; D; ) {
                    if (D._nodeType === u.NodeType.DocumentType)
                      throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    D = D._nextSibling;
                  }
                }
              }
            } else if (y2 === u.NodeType.Element) {
              try {
                for (var S = n(t2._children), C = S.next(); !C.done; C = S.next()) {
                  if (C.value._nodeType === u.NodeType.Element)
                    throw new s.HierarchyRequestError("Document already has a document element node. Node is " + e2.nodeName + ".");
                }
              } catch (e3) {
                c2 = { error: e3 };
              } finally {
                try {
                  C && !C.done && (h2 = S.return) && h2.call(S);
                } finally {
                  if (c2)
                    throw c2.error;
                }
              }
              if (r2) {
                if (v2 === u.NodeType.DocumentType)
                  throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + e2.nodeName + ".");
                for (D = r2._nextSibling; D; ) {
                  if (D._nodeType === u.NodeType.DocumentType)
                    throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + e2.nodeName + ".");
                  D = D._nextSibling;
                }
              }
            } else if (y2 === u.NodeType.DocumentType) {
              try {
                for (var A = n(t2._children), N = A.next(); !N.done; N = A.next()) {
                  if (N.value._nodeType === u.NodeType.DocumentType)
                    throw new s.HierarchyRequestError("Document already has a document type node. Node is " + e2.nodeName + ".");
                }
              } catch (e3) {
                p2 = { error: e3 };
              } finally {
                try {
                  N && !N.done && (d2 = A.return) && d2.call(A);
                } finally {
                  if (p2)
                    throw p2.error;
                }
              }
              if (r2)
                for (var T = r2._previousSibling; T; ) {
                  if (T._nodeType === u.NodeType.Element)
                    throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + e2.nodeName + ".");
                  T = T._previousSibling;
                }
              else
                for (T = t2._firstChild; T; ) {
                  if (T._nodeType === u.NodeType.Element)
                    throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + e2.nodeName + ".");
                  T = T._nextSibling;
                }
            }
          }
        }
        function b(e2, t2, r2) {
          g(e2, t2, r2);
          var n2 = r2;
          return n2 === e2 && (n2 = e2._nextSibling), _.document_adopt(e2, t2._nodeDocument), x(e2, t2, n2), e2;
        }
        function x(e2, t2, r2, i2) {
          var s2, d2;
          if (null !== r2 || e2._nodeType === u.NodeType.DocumentFragment) {
            var _2 = e2._nodeType === u.NodeType.DocumentFragment ? e2._children.size : 1;
            if (null !== r2 && 0 !== a.dom.rangeList.size) {
              var g2 = f.tree_index(r2);
              try {
                for (var b2 = n(a.dom.rangeList), x2 = b2.next(); !x2.done; x2 = b2.next()) {
                  var E = x2.value;
                  E._start[0] === t2 && E._start[1] > g2 && (E._start[1] += _2), E._end[0] === t2 && E._end[1] > g2 && (E._end[1] += _2);
                }
              } catch (e3) {
                s2 = { error: e3 };
              } finally {
                try {
                  x2 && !x2.done && (d2 = b2.return) && d2.call(b2);
                } finally {
                  if (s2)
                    throw s2.error;
                }
              }
            }
            var D = e2._nodeType === u.NodeType.DocumentFragment ? new (Array.bind.apply(Array, o([void 0], e2._children)))() : [e2];
            if (e2._nodeType === u.NodeType.DocumentFragment)
              for (; e2._firstChild; )
                w(e2._firstChild, e2, true);
            a.dom.features.mutationObservers && e2._nodeType === u.NodeType.DocumentFragment && y.observer_queueTreeMutationRecord(e2, [], D, null, null);
            for (var S = r2 ? r2._previousSibling : t2._lastChild, C = null === r2 ? -1 : f.tree_index(r2), A = 0; A < D.length; A++) {
              var N = D[A];
              if (l.Guard.isElementNode(N) && (l.Guard.isDocumentNode(t2) && (t2._documentElement = N), N._nodeDocument._hasNamespaces || null === N._namespace && null === N._namespacePrefix || (N._nodeDocument._hasNamespaces = true)), N._parent = t2, null === r2 ? h.set.append(t2._children, N) : (h.set.insert(t2._children, N, C), C++), null === t2._firstChild)
                N._previousSibling = null, N._nextSibling = null, t2._firstChild = N, t2._lastChild = N;
              else {
                var T = r2 ? r2._previousSibling : t2._lastChild, O = r2 || null;
                N._previousSibling = T, N._nextSibling = O, T && (T._nextSibling = N), O && (O._previousSibling = N), T || (t2._firstChild = N), O || (t2._lastChild = N);
              }
              a.dom.features.slots && null !== t2._shadowRoot && l.Guard.isSlotable(N) && m.shadowTree_assignASlot(N), a.dom.features.steps && l.Guard.isTextNode(N) && v.dom_runChildTextContentChangeSteps(t2), a.dom.features.slots && l.Guard.isShadowRoot(f.tree_rootNode(t2)) && l.Guard.isSlot(t2) && c.isEmpty(t2._assignedNodes) && m.shadowTree_signalASlotChange(t2), a.dom.features.slots && m.shadowTree_assignSlotablesForATree(f.tree_rootNode(N));
              for (var F = f.tree_getFirstDescendantNode(N, true, true); null !== F; )
                a.dom.features.steps && v.dom_runInsertionSteps(F), a.dom.features.customElements && l.Guard.isElementNode(F) && m.shadowTree_isConnected(F) && (l.Guard.isCustomElementNode(F) ? p.customElement_enqueueACustomElementCallbackReaction(F, "connectedCallback", []) : p.customElement_tryToUpgrade(F)), F = f.tree_getNextDescendantNode(N, F, true, true);
            }
            a.dom.features.mutationObservers && (i2 || y.observer_queueTreeMutationRecord(t2, D, [], S, r2));
          } else
            !function(e3, t3, r3) {
              var n2 = t3._lastChild;
              l.Guard.isElementNode(e3) && (l.Guard.isDocumentNode(t3) && (t3._documentElement = e3), e3._nodeDocument._hasNamespaces || null === e3._namespace && null === e3._namespacePrefix || (e3._nodeDocument._hasNamespaces = true));
              if (e3._parent = t3, t3._children.add(e3), null === t3._firstChild)
                e3._previousSibling = null, e3._nextSibling = null, t3._firstChild = e3, t3._lastChild = e3;
              else {
                var i3 = t3._lastChild;
                e3._previousSibling = i3, e3._nextSibling = null, i3 && (i3._nextSibling = e3), i3 || (t3._firstChild = e3), t3._lastChild = e3;
              }
              a.dom.features.slots && null !== t3._shadowRoot && l.Guard.isSlotable(e3) && m.shadowTree_assignASlot(e3);
              a.dom.features.steps && l.Guard.isTextNode(e3) && v.dom_runChildTextContentChangeSteps(t3);
              a.dom.features.slots && l.Guard.isShadowRoot(f.tree_rootNode(t3)) && l.Guard.isSlot(t3) && c.isEmpty(t3._assignedNodes) && m.shadowTree_signalASlotChange(t3);
              a.dom.features.slots && m.shadowTree_assignSlotablesForATree(f.tree_rootNode(e3));
              a.dom.features.steps && v.dom_runInsertionSteps(e3);
              a.dom.features.customElements && l.Guard.isElementNode(e3) && m.shadowTree_isConnected(e3) && (l.Guard.isCustomElementNode(e3) ? p.customElement_enqueueACustomElementCallbackReaction(e3, "connectedCallback", []) : p.customElement_tryToUpgrade(e3));
              a.dom.features.mutationObservers && (r3 || y.observer_queueTreeMutationRecord(t3, [e3], [], n2, null));
            }(e2, t2, i2);
        }
        function w(e2, t2, r2) {
          var i2, o2, s2, u2, h2, _2, g2, b2;
          if (0 !== a.dom.rangeList.size) {
            var x2 = f.tree_index(e2);
            try {
              for (var w2 = n(a.dom.rangeList), E = w2.next(); !E.done; E = w2.next()) {
                var D = E.value;
                f.tree_isDescendantOf(e2, D._start[0], true) && (D._start = [t2, x2]), f.tree_isDescendantOf(e2, D._end[0], true) && (D._end = [t2, x2]), D._start[0] === t2 && D._start[1] > x2 && D._start[1]--, D._end[0] === t2 && D._end[1] > x2 && D._end[1]--;
              }
            } catch (e3) {
              i2 = { error: e3 };
            } finally {
              try {
                E && !E.done && (o2 = w2.return) && o2.call(w2);
              } finally {
                if (i2)
                  throw i2.error;
              }
            }
            try {
              for (var S = n(a.dom.rangeList), C = S.next(); !C.done; C = S.next()) {
                (D = C.value)._start[0] === t2 && D._start[1] > x2 && (D._start[1] -= 1), D._end[0] === t2 && D._end[1] > x2 && (D._end[1] -= 1);
              }
            } catch (e3) {
              s2 = { error: e3 };
            } finally {
              try {
                C && !C.done && (u2 = S.return) && u2.call(S);
              } finally {
                if (s2)
                  throw s2.error;
              }
            }
          }
          if (a.dom.features.steps)
            try {
              for (var A = n(d.nodeIterator_iteratorList()), N = A.next(); !N.done; N = A.next()) {
                var T = N.value;
                T._root._nodeDocument === e2._nodeDocument && v.dom_runNodeIteratorPreRemovingSteps(T, e2);
              }
            } catch (e3) {
              h2 = { error: e3 };
            } finally {
              try {
                N && !N.done && (_2 = A.return) && _2.call(A);
              } finally {
                if (h2)
                  throw h2.error;
              }
            }
          var O = e2._previousSibling, F = e2._nextSibling;
          l.Guard.isDocumentNode(t2) && l.Guard.isElementNode(e2) && (t2._documentElement = null), e2._parent = null, t2._children.delete(e2);
          var k = e2._previousSibling, P = e2._nextSibling;
          (e2._previousSibling = null, e2._nextSibling = null, k && (k._nextSibling = P), P && (P._previousSibling = k), k || (t2._firstChild = P), P || (t2._lastChild = k), a.dom.features.slots && l.Guard.isSlotable(e2) && null !== e2._assignedSlot && m.shadowTree_isAssigned(e2) && m.shadowTree_assignSlotables(e2._assignedSlot), a.dom.features.slots && l.Guard.isShadowRoot(f.tree_rootNode(t2)) && l.Guard.isSlot(t2) && c.isEmpty(t2._assignedNodes) && m.shadowTree_signalASlotChange(t2), a.dom.features.slots) && (null !== f.tree_getFirstDescendantNode(e2, true, false, function(e3) {
            return l.Guard.isSlot(e3);
          }) && (m.shadowTree_assignSlotablesForATree(f.tree_rootNode(t2)), m.shadowTree_assignSlotablesForATree(e2)));
          a.dom.features.steps && v.dom_runRemovingSteps(e2, t2), a.dom.features.customElements && l.Guard.isCustomElementNode(e2) && p.customElement_enqueueACustomElementCallbackReaction(e2, "disconnectedCallback", []);
          for (var I = f.tree_getFirstDescendantNode(e2, false, true); null !== I; )
            a.dom.features.steps && v.dom_runRemovingSteps(I, e2), a.dom.features.customElements && l.Guard.isCustomElementNode(I) && p.customElement_enqueueACustomElementCallbackReaction(I, "disconnectedCallback", []), I = f.tree_getNextDescendantNode(e2, I, false, true);
          if (a.dom.features.mutationObservers)
            for (var L = f.tree_getFirstAncestorNode(t2, true); null !== L; ) {
              try {
                for (var M = (g2 = void 0, n(L._registeredObserverList)), B = M.next(); !B.done; B = M.next()) {
                  var j = B.value;
                  j.options.subtree && e2._registeredObserverList.push({ observer: j.observer, options: j.options, source: j });
                }
              } catch (e3) {
                g2 = { error: e3 };
              } finally {
                try {
                  B && !B.done && (b2 = M.return) && b2.call(M);
                } finally {
                  if (g2)
                    throw g2.error;
                }
              }
              L = f.tree_getNextAncestorNode(t2, L, true);
            }
          a.dom.features.mutationObservers && (r2 || y.observer_queueTreeMutationRecord(t2, [], [e2], O, F)), a.dom.features.steps && l.Guard.isTextNode(e2) && v.dom_runChildTextContentChangeSteps(t2);
        }
        t.mutation_ensurePreInsertionValidity = g, t.mutation_preInsert = b, t.mutation_insert = x, t.mutation_append = function(e2, t2) {
          return b(e2, t2, null);
        }, t.mutation_replace = function(e2, t2, r2) {
          var i2, o2, l2, c2, h2, p2, d2, m2;
          if (r2._nodeType !== u.NodeType.Document && r2._nodeType !== u.NodeType.DocumentFragment && r2._nodeType !== u.NodeType.Element)
            throw new s.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + r2.nodeName + ".");
          if (f.tree_isHostIncludingAncestorOf(r2, t2, true))
            throw new s.HierarchyRequestError("The node to be inserted cannot be an ancestor of parent node. Node is " + t2.nodeName + ", parent node is " + r2.nodeName + ".");
          if (e2._parent !== r2)
            throw new s.NotFoundError("The reference child node cannot be found under parent node. Child node is " + e2.nodeName + ", parent node is " + r2.nodeName + ".");
          if (t2._nodeType !== u.NodeType.DocumentFragment && t2._nodeType !== u.NodeType.DocumentType && t2._nodeType !== u.NodeType.Element && t2._nodeType !== u.NodeType.Text && t2._nodeType !== u.NodeType.ProcessingInstruction && t2._nodeType !== u.NodeType.CData && t2._nodeType !== u.NodeType.Comment)
            throw new s.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + t2.nodeName + ".");
          if (t2._nodeType === u.NodeType.Text && r2._nodeType === u.NodeType.Document)
            throw new s.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + t2.nodeName + ".");
          if (t2._nodeType === u.NodeType.DocumentType && r2._nodeType !== u.NodeType.Document)
            throw new s.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + r2.nodeName + ".");
          if (r2._nodeType === u.NodeType.Document) {
            if (t2._nodeType === u.NodeType.DocumentFragment) {
              var v2 = 0;
              try {
                for (var g2 = n(t2._children), b2 = g2.next(); !b2.done; b2 = g2.next()) {
                  var E = b2.value;
                  if (E._nodeType === u.NodeType.Element)
                    v2++;
                  else if (E._nodeType === u.NodeType.Text)
                    throw new s.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + E.nodeName + ".");
                }
              } catch (e3) {
                i2 = { error: e3 };
              } finally {
                try {
                  b2 && !b2.done && (o2 = g2.return) && o2.call(g2);
                } finally {
                  if (i2)
                    throw i2.error;
                }
              }
              if (v2 > 1)
                throw new s.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + v2 + " element nodes.");
              if (1 === v2) {
                try {
                  for (var D = n(r2._children), S = D.next(); !S.done; S = D.next()) {
                    if ((F = S.value)._nodeType === u.NodeType.Element && F !== e2)
                      throw new s.HierarchyRequestError("The document node already has a document element node.");
                  }
                } catch (e3) {
                  l2 = { error: e3 };
                } finally {
                  try {
                    S && !S.done && (c2 = D.return) && c2.call(D);
                  } finally {
                    if (l2)
                      throw l2.error;
                  }
                }
                for (var C = e2._nextSibling; C; ) {
                  if (C._nodeType === u.NodeType.DocumentType)
                    throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");
                  C = C._nextSibling;
                }
              }
            } else if (t2._nodeType === u.NodeType.Element) {
              try {
                for (var A = n(r2._children), N = A.next(); !N.done; N = A.next()) {
                  if ((F = N.value)._nodeType === u.NodeType.Element && F !== e2)
                    throw new s.HierarchyRequestError("Document already has a document element node. Node is " + t2.nodeName + ".");
                }
              } catch (e3) {
                h2 = { error: e3 };
              } finally {
                try {
                  N && !N.done && (p2 = A.return) && p2.call(A);
                } finally {
                  if (h2)
                    throw h2.error;
                }
              }
              for (C = e2._nextSibling; C; ) {
                if (C._nodeType === u.NodeType.DocumentType)
                  throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + t2.nodeName + ".");
                C = C._nextSibling;
              }
            } else if (t2._nodeType === u.NodeType.DocumentType) {
              try {
                for (var T = n(r2._children), O = T.next(); !O.done; O = T.next()) {
                  var F;
                  if ((F = O.value)._nodeType === u.NodeType.DocumentType && F !== e2)
                    throw new s.HierarchyRequestError("Document already has a document type node. Node is " + t2.nodeName + ".");
                }
              } catch (e3) {
                d2 = { error: e3 };
              } finally {
                try {
                  O && !O.done && (m2 = T.return) && m2.call(T);
                } finally {
                  if (d2)
                    throw d2.error;
                }
              }
              for (var k = e2._previousSibling; k; ) {
                if (k._nodeType === u.NodeType.Element)
                  throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + t2.nodeName + ".");
                k = k._previousSibling;
              }
            }
          }
          var P = e2._nextSibling;
          P === t2 && (P = t2._nextSibling);
          var I = e2._previousSibling;
          _.document_adopt(t2, r2._nodeDocument);
          var L = [];
          null !== e2._parent && (L.push(e2), w(e2, e2._parent, true));
          var M = [];
          return t2._nodeType === u.NodeType.DocumentFragment ? M = Array.from(t2._children) : M.push(t2), x(t2, r2, P, true), a.dom.features.mutationObservers && y.observer_queueTreeMutationRecord(r2, M, L, I, P), e2;
        }, t.mutation_replaceAll = function(e2, t2) {
          var r2, i2;
          null !== e2 && _.document_adopt(e2, t2._nodeDocument);
          var o2 = Array.from(t2._children), s2 = [];
          e2 && e2._nodeType === u.NodeType.DocumentFragment ? s2 = Array.from(e2._children) : null !== e2 && s2.push(e2);
          try {
            for (var l2 = n(o2), c2 = l2.next(); !c2.done; c2 = l2.next()) {
              w(c2.value, t2, true);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (i2 = l2.return) && i2.call(l2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          null !== e2 && x(e2, t2, null, true), a.dom.features.mutationObservers && y.observer_queueTreeMutationRecord(t2, s2, o2, null, null);
        }, t.mutation_preRemove = function(e2, t2) {
          if (e2._parent !== t2)
            throw new s.NotFoundError("The child node cannot be found under parent node. Child node is " + e2.nodeName + ", parent node is " + t2.nodeName + ".");
          return w(e2, t2), e2;
        }, t.mutation_remove = w;
      }, function(e, t, r) {
        "use strict";
        function n(e2) {
          return null == e2;
        }
        e.exports.isNothing = n, e.exports.isObject = function(e2) {
          return "object" == typeof e2 && null !== e2;
        }, e.exports.toArray = function(e2) {
          return Array.isArray(e2) ? e2 : n(e2) ? [] : [e2];
        }, e.exports.repeat = function(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2 += 1)
            n2 += e2;
          return n2;
        }, e.exports.isNegativeZero = function(e2) {
          return 0 === e2 && Number.NEGATIVE_INFINITY === 1 / e2;
        }, e.exports.extend = function(e2, t2) {
          var r2, n2, i, o;
          if (t2)
            for (r2 = 0, n2 = (o = Object.keys(t2)).length; r2 < n2; r2 += 1)
              e2[i = o[r2]] = t2[i];
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(53), o = r(10);
        function a(e2, t2, r2) {
          var n2 = [];
          return e2.include.forEach(function(e3) {
            r2 = a(e3, t2, r2);
          }), e2[t2].forEach(function(e3) {
            r2.forEach(function(t3, r3) {
              t3.tag === e3.tag && t3.kind === e3.kind && n2.push(r3);
            }), r2.push(e3);
          }), r2.filter(function(e3, t3) {
            return -1 === n2.indexOf(t3);
          });
        }
        function s(e2) {
          this.include = e2.include || [], this.implicit = e2.implicit || [], this.explicit = e2.explicit || [], this.implicit.forEach(function(e3) {
            if (e3.loadKind && "scalar" !== e3.loadKind)
              throw new i("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
          }), this.compiledImplicit = a(this, "implicit", []), this.compiledExplicit = a(this, "explicit", []), this.compiledTypeMap = function() {
            var e3, t2, r2 = { scalar: {}, sequence: {}, mapping: {}, fallback: {} };
            function n2(e4) {
              r2[e4.kind][e4.tag] = r2.fallback[e4.tag] = e4;
            }
            for (e3 = 0, t2 = arguments.length; e3 < t2; e3 += 1)
              arguments[e3].forEach(n2);
            return r2;
          }(this.compiledImplicit, this.compiledExplicit);
        }
        s.DEFAULT = null, s.create = function() {
          var e2, t2;
          switch (arguments.length) {
            case 1:
              e2 = s.DEFAULT, t2 = arguments[0];
              break;
            case 2:
              e2 = arguments[0], t2 = arguments[1];
              break;
            default:
              throw new i("Wrong number of arguments for Schema.create function");
          }
          if (e2 = n.toArray(e2), t2 = n.toArray(t2), !e2.every(function(e3) {
            return e3 instanceof s;
          }))
            throw new i("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
          if (!t2.every(function(e3) {
            return e3 instanceof o;
          }))
            throw new i("Specified list of YAML types (or a single Type object) contains a non-Type object.");
          return new s({ include: e2, explicit: t2 });
        }, e.exports = s;
      }, function(e, t) {
        e.exports = function(e2, t2) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
        };
      }, function(e, t, r) {
        var n = r(8), i = r(42), o = "".split;
        e.exports = n(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return "String" == i(e2) ? o.call(e2, "") : Object(e2);
        } : Object;
      }, function(e, t) {
        var r = {}.toString;
        e.exports = function(e2) {
          return r.call(e2).slice(8, -1);
        };
      }, function(e, t, r) {
        var n, i, o, a = r(186), s = r(11), u = r(13), l = r(21), c = r(14), h = r(57), p = r(45), f = s.WeakMap;
        if (a) {
          var d = new f(), m = d.get, y = d.has, v = d.set;
          n = function(e2, t2) {
            return v.call(d, e2, t2), t2;
          }, i = function(e2) {
            return m.call(d, e2) || {};
          }, o = function(e2) {
            return y.call(d, e2);
          };
        } else {
          var _ = h("state");
          p[_] = true, n = function(e2, t2) {
            return l(e2, _, t2), t2;
          }, i = function(e2) {
            return c(e2, _) ? e2[_] : {};
          }, o = function(e2) {
            return c(e2, _);
          };
        }
        e.exports = { set: n, get: i, has: o, enforce: function(e2) {
          return o(e2) ? i(e2) : n(e2, {});
        }, getterFor: function(e2) {
          return function(t2) {
            var r2;
            if (!u(t2) || (r2 = i(t2)).type !== e2)
              throw TypeError("Incompatible receiver, " + e2 + " required");
            return r2;
          };
        } };
      }, function(e, t) {
        e.exports = false;
      }, function(e, t) {
        e.exports = {};
      }, function(e, t, r) {
        var n = r(120), i = r(11), o = function(e2) {
          return "function" == typeof e2 ? e2 : void 0;
        };
        e.exports = function(e2, t2) {
          return arguments.length < 2 ? o(n[e2]) || o(i[e2]) : n[e2] && n[e2][t2] || i[e2] && i[e2][t2];
        };
      }, function(e, t) {
        var r = Math.ceil, n = Math.floor;
        e.exports = function(e2) {
          return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? n : r)(e2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(8);
        e.exports = function(e2, t2) {
          var r2 = [][e2];
          return !!r2 && n(function() {
            r2.call(null, t2 || function() {
              throw 1;
            }, 1);
          });
        };
      }, function(e, t) {
        e.exports = {};
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(220), r(64), r(19), r(65), r(20), r(68), r(66), r(92), r(144), r(22), r(94), r(23);
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(1), s = r(69), u = r(95), l = r(7), c = r(0), h = r(258), p = function() {
          function e2(e3) {
            this.level = 0, this._builderOptions = e3;
          }
          return e2.prototype.declaration = function(e3, t2, r2) {
          }, e2.prototype.docType = function(e3, t2, r2) {
          }, e2.prototype.comment = function(e3) {
          }, e2.prototype.text = function(e3) {
          }, e2.prototype.instruction = function(e3, t2) {
          }, e2.prototype.cdata = function(e3) {
          }, e2.prototype.openTagBegin = function(e3) {
          }, e2.prototype.openTagEnd = function(e3, t2, r2) {
          }, e2.prototype.closeTag = function(e3) {
          }, e2.prototype.attributes = function(e3) {
            var t2, r2;
            try {
              for (var i2 = n(e3), o2 = i2.next(); !o2.done; o2 = i2.next()) {
                var a2 = o2.value;
                this.attribute(null === a2[1] ? a2[2] : a2[1] + ":" + a2[2], a2[3]);
              }
            } catch (e4) {
              t2 = { error: e4 };
            } finally {
              try {
                o2 && !o2.done && (r2 = i2.return) && r2.call(i2);
              } finally {
                if (t2)
                  throw t2.error;
              }
            }
          }, e2.prototype.attribute = function(e3, t2) {
          }, e2.prototype.beginElement = function(e3) {
          }, e2.prototype.endElement = function(e3) {
          }, e2.prototype.serializeNode = function(e3, t2) {
            var r2 = void 0 !== e3._nodeDocument && e3._nodeDocument._hasNamespaces;
            if (this.level = 0, this.currentNode = e3, r2) {
              var n2 = new u.NamespacePrefixMap();
              n2.set("xml", l.namespace.XML);
              this._serializeNodeNS(e3, null, n2, { value: 1 }, t2);
            } else
              this._serializeNode(e3, t2);
          }, e2.prototype._serializeNodeNS = function(e3, t2, r2, n2, i2) {
            switch (this.currentNode = e3, e3.nodeType) {
              case a.NodeType.Element:
                this._serializeElementNS(e3, t2, r2, n2, i2);
                break;
              case a.NodeType.Document:
                this._serializeDocumentNS(e3, t2, r2, n2, i2);
                break;
              case a.NodeType.Comment:
                this._serializeComment(e3, i2);
                break;
              case a.NodeType.Text:
                this._serializeText(e3, i2);
                break;
              case a.NodeType.DocumentFragment:
                this._serializeDocumentFragmentNS(e3, t2, r2, n2, i2);
                break;
              case a.NodeType.DocumentType:
                this._serializeDocumentType(e3, i2);
                break;
              case a.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(e3, i2);
                break;
              case a.NodeType.CData:
                this._serializeCData(e3, i2);
                break;
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeNode = function(e3, t2) {
            switch (this.currentNode = e3, e3.nodeType) {
              case a.NodeType.Element:
                this._serializeElement(e3, t2);
                break;
              case a.NodeType.Document:
                this._serializeDocument(e3, t2);
                break;
              case a.NodeType.Comment:
                this._serializeComment(e3, t2);
                break;
              case a.NodeType.Text:
                this._serializeText(e3, t2);
                break;
              case a.NodeType.DocumentFragment:
                this._serializeDocumentFragment(e3, t2);
                break;
              case a.NodeType.DocumentType:
                this._serializeDocumentType(e3, t2);
                break;
              case a.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(e3, t2);
                break;
              case a.NodeType.CData:
                this._serializeCData(e3, t2);
                break;
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeElementNS = function(t2, r2, i2, a2, s2) {
            var u2, h2, p2 = [];
            if (s2 && (-1 !== t2.localName.indexOf(":") || !c.xml_isName(t2.localName)))
              throw new Error("Node local name contains invalid characters (well-formed required).");
            var f = "", d = false, m = false, y = i2.copy(), v = {}, _ = this._recordNamespaceInformation(t2, y, v), g = r2, b = t2.namespaceURI;
            if (g === b)
              null !== _ && (m = true), f = b === l.namespace.XML ? "xml:" + t2.localName : t2.localName, this.beginElement(f), this.openTagBegin(f);
            else {
              var x = t2.prefix, w = null;
              if (null === x && b === _ || (w = y.get(x, b)), "xmlns" === x) {
                if (s2)
                  throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                w = x;
              }
              null !== w ? (f = w + ":" + t2.localName, null !== _ && _ !== l.namespace.XML && (g = _ || null), this.beginElement(f), this.openTagBegin(f)) : null !== x ? (x in v && (x = this._generatePrefix(b, y, a2)), y.set(x, b), f += x + ":" + t2.localName, this.beginElement(f), this.openTagBegin(f), p2.push([null, "xmlns", x, this._serializeAttributeValue(b, s2)]), null !== _ && (g = _ || null)) : null === _ || null !== _ && _ !== b ? (m = true, f += t2.localName, g = b, this.beginElement(f), this.openTagBegin(f), p2.push([null, null, "xmlns", this._serializeAttributeValue(b, s2)])) : (f += t2.localName, g = b, this.beginElement(f), this.openTagBegin(f));
            }
            p2.push.apply(p2, o(this._serializeAttributesNS(t2, y, a2, v, m, s2))), this.attributes(p2);
            var E = b === l.namespace.HTML;
            if (E && 0 === t2.childNodes.length && e2._VoidElementNames.has(t2.localName) ? (this.openTagEnd(f, true, true), this.endElement(f), d = true) : E || 0 !== t2.childNodes.length ? this.openTagEnd(f, false, false) : (this.openTagEnd(f, true, false), this.endElement(f), d = true), !d) {
              if (E && "template" === t2.localName)
                ;
              else
                try {
                  for (var D = n(t2.childNodes), S = D.next(); !S.done; S = D.next()) {
                    var C = S.value;
                    this.level++, this._serializeNodeNS(C, g, y, a2, s2), this.level--;
                  }
                } catch (e3) {
                  u2 = { error: e3 };
                } finally {
                  try {
                    S && !S.done && (h2 = D.return) && h2.call(D);
                  } finally {
                    if (u2)
                      throw u2.error;
                  }
                }
              this.closeTag(f), this.endElement(f);
            }
          }, e2.prototype._serializeElement = function(e3, t2) {
            var r2, i2;
            if (t2 && (-1 !== e3.localName.indexOf(":") || !c.xml_isName(e3.localName)))
              throw new Error("Node local name contains invalid characters (well-formed required).");
            var o2 = false, a2 = e3.localName;
            this.beginElement(a2), this.openTagBegin(a2);
            var s2 = this._serializeAttributes(e3, t2);
            if (this.attributes(s2), e3.hasChildNodes() ? this.openTagEnd(a2, false, false) : (this.openTagEnd(a2, true, false), this.endElement(a2), o2 = true), !o2) {
              try {
                for (var u2 = n(e3._children), l2 = u2.next(); !l2.done; l2 = u2.next()) {
                  var h2 = l2.value;
                  this.level++, this._serializeNode(h2, t2), this.level--;
                }
              } catch (e4) {
                r2 = { error: e4 };
              } finally {
                try {
                  l2 && !l2.done && (i2 = u2.return) && i2.call(u2);
                } finally {
                  if (r2)
                    throw r2.error;
                }
              }
              this.closeTag(a2), this.endElement(a2);
            }
          }, e2.prototype._serializeDocumentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2;
            if (o2 && null === e3.documentElement)
              throw new Error("Missing document element (well-formed required).");
            try {
              for (var u2 = n(e3.childNodes), l2 = u2.next(); !l2.done; l2 = u2.next()) {
                var c2 = l2.value;
                this._serializeNodeNS(c2, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                l2 && !l2.done && (s2 = u2.return) && s2.call(u2);
              } finally {
                if (a2)
                  throw a2.error;
              }
            }
          }, e2.prototype._serializeDocument = function(e3, t2) {
            var r2, i2;
            if (t2 && null === e3.documentElement)
              throw new Error("Missing document element (well-formed required).");
            try {
              for (var o2 = n(e3._children), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                this._serializeNode(s2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (i2 = o2.return) && i2.call(o2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, e2.prototype._serializeComment = function(e3, t2) {
            if (t2 && (!c.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("--") || e3.data.endsWith("-")))
              throw new Error("Comment data contains invalid characters (well-formed required).");
            this.comment(e3.data);
          }, e2.prototype._serializeText = function(e3, t2) {
            if (t2 && !c.xml_isLegalChar(e3.data))
              throw new Error("Text data contains invalid characters (well-formed required).");
            var r2 = e3.data.replace(h.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            this.text(r2);
          }, e2.prototype._serializeDocumentFragmentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2;
            try {
              for (var u2 = n(e3.childNodes), l2 = u2.next(); !l2.done; l2 = u2.next()) {
                var c2 = l2.value;
                this._serializeNodeNS(c2, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                l2 && !l2.done && (s2 = u2.return) && s2.call(u2);
              } finally {
                if (a2)
                  throw a2.error;
              }
            }
          }, e2.prototype._serializeDocumentFragment = function(e3, t2) {
            var r2, i2;
            try {
              for (var o2 = n(e3._children), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                this._serializeNode(s2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (i2 = o2.return) && i2.call(o2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, e2.prototype._serializeDocumentType = function(e3, t2) {
            if (t2 && !c.xml_isPubidChar(e3.publicId))
              throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
            if (t2 && (!c.xml_isLegalChar(e3.systemId) || -1 !== e3.systemId.indexOf('"') && -1 !== e3.systemId.indexOf("'")))
              throw new Error("DocType system identifier contains invalid characters (well-formed required).");
            this.docType(e3.name, e3.publicId, e3.systemId);
          }, e2.prototype._serializeProcessingInstruction = function(e3, t2) {
            if (t2 && (-1 !== e3.target.indexOf(":") || /^xml$/i.test(e3.target)))
              throw new Error("Processing instruction target contains invalid characters (well-formed required).");
            if (t2 && (!c.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("?>")))
              throw new Error("Processing instruction data contains invalid characters (well-formed required).");
            this.instruction(e3.target, e3.data);
          }, e2.prototype._serializeCData = function(e3, t2) {
            if (t2 && -1 !== e3.data.indexOf("]]>"))
              throw new Error("CDATA contains invalid characters (well-formed required).");
            this.cdata(e3.data);
          }, e2.prototype._serializeAttributesNS = function(e3, t2, r2, i2, o2, a2) {
            var u2, h2, p2 = [], f = a2 ? new s.LocalNameSet() : void 0;
            try {
              for (var d = n(e3.attributes), m = d.next(); !m.done; m = d.next()) {
                var y = m.value;
                if (a2 || o2 || null !== y.namespaceURI) {
                  if (a2 && f && f.has(y.namespaceURI, y.localName))
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                  a2 && f && f.set(y.namespaceURI, y.localName);
                  var v = y.namespaceURI, _ = null;
                  if (null !== v)
                    if (_ = t2.get(y.prefix, v), v === l.namespace.XMLNS) {
                      if (y.value === l.namespace.XML || null === y.prefix && o2 || null !== y.prefix && (!(y.localName in i2) || i2[y.localName] !== y.value) && t2.has(y.localName, y.value))
                        continue;
                      if (a2 && y.value === l.namespace.XMLNS)
                        throw new Error("XMLNS namespace is reserved (well-formed required).");
                      if (a2 && "" === y.value)
                        throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                      "xmlns" === y.prefix && (_ = "xmlns");
                    } else
                      null === _ && (_ = null === y.prefix || t2.hasPrefix(y.prefix) && !t2.has(y.prefix, v) ? this._generatePrefix(v, t2, r2) : y.prefix, p2.push([null, "xmlns", _, this._serializeAttributeValue(v, a2)]));
                  if (null !== _ && _, a2 && (-1 !== y.localName.indexOf(":") || !c.xml_isName(y.localName) || "xmlns" === y.localName && null === v))
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                  p2.push([v, _, y.localName, this._serializeAttributeValue(y.value, a2)]);
                } else
                  p2.push([null, null, y.localName, this._serializeAttributeValue(y.value, a2)]);
              }
            } catch (e4) {
              u2 = { error: e4 };
            } finally {
              try {
                m && !m.done && (h2 = d.return) && h2.call(d);
              } finally {
                if (u2)
                  throw u2.error;
              }
            }
            return p2;
          }, e2.prototype._serializeAttributes = function(e3, t2) {
            var r2, i2, o2 = [], a2 = t2 ? {} : void 0;
            try {
              for (var s2 = n(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var l2 = u2.value;
                if (t2) {
                  if (t2 && a2 && l2.localName in a2)
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                  if (t2 && a2 && (a2[l2.localName] = true), t2 && (-1 !== l2.localName.indexOf(":") || !c.xml_isName(l2.localName)))
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                  o2.push([null, null, l2.localName, this._serializeAttributeValue(l2.value, t2)]);
                } else
                  o2.push([null, null, l2.localName, this._serializeAttributeValue(l2.value, t2)]);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return o2;
          }, e2.prototype._recordNamespaceInformation = function(e3, t2, r2) {
            var i2, o2, a2 = null;
            try {
              for (var s2 = n(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var c2 = u2.value, h2 = c2.namespaceURI, p2 = c2.prefix;
                if (h2 === l.namespace.XMLNS) {
                  if (null === p2) {
                    a2 = c2.value;
                    continue;
                  }
                  var f = c2.localName, d = c2.value;
                  if (d === l.namespace.XML)
                    continue;
                  if ("" === d && (d = null), t2.has(f, d))
                    continue;
                  t2.set(f, d), r2[f] = d || "";
                }
              }
            } catch (e4) {
              i2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (o2 = s2.return) && o2.call(s2);
              } finally {
                if (i2)
                  throw i2.error;
              }
            }
            return a2;
          }, e2.prototype._generatePrefix = function(e3, t2, r2) {
            var n2 = "ns" + r2.value.toString();
            return r2.value++, t2.set(n2, e3), n2;
          }, e2.prototype._serializeAttributeValue = function(e3, t2) {
            if (t2 && null !== e3 && !c.xml_isLegalChar(e3))
              throw new Error("Invalid characters in attribute value.");
            return null === e3 ? "" : e3.replace(h.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
          }, e2._VoidElementNames = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), e2;
        }();
        t.BaseWriter = p;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(6), a = r(3), s = r(7), u = r(29), l = r(17), c = r(97);
        function h() {
          var e2 = o.dom.window;
          e2._mutationObserverMicrotaskQueued || (e2._mutationObserverMicrotaskQueued = true, Promise.resolve().then(function() {
            p();
          }));
        }
        function p() {
          var e2, t2, r2, i2, u2 = o.dom.window;
          u2._mutationObserverMicrotaskQueued = false;
          var l2 = s.set.clone(u2._mutationObservers), h2 = s.set.clone(u2._signalSlots);
          s.set.empty(u2._signalSlots);
          var p2 = function(e3) {
            var t3 = s.list.clone(e3._recordQueue);
            s.list.empty(e3._recordQueue);
            for (var r3 = 0; r3 < e3._nodeList.length; r3++) {
              var n2 = e3._nodeList[r3];
              s.list.remove(n2._registeredObserverList, function(t4) {
                return a.Guard.isTransientRegisteredObserver(t4) && t4.observer === e3;
              });
            }
            if (!s.list.isEmpty(t3))
              try {
                e3._callback.call(e3, t3, e3);
              } catch (e4) {
              }
          };
          try {
            for (var f2 = n(l2), d = f2.next(); !d.done; d = f2.next()) {
              p2(d.value);
            }
          } catch (t3) {
            e2 = { error: t3 };
          } finally {
            try {
              d && !d.done && (t2 = f2.return) && t2.call(f2);
            } finally {
              if (e2)
                throw e2.error;
            }
          }
          if (o.dom.features.slots)
            try {
              for (var m = n(h2), y = m.next(); !y.done; y = m.next()) {
                var v = y.value;
                c.event_fireAnEvent("slotchange", v, void 0, { bubbles: true });
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                y && !y.done && (i2 = m.return) && i2.call(m);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
        }
        function f(e2, t2, r2, o2, a2, s2, c2, p2, f2) {
          for (var d, m, y = /* @__PURE__ */ new Map(), v = l.tree_getFirstAncestorNode(t2, true); null !== v; ) {
            for (var _ = 0; _ < v._registeredObserverList.length; _++) {
              var g = v._registeredObserverList[_], b = g.options;
              if ((v === t2 || b.subtree) && (("attributes" !== e2 || b.attributes) && ("attributes" !== e2 || !b.attributeFilter || b.attributeFilter.indexOf(r2 || "") && null === o2) && ("characterData" !== e2 || b.characterData) && ("childList" !== e2 || b.childList))) {
                var x = g.observer;
                y.has(x) || y.set(x, null), ("attributes" === e2 && b.attributeOldValue || "characterData" === e2 && b.characterDataOldValue) && y.set(x, a2);
              }
            }
            v = l.tree_getNextAncestorNode(t2, v, true);
          }
          try {
            for (var w = n(y), E = w.next(); !E.done; E = w.next()) {
              var D = i(E.value, 2), S = D[0], C = D[1], A = u.create_mutationRecord(e2, t2, u.create_nodeListStatic(t2, s2), u.create_nodeListStatic(t2, c2), p2, f2, r2, o2, C);
              S._recordQueue.push(A);
            }
          } catch (e3) {
            d = { error: e3 };
          } finally {
            try {
              E && !E.done && (m = w.return) && m.call(w);
            } finally {
              if (d)
                throw d.error;
            }
          }
          h();
        }
        t.observer_queueAMutationObserverMicrotask = h, t.observer_notifyMutationObservers = p, t.observer_queueMutationRecord = f, t.observer_queueTreeMutationRecord = function(e2, t2, r2, n2, i2) {
          f("childList", e2, null, null, null, t2, r2, n2, i2);
        }, t.observer_queueAttributeMutationRecord = function(e2, t2, r2, n2) {
          f("attributes", e2, t2, r2, n2, [], [], null, null);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(6), i = r(7), o = r(3), a = r(9), s = r(29), u = r(73), l = r(51), c = r(30), h = r(37), p = r(106);
        function f(e2, t2, r2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(t2, e2._localName, e2._namespace, e2._value), n.dom.features.customElements && o.Guard.isCustomElementNode(t2) && u.customElement_enqueueACustomElementCallbackReaction(t2, "attributeChangedCallback", [e2._localName, e2._value, r2, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(t2, e2._localName, e2._value, r2, e2._namespace), e2._value = r2;
        }
        function d(e2, t2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(t2, e2._localName, e2._namespace, null), n.dom.features.customElements && o.Guard.isCustomElementNode(t2) && u.customElement_enqueueACustomElementCallbackReaction(t2, "attributeChangedCallback", [e2._localName, null, e2._value, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(t2, e2._localName, null, e2._value, e2._namespace), t2._attributeList._asArray().push(e2), e2._element = t2, t2._nodeDocument._hasNamespaces || null === e2._namespace && null === e2._namespacePrefix && "xmlns" !== e2._localName || (t2._nodeDocument._hasNamespaces = true);
        }
        function m(e2, t2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(t2, e2._localName, e2._namespace, e2._value), n.dom.features.customElements && o.Guard.isCustomElementNode(t2) && u.customElement_enqueueACustomElementCallbackReaction(t2, "attributeChangedCallback", [e2._localName, e2._value, null, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(t2, e2._localName, e2._value, null, e2._namespace);
          var r2 = t2._attributeList._asArray().indexOf(e2);
          t2._attributeList._asArray().splice(r2, 1), e2._element = null;
        }
        function y(e2, t2, r2) {
          n.dom.features.mutationObservers && l.observer_queueAttributeMutationRecord(r2, e2._localName, e2._namespace, e2._value), n.dom.features.customElements && o.Guard.isCustomElementNode(r2) && u.customElement_enqueueACustomElementCallbackReaction(r2, "attributeChangedCallback", [e2._localName, e2._value, t2._value, e2._namespace]), n.dom.features.steps && c.dom_runAttributeChangeSteps(r2, e2._localName, e2._value, t2._value, e2._namespace);
          var i2 = r2._attributeList._asArray().indexOf(e2);
          -1 !== i2 && (r2._attributeList._asArray()[i2] = t2), e2._element = null, t2._element = r2, r2._nodeDocument._hasNamespaces || null === t2._namespace && null === t2._namespacePrefix && "xmlns" !== t2._localName || (r2._nodeDocument._hasNamespaces = true);
        }
        function v(e2, t2) {
          return t2._namespace === i.namespace.HTML && "html" === t2._nodeDocument._type && (e2 = e2.toLowerCase()), t2._attributeList._asArray().find(function(t3) {
            return t3._qualifiedName === e2;
          }) || null;
        }
        function _(e2, t2, r2) {
          var n2 = e2 || null;
          return r2._attributeList._asArray().find(function(e3) {
            return e3._namespace === n2 && e3._localName === t2;
          }) || null;
        }
        t.element_has = function(e2, t2) {
          return -1 !== t2._attributeList._asArray().indexOf(e2);
        }, t.element_change = f, t.element_append = d, t.element_remove = m, t.element_replace = y, t.element_getAnAttributeByName = v, t.element_getAnAttributeByNamespaceAndLocalName = _, t.element_getAnAttributeValue = function(e2, t2, r2) {
          void 0 === r2 && (r2 = "");
          var n2 = _(r2, t2, e2);
          return null === n2 ? "" : n2._value;
        }, t.element_setAnAttribute = function(e2, t2) {
          if (null !== e2._element && e2._element !== t2)
            throw new a.InUseAttributeError("This attribute already exists in the document: " + e2._qualifiedName + " as a child of " + e2._element._qualifiedName + ".");
          var r2 = _(e2._namespace || "", e2._localName, t2);
          return r2 === e2 ? e2 : (null !== r2 ? y(r2, e2, t2) : d(e2, t2), r2);
        }, t.element_setAnAttributeValue = function(e2, t2, r2, n2, i2) {
          void 0 === n2 && (n2 = null), void 0 === i2 && (i2 = null);
          var o2 = _(i2 || "", t2, e2);
          if (null === o2) {
            var a2 = s.create_attr(e2._nodeDocument, t2);
            return a2._namespace = i2, a2._namespacePrefix = n2, a2._value = r2, void d(a2, e2);
          }
          f(o2, e2, r2);
        }, t.element_removeAnAttributeByName = function(e2, t2) {
          var r2 = v(e2, t2);
          return null !== r2 && m(r2, t2), r2;
        }, t.element_removeAnAttributeByNamespaceAndLocalName = function(e2, t2, r2) {
          var n2 = _(e2, t2, r2);
          return null !== n2 && m(n2, r2), n2;
        }, t.element_createAnElement = function(e2, t2, r2, o2, l2, c2) {
          void 0 === o2 && (o2 = null), void 0 === l2 && (l2 = null), void 0 === c2 && (c2 = false);
          var h2 = null;
          if (!n.dom.features.customElements)
            return (h2 = s.create_element(e2, t2, r2, o2))._customElementState = "uncustomized", h2._customElementDefinition = null, h2._is = l2, h2;
          var f2 = u.customElement_lookUpACustomElementDefinition(e2, r2, t2, l2);
          if (null !== f2 && f2.name !== f2.localName)
            (h2 = new (p.document_elementInterface(t2, i.namespace.HTML))())._localName = t2, h2._namespace = i.namespace.HTML, h2._namespacePrefix = o2, h2._customElementState = "undefined", h2._customElementDefinition = null, h2._is = l2, h2._nodeDocument = e2, c2 ? u.customElement_upgrade(f2, h2) : u.customElement_enqueueACustomElementUpgradeReaction(h2, f2);
          else if (null !== f2)
            if (c2)
              try {
                var d2 = new (0, f2.constructor)();
                if (console.assert(void 0 !== d2._customElementState), console.assert(void 0 !== d2._customElementDefinition), console.assert(d2._namespace === i.namespace.HTML), 0 !== d2._attributeList.length)
                  throw new a.NotSupportedError("Custom element already has attributes.");
                if (0 !== d2._children.size)
                  throw new a.NotSupportedError("Custom element already has child nodes.");
                if (null !== d2._parent)
                  throw new a.NotSupportedError("Custom element already has a parent node.");
                if (d2._nodeDocument !== e2)
                  throw new a.NotSupportedError("Custom element is already in a document.");
                if (d2._localName !== t2)
                  throw new a.NotSupportedError("Custom element has a different local name.");
                d2._namespacePrefix = o2, d2._is = null;
              } catch (r3) {
                (h2 = s.create_htmlUnknownElement(e2, t2, i.namespace.HTML, o2))._customElementState = "failed", h2._customElementDefinition = null, h2._is = null;
              }
            else
              (h2 = s.create_htmlElement(e2, t2, i.namespace.HTML, o2))._customElementState = "undefined", h2._customElementDefinition = null, h2._is = null, u.customElement_enqueueACustomElementUpgradeReaction(h2, f2);
          else {
            (h2 = new (p.document_elementInterface(t2, r2))())._localName = t2, h2._namespace = r2, h2._namespacePrefix = o2, h2._customElementState = "uncustomized", h2._customElementDefinition = null, h2._is = l2, h2._nodeDocument = e2, r2 !== i.namespace.HTML || null === l2 && !u.customElement_isValidCustomElementName(t2) || (h2._customElementState = "undefined");
          }
          if (null === h2)
            throw new Error("Unable to create element.");
          return h2;
        }, t.element_insertAdjacent = function(e2, t2, r2) {
          switch (t2.toLowerCase()) {
            case "beforebegin":
              return null === e2._parent ? null : h.mutation_preInsert(r2, e2._parent, e2);
            case "afterbegin":
              return h.mutation_preInsert(r2, e2, e2._firstChild);
            case "beforeend":
              return h.mutation_preInsert(r2, e2, null);
            case "afterend":
              return null === e2._parent ? null : h.mutation_preInsert(r2, e2._parent, e2._nextSibling);
            default:
              throw new a.SyntaxError(`Invalid 'where' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected`);
          }
        };
      }, function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          Error.call(this), this.name = "YAMLException", this.reason = e2, this.mark = t2, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
        }
        n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n.prototype.toString = function(e2) {
          var t2 = this.name + ": ";
          return t2 += this.reason || "(unknown reason)", !e2 && this.mark && (t2 += " " + this.mark.toString()), t2;
        }, e.exports = n;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ include: [r(181)], implicit: [r(294), r(295)], explicit: [r(296), r(297), r(298), r(299)] });
      }, function(e, t, r) {
        var n = r(16), i = r(79), o = r(40), a = r(24), s = r(56), u = r(14), l = r(115), c = Object.getOwnPropertyDescriptor;
        t.f = n ? c : function(e2, t2) {
          if (e2 = a(e2), t2 = s(t2, true), l)
            try {
              return c(e2, t2);
            } catch (e3) {
            }
          if (u(e2, t2))
            return o(!i.f.call(e2, t2), e2[t2]);
        };
      }, function(e, t, r) {
        var n = r(13);
        e.exports = function(e2, t2) {
          if (!n(e2))
            return e2;
          var r2, i;
          if (t2 && "function" == typeof (r2 = e2.toString) && !n(i = r2.call(e2)))
            return i;
          if ("function" == typeof (r2 = e2.valueOf) && !n(i = r2.call(e2)))
            return i;
          if (!t2 && "function" == typeof (r2 = e2.toString) && !n(i = r2.call(e2)))
            return i;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(e, t, r) {
        var n = r(81), i = r(58), o = n("keys");
        e.exports = function(e2) {
          return o[e2] || (o[e2] = i(e2));
        };
      }, function(e, t) {
        var r = 0, n = Math.random();
        e.exports = function(e2) {
          return "Symbol(" + String(void 0 === e2 ? "" : e2) + ")_" + (++r + n).toString(36);
        };
      }, function(e, t, r) {
        var n = r(42);
        e.exports = Array.isArray || function(e2) {
          return "Array" == n(e2);
        };
      }, function(e, t, r) {
        var n, i = r(18), o = r(188), a = r(84), s = r(45), u = r(189), l = r(116), c = r(57), h = c("IE_PROTO"), p = function() {
        }, f = function(e2) {
          return "<script>" + e2 + "<\/script>";
        }, d = function() {
          try {
            n = document.domain && new ActiveXObject("htmlfile");
          } catch (e3) {
          }
          var e2, t2;
          d = n ? function(e3) {
            e3.write(f("")), e3.close();
            var t3 = e3.parentWindow.Object;
            return e3 = null, t3;
          }(n) : ((t2 = l("iframe")).style.display = "none", u.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(f("document.F=Object")), e2.close(), e2.F);
          for (var r2 = a.length; r2--; )
            delete d.prototype[a[r2]];
          return d();
        };
        s[h] = true, e.exports = Object.create || function(e2, t2) {
          var r2;
          return null !== e2 ? (p.prototype = i(e2), r2 = new p(), p.prototype = null, r2[h] = e2) : r2 = d(), void 0 === t2 ? r2 : o(r2, t2);
        };
      }, function(e, t, r) {
        var n = r(121), i = r(84);
        e.exports = Object.keys || function(e2) {
          return n(e2, i);
        };
      }, function(e, t, r) {
        var n = r(15).f, i = r(14), o = r(5)("toStringTag");
        e.exports = function(e2, t2, r2) {
          e2 && !i(e2 = r2 ? e2 : e2.prototype, o) && n(e2, o, { configurable: true, value: t2 });
        };
      }, function(e, t, r) {
        var n = r(8), i = r(5), o = r(129), a = i("species");
        e.exports = function(e2) {
          return o >= 51 || !n(function() {
            var t2 = [];
            return (t2.constructor = {})[a] = function() {
              return { foo: 1 };
            }, 1 !== t2[e2](Boolean).foo;
          });
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(122).indexOf, o = r(48), a = r(28), s = [].indexOf, u = !!s && 1 / [1].indexOf(1, -0) < 0, l = o("indexOf"), c = a("indexOf", { ACCESSORS: true, 1: 0 });
        n({ target: "Array", proto: true, forced: u || !l || !c }, { indexOf: function(e2) {
          return u ? s.apply(this, arguments) || 0 : i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        var n = r(16), i = r(15).f, o = Function.prototype, a = o.toString, s = /^\s*function ([^ (]*)/;
        n && !("name" in o) && i(o, "name", { configurable: true, get: function() {
          try {
            return a.call(this).match(s)[1];
          } catch (e2) {
            return "";
          }
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(25), i = r(18), o = r(8), a = r(136), s = RegExp.prototype, u = s.toString, l = o(function() {
          return "/a/b" != u.call({ source: "a", flags: "b" });
        }), c = "toString" != u.name;
        (l || c) && n(RegExp.prototype, "toString", function() {
          var e2 = i(this), t2 = String(e2.source), r2 = e2.flags;
          return "/" + t2 + "/" + String(void 0 === r2 && e2 instanceof RegExp && !("flags" in s) ? a.call(e2) : r2);
        }, { unsafe: true });
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(138), r(20), r(66), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(2), s = r(1), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._writerOptions = a.applyDefaults(r2, { format: "object", wellFormed: false, group: false, verbose: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            return this._currentList = [], this._currentIndex = 0, this._listRegister = [this._currentList], this.serializeNode(e3, this._writerOptions.wellFormed), this._process(this._currentList, this._writerOptions);
          }, t2.prototype._process = function(e3, t3) {
            var r2, n2, i2, o2, u2, l, c;
            if (0 === e3.length)
              return {};
            for (var h = {}, p = false, f = 0, d = 0, m = 0, y = 0, v = 0; v < e3.length; v++) {
              var _ = e3[v];
              switch (I = Object.keys(_)[0]) {
                case "@":
                  continue;
                case "#":
                  f++;
                  break;
                case "!":
                  d++;
                  break;
                case "?":
                  m++;
                  break;
                case "$":
                  y++;
                  break;
                default:
                  h[I] ? p = true : h[I] = true;
              }
            }
            var g = this._getAttrKey(), b = this._getNodeKey(s.NodeType.Text), x = this._getNodeKey(s.NodeType.Comment), w = this._getNodeKey(s.NodeType.ProcessingInstruction), E = this._getNodeKey(s.NodeType.CData);
            if (1 === f && 1 === e3.length && a.isString(e3[0]["#"]))
              return e3[0]["#"];
            if (p) {
              var D = {};
              for (v = 0; v < e3.length; v++) {
                _ = e3[v];
                if ("@" === (I = Object.keys(_)[0])) {
                  var S = _["@"];
                  1 === (L = Object.keys(S)).length ? D[g + L[0]] = S[L[0]] : D[g] = _["@"];
                }
              }
              var C = [];
              for (v = 0; v < e3.length; v++) {
                _ = e3[v];
                switch (I = Object.keys(_)[0]) {
                  case "@":
                    break;
                  case "#":
                    C.push(((r2 = {})[b] = _["#"], r2));
                    break;
                  case "!":
                    C.push(((n2 = {})[x] = _["!"], n2));
                    break;
                  case "?":
                    C.push(((i2 = {})[w] = _["?"], i2));
                    break;
                  case "$":
                    C.push(((o2 = {})[E] = _.$, o2));
                    break;
                  default:
                    if (0 !== (B = _)[I].length && a.isArray(B[I][0])) {
                      for (var A = [], N = B[I], T = 0; T < N.length; T++)
                        A.push(this._process(N[T], t3));
                      C.push(((u2 = {})[I] = A, u2));
                    } else
                      t3.verbose ? C.push(((l = {})[I] = [this._process(B[I], t3)], l)) : C.push(((c = {})[I] = this._process(B[I], t3), c));
                }
              }
              return D[b] = C, D;
            }
            var O = 1, F = 1, k = 1, P = 1;
            for (D = {}, v = 0; v < e3.length; v++) {
              var I;
              _ = e3[v];
              switch (I = Object.keys(_)[0]) {
                case "@":
                  S = _["@"];
                  var L = Object.keys(S);
                  if (t3.group && 1 !== L.length)
                    D[g] = S;
                  else
                    for (var M in S)
                      D[g + M] = S[M];
                  break;
                case "#":
                  O = this._processSpecItem(_["#"], D, t3.group, b, f, O);
                  break;
                case "!":
                  F = this._processSpecItem(_["!"], D, t3.group, x, d, F);
                  break;
                case "?":
                  k = this._processSpecItem(_["?"], D, t3.group, w, m, k);
                  break;
                case "$":
                  P = this._processSpecItem(_.$, D, t3.group, E, y, P);
                  break;
                default:
                  var B;
                  if (0 !== (B = _)[I].length && a.isArray(B[I][0])) {
                    A = [], N = B[I];
                    for (var j = 0; j < N.length; j++)
                      A.push(this._process(N[j], t3));
                    D[I] = A;
                  } else
                    t3.verbose ? D[I] = [this._process(B[I], t3)] : D[I] = this._process(B[I], t3);
              }
            }
            return D;
          }, t2.prototype._processSpecItem = function(e3, t3, r2, n2, i2, s2) {
            var u2, l;
            if (!r2 && a.isArray(e3) && i2 + e3.length > 2)
              try {
                for (var c = o(e3), h = c.next(); !h.done; h = c.next()) {
                  var p = h.value;
                  t3[n2 + (s2++).toString()] = p;
                }
              } catch (e4) {
                u2 = { error: e4 };
              } finally {
                try {
                  h && !h.done && (l = c.return) && l.call(c);
                } finally {
                  if (u2)
                    throw u2.error;
                }
              }
            else
              t3[i2 > 1 ? n2 + (s2++).toString() : n2] = e3;
            return s2;
          }, t2.prototype.beginElement = function(e3) {
            var t3, r2, n2 = [];
            if (0 === this._currentList.length)
              this._currentList.push(((t3 = {})[e3] = n2, t3));
            else {
              var i2 = this._currentList[this._currentList.length - 1];
              if (this._isElementNode(i2, e3))
                if (0 !== i2[e3].length && a.isArray(i2[e3][0]))
                  i2[e3].push(n2);
                else
                  i2[e3] = [i2[e3], n2];
              else
                this._currentList.push(((r2 = {})[e3] = n2, r2));
            }
            this._currentIndex++, this._listRegister.length > this._currentIndex ? this._listRegister[this._currentIndex] = n2 : this._listRegister.push(n2), this._currentList = n2;
          }, t2.prototype.endElement = function() {
            this._currentList = this._listRegister[--this._currentIndex];
          }, t2.prototype.attribute = function(e3, t3) {
            var r2, n2;
            if (0 === this._currentList.length)
              this._currentList.push({ "@": (r2 = {}, r2[e3] = t3, r2) });
            else {
              var i2 = this._currentList[this._currentList.length - 1];
              this._isAttrNode(i2) ? i2["@"][e3] = t3 : this._currentList.push({ "@": (n2 = {}, n2[e3] = t3, n2) });
            }
          }, t2.prototype.comment = function(e3) {
            if (0 === this._currentList.length)
              this._currentList.push({ "!": e3 });
            else {
              var t3 = this._currentList[this._currentList.length - 1];
              this._isCommentNode(t3) ? a.isArray(t3["!"]) ? t3["!"].push(e3) : t3["!"] = [t3["!"], e3] : this._currentList.push({ "!": e3 });
            }
          }, t2.prototype.text = function(e3) {
            if (0 === this._currentList.length)
              this._currentList.push({ "#": e3 });
            else {
              var t3 = this._currentList[this._currentList.length - 1];
              this._isTextNode(t3) ? a.isArray(t3["#"]) ? t3["#"].push(e3) : t3["#"] = [t3["#"], e3] : this._currentList.push({ "#": e3 });
            }
          }, t2.prototype.instruction = function(e3, t3) {
            var r2 = "" === t3 ? e3 : e3 + " " + t3;
            if (0 === this._currentList.length)
              this._currentList.push({ "?": r2 });
            else {
              var n2 = this._currentList[this._currentList.length - 1];
              this._isInstructionNode(n2) ? a.isArray(n2["?"]) ? n2["?"].push(r2) : n2["?"] = [n2["?"], r2] : this._currentList.push({ "?": r2 });
            }
          }, t2.prototype.cdata = function(e3) {
            if (0 === this._currentList.length)
              this._currentList.push({ $: e3 });
            else {
              var t3 = this._currentList[this._currentList.length - 1];
              this._isCDATANode(t3) ? a.isArray(t3.$) ? t3.$.push(e3) : t3.$ = [t3.$, e3] : this._currentList.push({ $: e3 });
            }
          }, t2.prototype._isAttrNode = function(e3) {
            return "@" in e3;
          }, t2.prototype._isTextNode = function(e3) {
            return "#" in e3;
          }, t2.prototype._isCommentNode = function(e3) {
            return "!" in e3;
          }, t2.prototype._isInstructionNode = function(e3) {
            return "?" in e3;
          }, t2.prototype._isCDATANode = function(e3) {
            return "$" in e3;
          }, t2.prototype._isElementNode = function(e3, t3) {
            return t3 in e3;
          }, t2.prototype._getAttrKey = function() {
            return this._builderOptions.convert.att;
          }, t2.prototype._getNodeKey = function(e3) {
            switch (e3) {
              case s.NodeType.Comment:
                return this._builderOptions.convert.comment;
              case s.NodeType.Text:
                return this._builderOptions.convert.text;
              case s.NodeType.ProcessingInstruction:
                return this._builderOptions.convert.ins;
              case s.NodeType.CData:
                return this._builderOptions.convert.cdata;
              default:
                throw new Error("Invalid node type.");
            }
          }, t2;
        }(r(50).BaseWriter);
        t.ObjectWriter = u;
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(93);
        n({ target: "RegExp", proto: true, forced: /./.exec !== i }, { exec: i });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
            this._items = {}, this._nullItems = {};
          }
          return e2.prototype.set = function(e3, t2) {
            null === e3 ? this._nullItems[t2] = true : (this._items[e3] || (this._items[e3] = {}), this._items[e3][t2] = true);
          }, e2.prototype.has = function(e3, t2) {
            return null === e3 ? true === this._nullItems[t2] : !!this._items[e3] && true === this._items[e3][t2];
          }, e2;
        }();
        t.LocalNameSet = n;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(9), o = r(3), a = r(0), s = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "_eventListenerList", { get: function() {
            return this.__eventListenerList || (this.__eventListenerList = []);
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_eventHandlerMap", { get: function() {
            return this.__eventHandlerMap || (this.__eventHandlerMap = {});
          }, enumerable: true, configurable: true }), e2.prototype.addEventListener = function(e3, t2, r2) {
            void 0 === r2 && (r2 = { passive: false, once: false, capture: false });
            var i2, s2 = n(a.eventTarget_flattenMore(r2), 3), u = s2[0], l = s2[1], c = s2[2];
            t2 && (i2 = o.Guard.isEventListener(t2) ? t2 : { handleEvent: t2 }, a.eventTarget_addEventListener(this, { type: e3, callback: i2, capture: u, passive: l, once: c, removed: false }));
          }, e2.prototype.removeEventListener = function(e3, t2, r2) {
            void 0 === r2 && (r2 = { capture: false });
            var n2 = a.eventTarget_flatten(r2);
            if (t2)
              for (var i2 = 0; i2 < this._eventListenerList.length; i2++) {
                var s2 = this._eventListenerList[i2];
                if (s2.type === e3 && s2.capture === n2) {
                  if (o.Guard.isEventListener(t2) && s2.callback === t2) {
                    a.eventTarget_removeEventListener(this, s2, i2);
                    break;
                  }
                  if (t2 && s2.callback.handleEvent === t2) {
                    a.eventTarget_removeEventListener(this, s2, i2);
                    break;
                  }
                }
              }
          }, e2.prototype.dispatchEvent = function(e3) {
            if (e3._dispatchFlag || !e3._initializedFlag)
              throw new i.InvalidStateError();
            return e3._isTrusted = false, a.event_dispatch(e3, this);
          }, e2.prototype._getTheParent = function(e3) {
            return null;
          }, e2;
        }();
        t.EventTargetImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(34), a = r(0), s = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this) || this;
            return r2._data = t3, r2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "data", { get: function() {
            return this._data;
          }, set: function(e3) {
            a.characterData_replaceData(this, 0, this._data.length, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "length", { get: function() {
            return this._data.length;
          }, enumerable: true, configurable: true }), t2.prototype.substringData = function(e3, t3) {
            return a.characterData_substringData(this, e3, t3);
          }, t2.prototype.appendData = function(e3) {
            return a.characterData_replaceData(this, this._data.length, 0, e3);
          }, t2.prototype.insertData = function(e3, t3) {
            a.characterData_replaceData(this, e3, 0, t3);
          }, t2.prototype.deleteData = function(e3, t3) {
            a.characterData_replaceData(this, e3, t3, "");
          }, t2.prototype.replaceData = function(e3, t3, r2) {
            a.characterData_replaceData(this, e3, t3, r2);
          }, Object.defineProperty(t2.prototype, "previousElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nextElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.before = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.after = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.replaceWith = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.remove = function() {
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2;
        }(o.NodeImpl);
        t.CharacterDataImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(3), u = r(2), l = r(17), c = r(51);
        function h(e2) {
          a.dom.window._signalSlots.add(e2), c.observer_queueAMutationObserverMicrotask();
        }
        function p(e2, t2) {
          void 0 === t2 && (t2 = false);
          var r2 = s.Cast.asNode(e2)._parent;
          if (null === r2)
            return null;
          var n2 = r2._shadowRoot || null;
          if (null === n2)
            return null;
          if (t2 && "open" !== n2._mode)
            return null;
          for (var i2 = l.tree_getFirstDescendantNode(n2, false, true, function(e3) {
            return s.Guard.isSlot(e3);
          }); null !== i2; ) {
            if (i2._name === e2._name)
              return i2;
            i2 = l.tree_getNextDescendantNode(n2, i2, false, true, function(e3) {
              return s.Guard.isSlot(e3);
            });
          }
          return null;
        }
        function f(e2) {
          var t2, r2, i2 = [], o2 = l.tree_rootNode(e2);
          if (!s.Guard.isShadowRoot(o2))
            return i2;
          var a2 = o2._host;
          try {
            for (var u2 = n(a2._children), c2 = u2.next(); !c2.done; c2 = u2.next()) {
              var h2 = c2.value;
              if (s.Guard.isSlotable(h2))
                p(h2) === e2 && i2.push(h2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (r2 = u2.return) && r2.call(u2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          return i2;
        }
        function d(e2) {
          var t2, r2, i2 = f(e2);
          if (i2.length === e2._assignedNodes.length) {
            for (var o2 = true, a2 = 0; a2 < i2.length; a2++)
              if (i2[a2] !== e2._assignedNodes[a2]) {
                o2 = false;
                break;
              }
            o2 || h(e2);
          }
          e2._assignedNodes = i2;
          try {
            for (var s2 = n(i2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
              u2.value._assignedSlot = e2;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              u2 && !u2.done && (r2 = s2.return) && r2.call(s2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
        }
        t.shadowTree_signalASlotChange = h, t.shadowTree_isConnected = function(e2) {
          return s.Guard.isDocumentNode(l.tree_rootNode(e2, true));
        }, t.shadowTree_isAssigned = function(e2) {
          return null !== e2._assignedSlot;
        }, t.shadowTree_findASlot = p, t.shadowTree_findSlotables = f, t.shadowTree_findFlattenedSlotables = function e2(t2) {
          var r2, i2, a2, c2, h2 = [], p2 = l.tree_rootNode(t2);
          if (!s.Guard.isShadowRoot(p2))
            return h2;
          var d2 = f(t2);
          if (u.isEmpty(d2))
            try {
              for (var m = n(t2._children), y = m.next(); !y.done; y = m.next()) {
                var v = y.value;
                s.Guard.isSlotable(v) && d2.push(v);
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                y && !y.done && (i2 = m.return) && i2.call(m);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          try {
            for (var _ = n(d2), g = _.next(); !g.done; g = _.next()) {
              var b = g.value;
              if (s.Guard.isSlot(b) && s.Guard.isShadowRoot(l.tree_rootNode(b))) {
                var x = e2(b);
                h2.push.apply(h2, o(x));
              } else
                h2.push(b);
            }
          } catch (e3) {
            a2 = { error: e3 };
          } finally {
            try {
              g && !g.done && (c2 = _.return) && c2.call(_);
            } finally {
              if (a2)
                throw a2.error;
            }
          }
          return h2;
        }, t.shadowTree_assignSlotables = d, t.shadowTree_assignSlotablesForATree = function(e2) {
          for (var t2 = l.tree_getFirstDescendantNode(e2, true, false, function(e3) {
            return s.Guard.isSlot(e3);
          }); null !== t2; )
            d(t2), t2 = l.tree_getNextDescendantNode(e2, t2, true, false, function(e3) {
              return s.Guard.isSlot(e3);
            });
        }, t.shadowTree_assignASlot = function(e2) {
          var t2 = p(e2);
          null !== t2 && d(t2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/, i = /* @__PURE__ */ new Set(["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"]), o = /* @__PURE__ */ new Set(["article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main", "nav", "p", "section", "span"]), a = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), s = /* @__PURE__ */ new Set(["article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main", "nav", "p", "section", "span"]);
        t.customElement_isValidCustomElementName = function(e2) {
          return !!n.test(e2) && !i.has(e2);
        }, t.customElement_isValidElementName = function(e2) {
          return o.has(e2);
        }, t.customElement_isVoidElementName = function(e2) {
          return a.has(e2);
        }, t.customElement_isValidShadowHostName = function(e2) {
          return s.has(e2);
        }, t.customElement_enqueueACustomElementUpgradeReaction = function(e2, t2) {
        }, t.customElement_enqueueACustomElementCallbackReaction = function(e2, t2, r2) {
        }, t.customElement_upgrade = function(e2, t2) {
        }, t.customElement_tryToUpgrade = function(e2) {
        }, t.customElement_lookUpACustomElementDefinition = function(e2, t2, r2, n2) {
          return null;
        };
      }, function(e, t, r) {
        r(4)({ target: "String", proto: true }, { repeat: r(260) });
      }, function(e, t, r) {
        "use strict";
        r(279), r(68), r(179), r(94), Object.defineProperty(t, "__esModule", { value: true });
        var n = r(109), i = function() {
          function e2(e3) {
            this._builderOptions = e3, e3.parser && Object.assign(this, e3.parser);
          }
          return e2.prototype._docType = function(e3, t2, r2, n2) {
            return e3.dtd({ name: t2, pubID: r2, sysID: n2 });
          }, e2.prototype._comment = function(e3, t2) {
            return e3.com(t2);
          }, e2.prototype._text = function(e3, t2) {
            return e3.txt(t2);
          }, e2.prototype._instruction = function(e3, t2, r2) {
            return e3.ins(t2, r2);
          }, e2.prototype._cdata = function(e3, t2) {
            return e3.dat(t2);
          }, e2.prototype._element = function(e3, t2, r2) {
            return void 0 === t2 ? e3.ele(r2) : e3.ele(t2, r2);
          }, e2.prototype._attribute = function(e3, t2, r2, n2) {
            return void 0 === t2 ? e3.att(r2, n2) : e3.att(t2, r2, n2);
          }, e2.prototype._sanitize = function(e3) {
            return n.sanitizeInput(e3, this._builderOptions.invalidCharReplacement);
          }, e2.prototype._decodeText = function(t2) {
            return null == t2 ? t2 : t2.replace(/&(quot|amp|apos|lt|gt);/g, function(t3, r2) {
              return e2._entityTable[r2];
            }).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g, function(e3, t3, r2) {
              return String.fromCodePoint(parseInt(t3 || r2, t3 ? 16 : 10));
            });
          }, e2.prototype._decodeAttributeValue = function(e3) {
            return this._decodeText(e3);
          }, e2.prototype.parse = function(e3, t2) {
            return this._parse(e3, t2);
          }, e2.prototype.docType = function(e3, t2, r2, n2) {
            return this._docType(e3, t2, r2, n2);
          }, e2.prototype.comment = function(e3, t2) {
            return this._comment(e3, t2);
          }, e2.prototype.text = function(e3, t2) {
            return this._text(e3, t2);
          }, e2.prototype.instruction = function(e3, t2, r2) {
            return this._instruction(e3, t2, r2);
          }, e2.prototype.cdata = function(e3, t2) {
            return this._cdata(e3, t2);
          }, e2.prototype.element = function(e3, t2, r2) {
            return this._element(e3, t2, r2);
          }, e2.prototype.attribute = function(e3, t2, r2, n2) {
            return this._attribute(e3, t2, r2, n2);
          }, e2.prototype.sanitize = function(e3) {
            return this._sanitize(e3);
          }, e2._entityTable = { lt: "<", gt: ">", amp: "&", quot: '"', apos: "'" }, e2;
        }();
        t.BaseReader = i;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = n.DEFAULT = new n({ include: [r(54)], explicit: [r(300), r(301), r(302)] });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(185);
        t.XMLBuilderImpl = n.XMLBuilderImpl;
        var i = r(305);
        t.XMLBuilderCBImpl = i.XMLBuilderCBImpl;
        var o = r(183);
        t.builder = o.builder, t.create = o.create, t.fragment = o.fragment, t.convert = o.convert;
        var a = r(310);
        t.createCB = a.createCB, t.fragmentCB = a.fragmentCB;
      }, function(e, t) {
        var r;
        r = function() {
          return this;
        }();
        try {
          r = r || new Function("return this")();
        } catch (e2) {
          "object" == typeof window && (r = window);
        }
        e.exports = r;
      }, function(e, t, r) {
        "use strict";
        var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, o = i && !n.call({ 1: 2 }, 1);
        t.f = o ? function(e2) {
          var t2 = i(this, e2);
          return !!t2 && t2.enumerable;
        } : n;
      }, function(e, t, r) {
        var n = r(11), i = r(21);
        e.exports = function(e2, t2) {
          try {
            i(n, e2, t2);
          } catch (r2) {
            n[e2] = t2;
          }
          return t2;
        };
      }, function(e, t, r) {
        var n = r(44), i = r(118);
        (e.exports = function(e2, t2) {
          return i[e2] || (i[e2] = void 0 !== t2 ? t2 : {});
        })("versions", []).push({ version: "3.6.5", mode: n ? "pure" : "global", copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)" });
      }, function(e, t, r) {
        var n = r(121), i = r(84).concat("length", "prototype");
        t.f = Object.getOwnPropertyNames || function(e2) {
          return n(e2, i);
        };
      }, function(e, t, r) {
        var n = r(47), i = Math.max, o = Math.min;
        e.exports = function(e2, t2) {
          var r2 = n(e2);
          return r2 < 0 ? i(r2 + t2, 0) : o(r2, t2);
        };
      }, function(e, t) {
        e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, function(e, t) {
        t.f = Object.getOwnPropertySymbols;
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !!Object.getOwnPropertySymbols && !n(function() {
          return !String(Symbol());
        });
      }, function(e, t, r) {
        var n = r(127);
        e.exports = function(e2, t2, r2) {
          if (n(e2), void 0 === t2)
            return e2;
          switch (r2) {
            case 0:
              return function() {
                return e2.call(t2);
              };
            case 1:
              return function(r3) {
                return e2.call(t2, r3);
              };
            case 2:
              return function(r3, n2) {
                return e2.call(t2, r3, n2);
              };
            case 3:
              return function(r3, n2, i) {
                return e2.call(t2, r3, n2, i);
              };
          }
          return function() {
            return e2.apply(t2, arguments);
          };
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(195), o = r(132), a = r(133), s = r(62), u = r(21), l = r(25), c = r(5), h = r(44), p = r(49), f = r(131), d = f.IteratorPrototype, m = f.BUGGY_SAFARI_ITERATORS, y = c("iterator"), v = function() {
          return this;
        };
        e.exports = function(e2, t2, r2, c2, f2, _, g) {
          i(r2, t2, c2);
          var b, x, w, E = function(e3) {
            if (e3 === f2 && N)
              return N;
            if (!m && e3 in C)
              return C[e3];
            switch (e3) {
              case "keys":
              case "values":
              case "entries":
                return function() {
                  return new r2(this, e3);
                };
            }
            return function() {
              return new r2(this);
            };
          }, D = t2 + " Iterator", S = false, C = e2.prototype, A = C[y] || C["@@iterator"] || f2 && C[f2], N = !m && A || E(f2), T = "Array" == t2 && C.entries || A;
          if (T && (b = o(T.call(new e2())), d !== Object.prototype && b.next && (h || o(b) === d || (a ? a(b, d) : "function" != typeof b[y] && u(b, y, v)), s(b, D, true, true), h && (p[D] = v))), "values" == f2 && A && "values" !== A.name && (S = true, N = function() {
            return A.call(this);
          }), h && !g || C[y] === N || u(C, y, N), p[t2] = N, f2)
            if (x = { values: E("values"), keys: _ ? N : E("keys"), entries: E("entries") }, g)
              for (w in x)
                (m || S || !(w in C)) && l(C, w, x[w]);
            else
              n({ target: t2, proto: true, forced: m || S }, x);
          return x;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(13), o = r(59), a = r(83), s = r(26), u = r(24), l = r(134), c = r(5), h = r(63), p = r(28), f = h("slice"), d = p("slice", { ACCESSORS: true, 0: 0, 1: 2 }), m = c("species"), y = [].slice, v = Math.max;
        n({ target: "Array", proto: true, forced: !f || !d }, { slice: function(e2, t2) {
          var r2, n2, c2, h2 = u(this), p2 = s(h2.length), f2 = a(e2, p2), d2 = a(void 0 === t2 ? p2 : t2, p2);
          if (o(h2) && ("function" != typeof (r2 = h2.constructor) || r2 !== Array && !o(r2.prototype) ? i(r2) && null === (r2 = r2[m]) && (r2 = void 0) : r2 = void 0, r2 === Array || void 0 === r2))
            return y.call(h2, f2, d2);
          for (n2 = new (void 0 === r2 ? Array : r2)(v(d2 - f2, 0)), c2 = 0; f2 < d2; f2++, c2++)
            f2 in h2 && l(n2, c2, h2[f2]);
          return n2.length = c2, n2;
        } });
      }, function(e, t, r) {
        var n = {};
        n[r(5)("toStringTag")] = "z", e.exports = "[object z]" === String(n);
      }, function(e, t, r) {
        "use strict";
        r(19), r(138), r(20), r(92), r(22), r(23), Object.defineProperty(t, "__esModule", { value: true }), t.DefaultBuilderOptions = { version: "1.0", encoding: void 0, standalone: void 0, keepNullNodes: false, keepNullAttributes: false, ignoreConverters: false, skipWhitespaceOnlyText: true, convert: { att: "@", ins: "?", text: "#", cdata: "$", comment: "!" }, defaultNamespace: { ele: void 0, att: void 0 }, namespaceAlias: { html: "http://www.w3.org/1999/xhtml", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink" }, invalidCharReplacement: void 0, parser: void 0 }, t.XMLBuilderOptionKeys = new Set(Object.keys(t.DefaultBuilderOptions)), t.DefaultXMLBuilderCBOptions = { format: "xml", wellFormed: false, prettyPrint: false, indent: "  ", newline: "\n", offset: 0, width: 0, allowEmptyTags: false, spaceBeforeSlash: false, keepNullNodes: false, keepNullAttributes: false, ignoreConverters: false, convert: { att: "@", ins: "?", text: "#", cdata: "$", comment: "!" }, defaultNamespace: { ele: void 0, att: void 0 }, namespaceAlias: { html: "http://www.w3.org/1999/xhtml", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink" } };
      }, function(e, t, r) {
        "use strict";
        var n = r(139), i = r(143);
        e.exports = n("Set", function(e2) {
          return function() {
            return e2(this, arguments.length ? arguments[0] : void 0);
          };
        }, i);
      }, function(e, t, r) {
        "use strict";
        var n, i, o = r(136), a = r(221), s = RegExp.prototype.exec, u = String.prototype.replace, l = s, c = (n = /a/, i = /b*/g, s.call(n, "a"), s.call(i, "a"), 0 !== n.lastIndex || 0 !== i.lastIndex), h = a.UNSUPPORTED_Y || a.BROKEN_CARET, p = void 0 !== /()??/.exec("")[1];
        (c || p || h) && (l = function(e2) {
          var t2, r2, n2, i2, a2 = this, l2 = h && a2.sticky, f = o.call(a2), d = a2.source, m = 0, y = e2;
          return l2 && (-1 === (f = f.replace("y", "")).indexOf("g") && (f += "g"), y = String(e2).slice(a2.lastIndex), a2.lastIndex > 0 && (!a2.multiline || a2.multiline && "\n" !== e2[a2.lastIndex - 1]) && (d = "(?: " + d + ")", y = " " + y, m++), r2 = new RegExp("^(?:" + d + ")", f)), p && (r2 = new RegExp("^" + d + "$(?!\\s)", f)), c && (t2 = a2.lastIndex), n2 = s.call(l2 ? r2 : a2, y), l2 ? n2 ? (n2.input = n2.input.slice(m), n2[0] = n2[0].slice(m), n2.index = a2.lastIndex, a2.lastIndex += n2[0].length) : a2.lastIndex = 0 : c && n2 && (a2.lastIndex = a2.global ? n2.index + n2[0].length : t2), p && n2 && n2.length > 1 && u.call(n2[0], r2, function() {
            for (i2 = 1; i2 < arguments.length - 2; i2++)
              void 0 === arguments[i2] && (n2[i2] = void 0);
          }), n2;
        }), e.exports = l;
      }, function(e, t, r) {
        "use strict";
        var n = r(225), i = r(18), o = r(27), a = r(26), s = r(47), u = r(35), l = r(226), c = r(227), h = Math.max, p = Math.min, f = Math.floor, d = /\$([$&'`]|\d\d?|<[^>]*>)/g, m = /\$([$&'`]|\d\d?)/g;
        n("replace", 2, function(e2, t2, r2, n2) {
          var y = n2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, v = n2.REPLACE_KEEPS_$0, _ = y ? "$" : "$0";
          return [function(r3, n3) {
            var i2 = u(this), o2 = null == r3 ? void 0 : r3[e2];
            return void 0 !== o2 ? o2.call(r3, i2, n3) : t2.call(String(i2), r3, n3);
          }, function(e3, n3) {
            if (!y && v || "string" == typeof n3 && -1 === n3.indexOf(_)) {
              var o2 = r2(t2, e3, this, n3);
              if (o2.done)
                return o2.value;
            }
            var u2 = i(e3), f2 = String(this), d2 = "function" == typeof n3;
            d2 || (n3 = String(n3));
            var m2 = u2.global;
            if (m2) {
              var b = u2.unicode;
              u2.lastIndex = 0;
            }
            for (var x = []; ; ) {
              var w = c(u2, f2);
              if (null === w)
                break;
              if (x.push(w), !m2)
                break;
              "" === String(w[0]) && (u2.lastIndex = l(f2, a(u2.lastIndex), b));
            }
            for (var E, D = "", S = 0, C = 0; C < x.length; C++) {
              w = x[C];
              for (var A = String(w[0]), N = h(p(s(w.index), f2.length), 0), T = [], O = 1; O < w.length; O++)
                T.push(void 0 === (E = w[O]) ? E : String(E));
              var F = w.groups;
              if (d2) {
                var k = [A].concat(T, N, f2);
                void 0 !== F && k.push(F);
                var P = String(n3.apply(void 0, k));
              } else
                P = g(A, f2, N, T, F, n3);
              N >= S && (D += f2.slice(S, N) + P, S = N + A.length);
            }
            return D + f2.slice(S);
          }];
          function g(e3, r3, n3, i2, a2, s2) {
            var u2 = n3 + e3.length, l2 = i2.length, c2 = m;
            return void 0 !== a2 && (a2 = o(a2), c2 = d), t2.call(s2, c2, function(t3, o2) {
              var s3;
              switch (o2.charAt(0)) {
                case "$":
                  return "$";
                case "&":
                  return e3;
                case "`":
                  return r3.slice(0, n3);
                case "'":
                  return r3.slice(u2);
                case "<":
                  s3 = a2[o2.slice(1, -1)];
                  break;
                default:
                  var c3 = +o2;
                  if (0 === c3)
                    return t3;
                  if (c3 > l2) {
                    var h2 = f(c3 / 10);
                    return 0 === h2 ? t3 : h2 <= l2 ? void 0 === i2[h2 - 1] ? o2.charAt(1) : i2[h2 - 1] + o2.charAt(1) : t3;
                  }
                  s3 = i2[c3 - 1];
              }
              return void 0 === s3 ? "" : s3;
            });
          }
        });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
            this._items = {}, this._nullItems = [];
          }
          return e2.prototype.copy = function() {
            var t2 = new e2();
            for (var r2 in this._items)
              t2._items[r2] = this._items[r2].slice(0);
            return t2._nullItems = this._nullItems.slice(0), t2;
          }, e2.prototype.get = function(e3, t2) {
            var r2 = null === t2 ? this._nullItems : this._items[t2] || null;
            if (null === r2)
              return null;
            for (var n2 = null, i = 0; i < r2.length; i++)
              if ((n2 = r2[i]) === e3)
                return n2;
            return n2;
          }, e2.prototype.has = function(e3, t2) {
            var r2 = null === t2 ? this._nullItems : this._items[t2] || null;
            return null !== r2 && -1 !== r2.indexOf(e3);
          }, e2.prototype.hasPrefix = function(e3) {
            if (-1 !== this._nullItems.indexOf(e3))
              return true;
            for (var t2 in this._items)
              if (-1 !== this._items[t2].indexOf(e3))
                return true;
            return false;
          }, e2.prototype.set = function(e3, t2) {
            var r2 = null === t2 ? this._nullItems : this._items[t2] || null;
            null !== t2 && null === r2 ? this._items[t2] = [e3] : r2.push(e3);
          }, e2;
        }();
        t.NamespacePrefixMap = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Surrogate = /[\uD800-\uDFFF]/, t.ScalarValue = /[\uD800-\uDFFF]/, t.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/, t.ASCIICodePoint = /[\u0000-\u007F]/, t.ASCIITabOrNewLine = /[\t\n\r]/, t.ASCIIWhiteSpace = /[\t\n\f\r ]/, t.C0Control = /[\u0000-\u001F]/, t.C0ControlOrSpace = /[\u0000-\u001F ]/, t.Control = /[\u0000-\u001F\u007F-\u009F]/, t.ASCIIDigit = /[0-9]/, t.ASCIIUpperHexDigit = /[0-9A-F]/, t.ASCIILowerHexDigit = /[0-9a-f]/, t.ASCIIHexDigit = /[0-9A-Fa-f]/, t.ASCIIUpperAlpha = /[A-Z]/, t.ASCIILowerAlpha = /[a-z]/, t.ASCIIAlpha = /[A-Za-z]/, t.ASCIIAlphanumeric = /[0-9A-Za-z]/;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(1), u = r(3), l = r(171), c = r(104), h = r(9), p = r(17), f = r(72), d = r(30);
        function m(e2, t2) {
          void 0 === t2 && (t2 = void 0), void 0 === t2 && (t2 = null);
          var r2 = y(e2, t2, /* @__PURE__ */ new Date(), {});
          return r2._isTrusted = true, r2;
        }
        function y(e2, t2, r2, n2) {
          var i2 = new e2("");
          return i2._initializedFlag = true, i2._timeStamp = r2.getTime(), Object.assign(i2, n2), a.dom.features.steps && d.dom_runEventConstructingSteps(i2), i2;
        }
        function v(e2, t2, r2, i2) {
          var o2, a2, l2, c2;
          void 0 === r2 && (r2 = false), void 0 === i2 && (i2 = { value: false });
          var h2 = false;
          e2._dispatchFlag = true;
          var d2 = t2;
          if (r2) {
            var m2 = t2._associatedDocument;
            u.Guard.isDocumentNode(m2) && (d2 = m2);
          }
          var y2 = null, v2 = p.tree_retarget(e2._relatedTarget, t2);
          if (t2 !== v2 || t2 === e2._relatedTarget) {
            var b2 = [];
            try {
              for (var x2 = n(e2._touchTargetList), w2 = x2.next(); !w2.done; w2 = x2.next()) {
                var E2 = w2.value;
                b2.push(p.tree_retarget(E2, t2));
              }
            } catch (e3) {
              o2 = { error: e3 };
            } finally {
              try {
                w2 && !w2.done && (a2 = x2.return) && a2.call(x2);
              } finally {
                if (o2)
                  throw o2.error;
              }
            }
            _(e2, t2, d2, v2, b2, false);
            var D2 = u.Guard.isMouseEvent(e2) && "click" === e2._type;
            D2 && void 0 !== t2._activationBehavior && (y2 = t2);
            for (var S = u.Guard.isSlotable(t2) && f.shadowTree_isAssigned(t2) ? t2 : null, C = false, A = t2._getTheParent(e2); null !== A && u.Guard.isNode(A); ) {
              if (null !== S) {
                if (!u.Guard.isSlot(A))
                  throw new Error("Parent node of a slotable should be a slot.");
                S = null;
                var N = p.tree_rootNode(A, true);
                u.Guard.isShadowRoot(N) && "closed" === N._mode && (C = true);
              }
              u.Guard.isSlotable(A) && f.shadowTree_isAssigned(A) && (S = A), v2 = p.tree_retarget(e2._relatedTarget, A), b2 = [];
              try {
                for (var T = (l2 = void 0, n(e2._touchTargetList)), O = T.next(); !O.done; O = T.next()) {
                  E2 = O.value;
                  b2.push(p.tree_retarget(E2, A));
                }
              } catch (e3) {
                l2 = { error: e3 };
              } finally {
                try {
                  O && !O.done && (c2 = T.return) && c2.call(T);
                } finally {
                  if (l2)
                    throw l2.error;
                }
              }
              u.Guard.isWindow(A) || u.Guard.isNode(A) && u.Guard.isNode(t2) && p.tree_isAncestorOf(p.tree_rootNode(t2, true), A, true, true) ? (D2 && e2._bubbles && null === y2 && A._activationBehavior && (y2 = A), _(e2, A, null, v2, b2, C)) : A === v2 ? A = null : (t2 = A, D2 && null === y2 && t2._activationBehavior && (y2 = t2), _(e2, A, t2, v2, b2, C)), null !== A && (A = A._getTheParent(e2)), C = false;
            }
            for (var F = null, k = e2._path, P = k.length - 1; P >= 0; P--) {
              if (null !== (L = k[P]).shadowAdjustedTarget) {
                F = L;
                break;
              }
            }
            if (null !== F)
              if (u.Guard.isNode(F.shadowAdjustedTarget) && u.Guard.isShadowRoot(p.tree_rootNode(F.shadowAdjustedTarget, true)))
                h2 = true;
              else if (u.Guard.isNode(F.relatedTarget) && u.Guard.isShadowRoot(p.tree_rootNode(F.relatedTarget, true)))
                h2 = true;
              else
                for (var I = 0; I < F.touchTargetList.length; I++) {
                  var L = F.touchTargetList[I];
                  if (u.Guard.isNode(L) && u.Guard.isShadowRoot(p.tree_rootNode(L, true))) {
                    h2 = true;
                    break;
                  }
                }
            null !== y2 && void 0 !== y2._legacyPreActivationBehavior && y2._legacyPreActivationBehavior(e2);
            for (P = k.length - 1; P >= 0; P--) {
              null !== (L = k[P]).shadowAdjustedTarget ? e2._eventPhase = s.EventPhase.AtTarget : e2._eventPhase = s.EventPhase.Capturing, g(L, e2, "capturing", i2);
            }
            for (P = 0; P < k.length; P++) {
              if (null !== (L = k[P]).shadowAdjustedTarget)
                e2._eventPhase = s.EventPhase.AtTarget;
              else {
                if (!e2._bubbles)
                  continue;
                e2._eventPhase = s.EventPhase.Bubbling;
              }
              g(L, e2, "bubbling", i2);
            }
          }
          return e2._eventPhase = s.EventPhase.None, e2._currentTarget = null, e2._path = [], e2._dispatchFlag = false, e2._stopPropagationFlag = false, e2._stopImmediatePropagationFlag = false, h2 && (e2._target = null, e2._relatedTarget = null, e2._touchTargetList = []), null !== y2 && (e2._canceledFlag || void 0 === y2._activationBehavior ? void 0 !== y2._legacyCanceledActivationBehavior && y2._legacyCanceledActivationBehavior(e2) : y2._activationBehavior(e2)), !e2._canceledFlag;
        }
        function _(e2, t2, r2, n2, i2, o2) {
          var a2 = false;
          u.Guard.isNode(t2) && u.Guard.isShadowRoot(p.tree_rootNode(t2)) && (a2 = true);
          var s2 = false;
          u.Guard.isShadowRoot(t2) && "closed" === t2._mode && (s2 = true), e2._path.push({ invocationTarget: t2, invocationTargetInShadowTree: a2, shadowAdjustedTarget: r2, relatedTarget: n2, touchTargetList: i2, rootOfClosedTree: s2, slotInClosedTree: o2 });
        }
        function g(e2, t2, r2, n2) {
          void 0 === n2 && (n2 = { value: false });
          for (var i2 = t2._path, a2 = -1, s2 = 0; s2 < i2.length; s2++)
            if (i2[s2] === e2) {
              a2 = s2;
              break;
            }
          if (-1 !== a2) {
            var u2 = i2[a2];
            (null !== u2.shadowAdjustedTarget || a2 > 0 && null !== (u2 = i2[a2 - 1]).shadowAdjustedTarget) && (t2._target = u2.shadowAdjustedTarget);
          }
          if (t2._relatedTarget = e2.relatedTarget, t2._touchTargetList = e2.touchTargetList, !t2._stopPropagationFlag) {
            t2._currentTarget = e2.invocationTarget;
            var l2 = t2._currentTarget._eventListenerList, c2 = new (Array.bind.apply(Array, o([void 0], l2)))();
            if (!b(t2, c2, r2, e2, n2) && t2._isTrusted) {
              var h2 = t2._type;
              "animationend" === h2 ? t2._type = "webkitAnimationEnd" : "animationiteration" === h2 ? t2._type = "webkitAnimationIteration" : "animationstart" === h2 ? t2._type = "webkitAnimationStart" : "transitionend" === h2 && (t2._type = "webkitTransitionEnd"), b(t2, c2, r2, e2, n2), t2._type = h2;
            }
          }
        }
        function b(e2, t2, r2, n2, i2) {
          void 0 === i2 && (i2 = { value: false });
          for (var o2 = false, a2 = 0; a2 < t2.length; a2++) {
            var s2 = t2[a2];
            if (!s2.removed) {
              if (e2._type !== s2.type)
                continue;
              if (o2 = true, "capturing" === r2 && !s2.capture)
                continue;
              if ("bubbling" === r2 && s2.capture)
                continue;
              if (s2.once && null !== e2._currentTarget) {
                for (var l2 = e2._currentTarget, c2 = -1, h2 = 0; h2 < l2._eventListenerList.length; h2++)
                  if (l2._eventListenerList[h2] === s2) {
                    c2 = h2;
                    break;
                  }
                -1 !== c2 && l2._eventListenerList.splice(c2, 1);
              }
              var p2 = void 0, f2 = void 0;
              u.Guard.isWindow(p2) && (f2 = p2._currentEvent, false === n2.invocationTargetInShadowTree && (p2._currentEvent = e2)), s2.passive && (e2._inPassiveListenerFlag = true);
              try {
                s2.callback.handleEvent.call(e2._currentTarget, e2);
              } catch (e3) {
                i2.value = true;
              }
              if (s2.passive && (e2._inPassiveListenerFlag = false), u.Guard.isWindow(p2) && (p2._currentEvent = f2), e2._stopImmediatePropagationFlag)
                return o2;
            }
          }
          return o2;
        }
        function x(e2, t2) {
          return null;
        }
        function w(e2, t2) {
          return null;
        }
        function E(e2, t2) {
        }
        function D(e2, t2) {
        }
        t.event_setTheCanceledFlag = function(e2) {
          e2._cancelable && !e2._inPassiveListenerFlag && (e2._canceledFlag = true);
        }, t.event_initialize = function(e2, t2, r2, n2) {
          e2._initializedFlag = true, e2._stopPropagationFlag = false, e2._stopImmediatePropagationFlag = false, e2._canceledFlag = false, e2._isTrusted = false, e2._target = null, e2._type = t2, e2._bubbles = r2, e2._cancelable = n2;
        }, t.event_createAnEvent = m, t.event_innerEventCreationSteps = y, t.event_dispatch = v, t.event_appendToAnEventPath = _, t.event_invoke = g, t.event_innerInvoke = b, t.event_fireAnEvent = function(e2, t2, r2, n2, i2) {
          void 0 === r2 && (r2 = c.EventImpl);
          var o2 = m(r2);
          if (o2._type = e2, n2)
            for (var a2 in n2) {
              o2[a2] = n2[a2];
            }
          return v(o2, t2, i2);
        }, t.event_createLegacyEvent = function(e2) {
          var t2 = null;
          switch (e2.toLowerCase()) {
            case "beforeunloadevent":
            case "compositionevent":
              break;
            case "customevent":
              t2 = l.CustomEventImpl;
              break;
            case "devicemotionevent":
            case "deviceorientationevent":
            case "dragevent":
              break;
            case "event":
            case "events":
              t2 = c.EventImpl;
          }
          if (null === t2)
            throw new h.NotSupportedError("Event constructor not found for interface " + e2 + ".");
          var r2 = new t2("");
          return r2._type = "", r2._timeStamp = (/* @__PURE__ */ new Date()).getTime(), r2._isTrusted = false, r2._initializedFlag = false, r2;
        }, t.event_getterEventHandlerIDLAttribute = function(e2, t2) {
          return null;
        }, t.event_setterEventHandlerIDLAttribute = function(e2, t2, r2) {
        }, t.event_determineTheTargetOfAnEventHandler = x, t.event_getTheCurrentValueOfAnEventHandler = w, t.event_activateAnEventHandler = E, t.event_deactivateAnEventHandler = D;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, a = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(6), u = r(1), l = r(9), c = r(34), h = r(3), p = r(2), f = r(7), d = r(152), m = r(0), y = r(12), v = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._children = /* @__PURE__ */ new Set(), t3._encoding = { name: "UTF-8", labels: ["unicode-1-1-utf-8", "utf-8", "utf8"] }, t3._contentType = "application/xml", t3._URL = { scheme: "about", username: "", password: "", host: null, port: null, path: ["blank"], query: null, fragment: null, _cannotBeABaseURLFlag: true, _blobURLEntry: null }, t3._origin = null, t3._type = "xml", t3._mode = "no-quirks", t3._documentElement = null, t3._hasNamespaces = false, t3._nodeDocumentOverwrite = null, t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "_nodeDocument", { get: function() {
            return this._nodeDocumentOverwrite || this;
          }, set: function(e3) {
            this._nodeDocumentOverwrite = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "implementation", { get: function() {
            return this._implementation || (this._implementation = m.create_domImplementation(this));
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "URL", { get: function() {
            return d.urlSerializer(this._URL);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "documentURI", { get: function() {
            return this.URL;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "origin", { get: function() {
            return "null";
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "compatMode", { get: function() {
            return "quirks" === this._mode ? "BackCompat" : "CSS1Compat";
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "characterSet", { get: function() {
            return this._encoding.name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "charset", { get: function() {
            return this._encoding.name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "inputEncoding", { get: function() {
            return this._encoding.name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "contentType", { get: function() {
            return this._contentType;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "doctype", { get: function() {
            var e3, t3;
            try {
              for (var r2 = o(this._children), n2 = r2.next(); !n2.done; n2 = r2.next()) {
                var i2 = n2.value;
                if (h.Guard.isDocumentTypeNode(i2))
                  return i2;
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                n2 && !n2.done && (t3 = r2.return) && t3.call(r2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "documentElement", { get: function() {
            return this._documentElement;
          }, enumerable: true, configurable: true }), t2.prototype.getElementsByTagName = function(e3) {
            return m.node_listOfElementsWithQualifiedName(e3, this);
          }, t2.prototype.getElementsByTagNameNS = function(e3, t3) {
            return m.node_listOfElementsWithNamespace(e3, t3, this);
          }, t2.prototype.getElementsByClassName = function(e3) {
            return m.node_listOfElementsWithClassNames(e3, this);
          }, t2.prototype.createElement = function(e3, t3) {
            if (!m.xml_isName(e3))
              throw new l.InvalidCharacterError();
            "html" === this._type && (e3 = e3.toLowerCase());
            var r2 = null;
            void 0 !== t3 && (r2 = p.isString(t3) ? t3 : t3.is);
            var n2 = "html" === this._type || "application/xhtml+xml" === this._contentType ? f.namespace.HTML : null;
            return m.element_createAnElement(this, e3, n2, null, r2, true);
          }, t2.prototype.createElementNS = function(e3, t3, r2) {
            return m.document_internalCreateElementNS(this, e3, t3, r2);
          }, t2.prototype.createDocumentFragment = function() {
            return m.create_documentFragment(this);
          }, t2.prototype.createTextNode = function(e3) {
            return m.create_text(this, e3);
          }, t2.prototype.createCDATASection = function(e3) {
            if ("html" === this._type)
              throw new l.NotSupportedError();
            if (-1 !== e3.indexOf("]]>"))
              throw new l.InvalidCharacterError();
            return m.create_cdataSection(this, e3);
          }, t2.prototype.createComment = function(e3) {
            return m.create_comment(this, e3);
          }, t2.prototype.createProcessingInstruction = function(e3, t3) {
            if (!m.xml_isName(e3))
              throw new l.InvalidCharacterError();
            if (-1 !== t3.indexOf("?>"))
              throw new l.InvalidCharacterError();
            return m.create_processingInstruction(this, e3, t3);
          }, t2.prototype.importNode = function(e3, t3) {
            if (void 0 === t3 && (t3 = false), h.Guard.isDocumentNode(e3) || h.Guard.isShadowRoot(e3))
              throw new l.NotSupportedError();
            return m.node_clone(e3, this, t3);
          }, t2.prototype.adoptNode = function(e3) {
            if (h.Guard.isDocumentNode(e3))
              throw new l.NotSupportedError();
            if (h.Guard.isShadowRoot(e3))
              throw new l.HierarchyRequestError();
            return m.document_adopt(e3, this), e3;
          }, t2.prototype.createAttribute = function(e3) {
            if (!m.xml_isName(e3))
              throw new l.InvalidCharacterError();
            return "html" === this._type && (e3 = e3.toLowerCase()), m.create_attr(this, e3);
          }, t2.prototype.createAttributeNS = function(e3, t3) {
            var r2 = a(m.namespace_validateAndExtract(e3, t3), 3), n2 = r2[0], i2 = r2[1], o2 = r2[2], s2 = m.create_attr(this, o2);
            return s2._namespace = n2, s2._namespacePrefix = i2, s2;
          }, t2.prototype.createEvent = function(e3) {
            return m.event_createLegacyEvent(e3);
          }, t2.prototype.createRange = function() {
            var e3 = m.create_range();
            return e3._start = [this, 0], e3._end = [this, 0], e3;
          }, t2.prototype.createNodeIterator = function(e3, t3, r2) {
            void 0 === t3 && (t3 = u.WhatToShow.All), void 0 === r2 && (r2 = null);
            var n2 = m.create_nodeIterator(e3, e3, true);
            return n2._whatToShow = t3, n2._iteratorCollection = m.create_nodeList(e3), p.isFunction(r2) ? (n2._filter = m.create_nodeFilter(), n2._filter.acceptNode = r2) : n2._filter = r2, n2;
          }, t2.prototype.createTreeWalker = function(e3, t3, r2) {
            void 0 === t3 && (t3 = u.WhatToShow.All), void 0 === r2 && (r2 = null);
            var n2 = m.create_treeWalker(e3, e3);
            return n2._whatToShow = t3, p.isFunction(r2) ? (n2._filter = m.create_nodeFilter(), n2._filter.acceptNode = r2) : n2._filter = r2, n2;
          }, t2.prototype._getTheParent = function(e3) {
            return "load" === e3._type ? null : s.dom.window;
          }, t2.prototype.getElementById = function(e3) {
            throw new Error("Mixin: NonElementParentNode not implemented.");
          }, Object.defineProperty(t2.prototype, "children", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "childElementCount", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.prepend = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.append = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelector = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelectorAll = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2;
        }(c.NodeImpl);
        t.DocumentImpl = v, y.idl_defineConst(v.prototype, "_nodeType", u.NodeType.Document);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, a = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(1), u = r(34), l = r(9), c = r(7), h = r(0), p = r(12), f = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._children = /* @__PURE__ */ new Set(), t3._namespace = null, t3._namespacePrefix = null, t3._localName = "", t3._customElementState = "undefined", t3._customElementDefinition = null, t3._is = null, t3._shadowRoot = null, t3._attributeList = h.create_namedNodeMap(t3), t3._attributeChangeSteps = [], t3._name = "", t3._assignedSlot = null, t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "namespaceURI", { get: function() {
            return this._namespace;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "prefix", { get: function() {
            return this._namespacePrefix;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "localName", { get: function() {
            return this._localName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "tagName", { get: function() {
            return this._htmlUppercasedQualifiedName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "id", { get: function() {
            return h.element_getAnAttributeValue(this, "id");
          }, set: function(e3) {
            h.element_setAnAttributeValue(this, "id", e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "className", { get: function() {
            return h.element_getAnAttributeValue(this, "class");
          }, set: function(e3) {
            h.element_setAnAttributeValue(this, "class", e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "classList", { get: function() {
            var e3 = h.element_getAnAttributeByName("class", this);
            return null === e3 && (e3 = h.create_attr(this._nodeDocument, "class")), h.create_domTokenList(this, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "slot", { get: function() {
            return h.element_getAnAttributeValue(this, "slot");
          }, set: function(e3) {
            h.element_setAnAttributeValue(this, "slot", e3);
          }, enumerable: true, configurable: true }), t2.prototype.hasAttributes = function() {
            return 0 !== this._attributeList.length;
          }, Object.defineProperty(t2.prototype, "attributes", { get: function() {
            return this._attributeList;
          }, enumerable: true, configurable: true }), t2.prototype.getAttributeNames = function() {
            var e3, t3, r2 = [];
            try {
              for (var n2 = o(this._attributeList), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                var a2 = i2.value;
                r2.push(a2._qualifiedName);
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                i2 && !i2.done && (t3 = n2.return) && t3.call(n2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            return r2;
          }, t2.prototype.getAttribute = function(e3) {
            var t3 = h.element_getAnAttributeByName(e3, this);
            return t3 ? t3._value : null;
          }, t2.prototype.getAttributeNS = function(e3, t3) {
            var r2 = h.element_getAnAttributeByNamespaceAndLocalName(e3, t3, this);
            return r2 ? r2._value : null;
          }, t2.prototype.setAttribute = function(e3, t3) {
            if (!h.xml_isName(e3))
              throw new l.InvalidCharacterError();
            this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toLowerCase());
            for (var r2 = null, n2 = 0; n2 < this._attributeList.length; n2++) {
              var i2 = this._attributeList[n2];
              if (i2._qualifiedName === e3) {
                r2 = i2;
                break;
              }
            }
            if (null === r2)
              return (r2 = h.create_attr(this._nodeDocument, e3))._value = t3, void h.element_append(r2, this);
            h.element_change(r2, this, t3);
          }, t2.prototype.setAttributeNS = function(e3, t3, r2) {
            var n2 = a(h.namespace_validateAndExtract(e3, t3), 3), i2 = n2[0], o2 = n2[1], s2 = n2[2];
            h.element_setAnAttributeValue(this, s2, r2, o2, i2);
          }, t2.prototype.removeAttribute = function(e3) {
            h.element_removeAnAttributeByName(e3, this);
          }, t2.prototype.removeAttributeNS = function(e3, t3) {
            h.element_removeAnAttributeByNamespaceAndLocalName(e3, t3, this);
          }, t2.prototype.hasAttribute = function(e3) {
            this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toLowerCase());
            for (var t3 = 0; t3 < this._attributeList.length; t3++) {
              if (this._attributeList[t3]._qualifiedName === e3)
                return true;
            }
            return false;
          }, t2.prototype.toggleAttribute = function(e3, t3) {
            if (!h.xml_isName(e3))
              throw new l.InvalidCharacterError();
            this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toLowerCase());
            for (var r2 = null, n2 = 0; n2 < this._attributeList.length; n2++) {
              var i2 = this._attributeList[n2];
              if (i2._qualifiedName === e3) {
                r2 = i2;
                break;
              }
            }
            return null === r2 ? (void 0 === t3 || true === t3) && ((r2 = h.create_attr(this._nodeDocument, e3))._value = "", h.element_append(r2, this), true) : void 0 !== t3 && false !== t3 || (h.element_removeAnAttributeByName(e3, this), false);
          }, t2.prototype.hasAttributeNS = function(e3, t3) {
            for (var r2 = e3 || null, n2 = 0; n2 < this._attributeList.length; n2++) {
              var i2 = this._attributeList[n2];
              if (i2._namespace === r2 && i2._localName === t3)
                return true;
            }
            return false;
          }, t2.prototype.getAttributeNode = function(e3) {
            return h.element_getAnAttributeByName(e3, this);
          }, t2.prototype.getAttributeNodeNS = function(e3, t3) {
            return h.element_getAnAttributeByNamespaceAndLocalName(e3, t3, this);
          }, t2.prototype.setAttributeNode = function(e3) {
            return h.element_setAnAttribute(e3, this);
          }, t2.prototype.setAttributeNodeNS = function(e3) {
            return h.element_setAnAttribute(e3, this);
          }, t2.prototype.removeAttributeNode = function(e3) {
            for (var t3 = false, r2 = 0; r2 < this._attributeList.length; r2++) {
              if (this._attributeList[r2] === e3) {
                t3 = true;
                break;
              }
            }
            if (!t3)
              throw new l.NotFoundError();
            return h.element_remove(e3, this), e3;
          }, t2.prototype.attachShadow = function(e3) {
            if (this._namespace !== c.namespace.HTML)
              throw new l.NotSupportedError();
            if (!h.customElement_isValidCustomElementName(this._localName) && !h.customElement_isValidShadowHostName(this._localName))
              throw new l.NotSupportedError();
            if (h.customElement_isValidCustomElementName(this._localName) || null !== this._is) {
              var t3 = h.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);
              if (null !== t3 && true === t3.disableShadow)
                throw new l.NotSupportedError();
            }
            if (null !== this._shadowRoot)
              throw new l.NotSupportedError();
            var r2 = h.create_shadowRoot(this._nodeDocument, this);
            return r2._mode = e3.mode, this._shadowRoot = r2, r2;
          }, Object.defineProperty(t2.prototype, "shadowRoot", { get: function() {
            var e3 = this._shadowRoot;
            return null === e3 || "closed" === e3.mode ? null : e3;
          }, enumerable: true, configurable: true }), t2.prototype.closest = function(e3) {
            throw new l.NotImplementedError();
          }, t2.prototype.matches = function(e3) {
            throw new l.NotImplementedError();
          }, t2.prototype.webkitMatchesSelector = function(e3) {
            return this.matches(e3);
          }, t2.prototype.getElementsByTagName = function(e3) {
            return h.node_listOfElementsWithQualifiedName(e3, this);
          }, t2.prototype.getElementsByTagNameNS = function(e3, t3) {
            return h.node_listOfElementsWithNamespace(e3, t3, this);
          }, t2.prototype.getElementsByClassName = function(e3) {
            return h.node_listOfElementsWithClassNames(e3, this);
          }, t2.prototype.insertAdjacentElement = function(e3, t3) {
            return h.element_insertAdjacent(this, e3, t3);
          }, t2.prototype.insertAdjacentText = function(e3, t3) {
            var r2 = h.create_text(this._nodeDocument, t3);
            h.element_insertAdjacent(this, e3, r2);
          }, Object.defineProperty(t2.prototype, "_qualifiedName", { get: function() {
            return this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_htmlUppercasedQualifiedName", { get: function() {
            var e3 = this._qualifiedName;
            return this._namespace === c.namespace.HTML && "html" === this._nodeDocument._type && (e3 = e3.toUpperCase()), e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "children", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "childElementCount", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.prepend = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.append = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelector = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelectorAll = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, Object.defineProperty(t2.prototype, "previousElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "nextElementSibling", { get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.before = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.after = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.replaceWith = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.remove = function() {
            throw new Error("Mixin: ChildNode not implemented.");
          }, Object.defineProperty(t2.prototype, "assignedSlot", { get: function() {
            throw new Error("Mixin: Slotable not implemented.");
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2, n2, i2) {
            void 0 === n2 && (n2 = null), void 0 === i2 && (i2 = null);
            var o2 = new t2();
            return o2._localName = r2, o2._namespace = n2, o2._namespacePrefix = i2, o2._nodeDocument = e3, o2;
          }, t2;
        }(u.NodeImpl);
        t.ElementImpl = f, p.idl_defineConst(f.prototype, "_nodeType", s.NodeType.Element);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(34), s = r(12), u = function(e2) {
          function t2(t3) {
            void 0 === t3 && (t3 = null);
            var r2 = e2.call(this) || this;
            return r2._children = /* @__PURE__ */ new Set(), r2._host = t3, r2;
          }
          return i(t2, e2), t2.prototype.getElementById = function(e3) {
            throw new Error("Mixin: NonElementParentNode not implemented.");
          }, Object.defineProperty(t2.prototype, "children", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "firstElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "lastElementChild", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "childElementCount", { get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
          }, enumerable: true, configurable: true }), t2.prototype.prepend = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.append = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelector = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2.prototype.querySelectorAll = function(e3) {
            throw new Error("Mixin: ParentNode not implemented.");
          }, t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = null);
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(a.NodeImpl);
        t.DocumentFragmentImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.DocumentFragment);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(1), s = r(71), u = r(0), l = r(12), c = function(e2) {
          function t2(t3) {
            void 0 === t3 && (t3 = "");
            var r2 = e2.call(this, t3) || this;
            return r2._name = "", r2._assignedSlot = null, r2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "wholeText", { get: function() {
            var e3, t3, r2 = "";
            try {
              for (var n2 = o(u.text_contiguousTextNodes(this, true)), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                r2 += i2.value._data;
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                i2 && !i2.done && (t3 = n2.return) && t3.call(n2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            return r2;
          }, enumerable: true, configurable: true }), t2.prototype.splitText = function(e3) {
            return u.text_split(this, e3);
          }, Object.defineProperty(t2.prototype, "assignedSlot", { get: function() {
            throw new Error("Mixin: Slotable not implemented.");
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(s.CharacterDataImpl);
        t.TextImpl = c, l.idl_defineConst(c.prototype, "_nodeType", a.NodeType.Text);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "_startNode", { get: function() {
            return this._start[0];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_startOffset", { get: function() {
            return this._start[1];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_endNode", { get: function() {
            return this._end[0];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_endOffset", { get: function() {
            return this._end[1];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_collapsed", { get: function() {
            return this._start[0] === this._end[0] && this._start[1] === this._end[1];
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "startContainer", { get: function() {
            return this._startNode;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "startOffset", { get: function() {
            return this._startOffset;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "endContainer", { get: function() {
            return this._endNode;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "endOffset", { get: function() {
            return this._endOffset;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "collapsed", { get: function() {
            return this._collapsed;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.AbstractRangeImpl = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = function() {
          function e2(e3) {
            this._activeFlag = false, this._root = e3, this._whatToShow = n.WhatToShow.All, this._filter = null;
          }
          return Object.defineProperty(e2.prototype, "root", { get: function() {
            return this._root;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "whatToShow", { get: function() {
            return this._whatToShow;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "filter", { get: function() {
            return this._filter;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.TraverserImpl = i;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = r(0), o = r(12), a = function() {
          function e2(e3, t2) {
            this._target = null, this._relatedTarget = null, this._touchTargetList = [], this._path = [], this._currentTarget = null, this._eventPhase = n.EventPhase.None, this._stopPropagationFlag = false, this._stopImmediatePropagationFlag = false, this._canceledFlag = false, this._inPassiveListenerFlag = false, this._composedFlag = false, this._initializedFlag = false, this._dispatchFlag = false, this._isTrusted = false, this._bubbles = false, this._cancelable = false, this._type = e3, t2 && (this._bubbles = t2.bubbles || false, this._cancelable = t2.cancelable || false, this._composedFlag = t2.composed || false), this._initializedFlag = true, this._timeStamp = (/* @__PURE__ */ new Date()).getTime();
          }
          return Object.defineProperty(e2.prototype, "type", { get: function() {
            return this._type;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "target", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "srcElement", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "currentTarget", { get: function() {
            return this._currentTarget;
          }, enumerable: true, configurable: true }), e2.prototype.composedPath = function() {
            var e3 = [], t2 = this._path;
            if (0 === t2.length)
              return e3;
            var r2 = this._currentTarget;
            if (null === r2)
              throw new Error("Event currentTarget is null.");
            e3.push(r2);
            for (var n2 = 0, i2 = 0, o2 = t2.length - 1; o2 >= 0; ) {
              if (t2[o2].rootOfClosedTree && i2++, t2[o2].invocationTarget === r2) {
                n2 = o2;
                break;
              }
              t2[o2].slotInClosedTree && i2--, o2--;
            }
            var a2 = i2, s = i2;
            for (o2 = n2 - 1; o2 >= 0; )
              t2[o2].rootOfClosedTree && a2++, a2 <= s && e3.unshift(t2[o2].invocationTarget), t2[o2].slotInClosedTree && --a2 < s && (s = a2), o2--;
            for (a2 = i2, s = i2, o2 = n2 + 1; o2 < t2.length; )
              t2[o2].slotInClosedTree && a2++, a2 <= s && e3.push(t2[o2].invocationTarget), t2[o2].rootOfClosedTree && --a2 < s && (s = a2), o2++;
            return e3;
          }, Object.defineProperty(e2.prototype, "eventPhase", { get: function() {
            return this._eventPhase;
          }, enumerable: true, configurable: true }), e2.prototype.stopPropagation = function() {
            this._stopPropagationFlag = true;
          }, Object.defineProperty(e2.prototype, "cancelBubble", { get: function() {
            return this._stopPropagationFlag;
          }, set: function(e3) {
            e3 && this.stopPropagation();
          }, enumerable: true, configurable: true }), e2.prototype.stopImmediatePropagation = function() {
            this._stopPropagationFlag = true, this._stopImmediatePropagationFlag = true;
          }, Object.defineProperty(e2.prototype, "bubbles", { get: function() {
            return this._bubbles;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "cancelable", { get: function() {
            return this._cancelable;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "returnValue", { get: function() {
            return !this._canceledFlag;
          }, set: function(e3) {
            e3 || i.event_setTheCanceledFlag(this);
          }, enumerable: true, configurable: true }), e2.prototype.preventDefault = function() {
            i.event_setTheCanceledFlag(this);
          }, Object.defineProperty(e2.prototype, "defaultPrevented", { get: function() {
            return this._canceledFlag;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "composed", { get: function() {
            return this._composedFlag;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "isTrusted", { get: function() {
            return this._isTrusted;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "timeStamp", { get: function() {
            return this._timeStamp;
          }, enumerable: true, configurable: true }), e2.prototype.initEvent = function(e3, t2, r2) {
            void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false), this._dispatchFlag || i.event_initialize(this, e3, t2, r2);
          }, e2.NONE = 0, e2.CAPTURING_PHASE = 1, e2.AT_TARGET = 2, e2.BUBBLING_PHASE = 3, e2;
        }();
        t.EventImpl = a, o.idl_defineConst(a.prototype, "NONE", 0), o.idl_defineConst(a.prototype, "CAPTURING_PHASE", 1), o.idl_defineConst(a.prototype, "AT_TARGET", 2), o.idl_defineConst(a.prototype, "BUBBLING_PHASE", 3);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = r(9);
        t.traversal_filter = function(e2, t2) {
          if (e2._activeFlag)
            throw new i.InvalidStateError();
          var r2 = 1 << t2._nodeType - 1;
          if (0 == (e2.whatToShow & r2))
            return n.FilterResult.Skip;
          if (!e2.filter)
            return n.FilterResult.Accept;
          e2._activeFlag = true;
          var o = n.FilterResult.Reject;
          try {
            o = e2.filter.acceptNode(t2);
          } catch (t3) {
            throw e2._activeFlag = false, t3;
          }
          return e2._activeFlag = false, o;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(6), a = r(3), s = r(2), u = r(99), l = r(73), c = r(17), h = r(173), p = r(30), f = r(52), d = r(37);
        t.document_elementInterface = function(e2, t2) {
          return u.ElementImpl;
        }, t.document_internalCreateElementNS = function(e2, t2, r2, i2) {
          var o2 = n(h.namespace_validateAndExtract(t2, r2), 3), a2 = o2[0], u2 = o2[1], l2 = o2[2], c2 = null;
          return void 0 !== i2 && (c2 = s.isString(i2) ? i2 : i2.is), f.element_createAnElement(e2, l2, a2, u2, c2, true);
        }, t.document_adopt = function(e2, t2) {
          var r2, n2;
          if (e2._nodeDocument !== t2 || null !== e2._parent) {
            var s2 = e2._nodeDocument;
            if (e2._parent && d.mutation_remove(e2, e2._parent), t2 !== s2)
              for (var u2 = c.tree_getFirstDescendantNode(e2, true, true); null !== u2; ) {
                if (u2._nodeDocument = t2, a.Guard.isElementNode(u2))
                  try {
                    for (var h2 = (r2 = void 0, i(u2._attributeList._asArray())), f2 = h2.next(); !f2.done; f2 = h2.next()) {
                      f2.value._nodeDocument = t2;
                    }
                  } catch (e3) {
                    r2 = { error: e3 };
                  } finally {
                    try {
                      f2 && !f2.done && (n2 = h2.return) && n2.call(h2);
                    } finally {
                      if (r2)
                        throw r2.error;
                    }
                  }
                o.dom.features.customElements && a.Guard.isElementNode(u2) && "custom" === u2._customElementState && l.customElement_enqueueACustomElementCallbackReaction(u2, "adoptedCallback", [s2, t2]), o.dom.features.steps && p.dom_runAdoptingSteps(u2, s2), u2 = c.tree_getNextDescendantNode(e2, u2, true, true);
              }
          }
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(9), s = r(17), u = r(51), l = r(30);
        t.characterData_replaceData = function(e2, t2, r2, c) {
          var h, p, f = s.tree_nodeLength(e2);
          if (t2 > f)
            throw new a.IndexSizeError("Offset exceeds character data length. Offset: " + t2 + ", Length: " + f + ", Node is " + e2.nodeName + ".");
          t2 + r2 > f && (r2 = f - t2), i.dom.features.mutationObservers && u.observer_queueMutationRecord("characterData", e2, null, null, e2._data, [], [], null, null);
          var d = e2._data.substring(0, t2) + c + e2._data.substring(t2 + r2);
          e2._data = d;
          try {
            for (var m = n(i.dom.rangeList), y = m.next(); !y.done; y = m.next()) {
              var v = y.value;
              v._start[0] === e2 && v._start[1] > t2 && v._start[1] <= t2 + r2 && (v._start[1] = t2), v._end[0] === e2 && v._end[1] > t2 && v._end[1] <= t2 + r2 && (v._end[1] = t2), v._start[0] === e2 && v._start[1] > t2 + r2 && (v._start[1] += c.length - r2), v._end[0] === e2 && v._end[1] > t2 + r2 && (v._end[1] += c.length - r2);
            }
          } catch (e3) {
            h = { error: e3 };
          } finally {
            try {
              y && !y.done && (p = m.return) && p.call(m);
            } finally {
              if (h)
                throw h.error;
            }
          }
          i.dom.features.steps && o.Guard.isTextNode(e2) && null !== e2._parent && l.dom_runChildTextContentChangeSteps(e2._parent);
        }, t.characterData_substringData = function(e2, t2, r2) {
          var n2 = s.tree_nodeLength(e2);
          if (t2 > n2)
            throw new a.IndexSizeError("Offset exceeds character data length. Offset: " + t2 + ", Length: " + n2 + ", Node is " + e2.nodeName + ".");
          return t2 + r2 > n2 ? e2._data.substr(t2) : e2._data.substr(t2, r2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(n(arguments[t2]));
          return e2;
        }, o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(7);
        function s(e2) {
          var t2 = a.string.splitAStringOnASCIIWhitespace(e2);
          return new Set(t2);
        }
        function u(e2) {
          return i(e2).join(" ");
        }
        t.orderedSet_parse = s, t.orderedSet_serialize = u, t.orderedSet_sanitize = function(e2) {
          return u(s(e2));
        }, t.orderedSet_contains = function(e2, t2, r2) {
          var n2, i2, a2, s2;
          try {
            for (var u2 = o(t2), l = u2.next(); !l.done; l = u2.next()) {
              var c = l.value, h = false;
              try {
                for (var p = (a2 = void 0, o(e2)), f = p.next(); !f.done; f = p.next()) {
                  var d = f.value;
                  if (r2) {
                    if (d === c) {
                      h = true;
                      break;
                    }
                  } else if (d.toUpperCase() === c.toUpperCase()) {
                    h = true;
                    break;
                  }
                }
              } catch (e3) {
                a2 = { error: e3 };
              } finally {
                try {
                  f && !f.done && (s2 = p.return) && s2.call(p);
                } finally {
                  if (a2)
                    throw a2.error;
                }
              }
              if (!h)
                return false;
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (i2 = u2.return) && i2.call(u2);
            } finally {
              if (n2)
                throw n2.error;
            }
          }
          return true;
        };
      }, function(e, t, r) {
        "use strict";
        r(179), Object.defineProperty(t, "__esModule", { value: true });
        var n = r(263), i = r(110), o = r(2);
        i.dom.setFeatures(false), t.createDocument = function() {
          var e2 = new n.DOMImplementation().createDocument(null, "root", null);
          return e2.documentElement && e2.removeChild(e2.documentElement), e2;
        }, t.sanitizeInput = function(e2, t2) {
          if (null == e2)
            return e2;
          if (void 0 === t2)
            return e2 + "";
          var r2 = "";
          e2 += "";
          for (var n2 = 0; n2 < e2.length; n2++) {
            var i2 = e2.charCodeAt(n2);
            if (9 === i2 || 10 === i2 || 13 === i2 || i2 >= 32 && i2 <= 55295 || i2 >= 57344 && i2 <= 65533)
              r2 += e2.charAt(n2);
            else if (i2 >= 55296 && i2 <= 56319 && n2 < e2.length - 1) {
              var a = e2.charCodeAt(n2 + 1);
              a >= 56320 && a <= 57343 ? (i2 = 1024 * (i2 - 55296) + a - 56320 + 65536, r2 += String.fromCodePoint(i2), n2++) : r2 += o.isString(t2) ? t2 : t2(e2.charAt(n2), n2, e2);
            } else
              r2 += o.isString(t2) ? t2 : t2(e2.charAt(n2), n2, e2);
          }
          return r2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(2), i = r(153);
        t.AbortController = i.AbortControllerImpl;
        var o = r(154);
        t.AbortSignal = o.AbortSignalImpl;
        var a = r(102);
        t.AbstractRange = a.AbstractRangeImpl;
        var s = r(157);
        t.Attr = s.AttrImpl;
        var u = r(158);
        t.CDATASection = u.CDATASectionImpl;
        var l = r(71);
        t.CharacterData = l.CharacterDataImpl;
        var c = r(264), h = r(159);
        t.Comment = h.CommentImpl;
        var p = r(171);
        t.CustomEvent = p.CustomEventImpl;
        var f = r(100);
        t.DocumentFragment = f.DocumentFragmentImpl;
        var d = r(98);
        t.Document = d.DocumentImpl;
        var m = r(265), y = r(155);
        t.DocumentType = y.DocumentTypeImpl;
        var v = r(6);
        t.dom = v.dom;
        var _ = r(148);
        t.DOMImplementation = _.DOMImplementationImpl;
        var g = r(170);
        t.DOMTokenList = g.DOMTokenListImpl;
        var b = r(99);
        t.Element = b.ElementImpl;
        var x = r(104);
        t.Event = x.EventImpl;
        var w = r(70);
        t.EventTarget = w.EventTargetImpl;
        var E = r(161);
        t.HTMLCollection = E.HTMLCollectionImpl;
        var D = r(266);
        t.MutationObserver = D.MutationObserverImpl;
        var S = r(169);
        t.MutationRecord = S.MutationRecordImpl;
        var C = r(164);
        t.NamedNodeMap = C.NamedNodeMapImpl;
        var A = r(168);
        t.NodeFilter = A.NodeFilterImpl;
        var N = r(34);
        t.Node = N.NodeImpl;
        var T = r(166);
        t.NodeIterator = T.NodeIteratorImpl;
        var O = r(162);
        t.NodeList = O.NodeListImpl;
        var F = r(163);
        t.NodeListStatic = F.NodeListStaticImpl;
        var k = r(267), P = r(268), I = r(269), L = r(160);
        t.ProcessingInstruction = L.ProcessingInstructionImpl;
        var M = r(165);
        t.Range = M.RangeImpl;
        var B = r(156);
        t.ShadowRoot = B.ShadowRootImpl;
        var j = r(270), R = r(271);
        t.StaticRange = R.StaticRangeImpl;
        var z = r(101);
        t.Text = z.TextImpl;
        var U = r(103);
        t.Traverser = U.TraverserImpl;
        var G = r(167);
        t.TreeWalker = G.TreeWalkerImpl;
        var X = r(149);
        t.Window = X.WindowImpl;
        var q = r(151);
        t.XMLDocument = q.XMLDocumentImpl, n.applyMixin(b.ElementImpl, c.ChildNodeImpl), n.applyMixin(l.CharacterDataImpl, c.ChildNodeImpl), n.applyMixin(y.DocumentTypeImpl, c.ChildNodeImpl), n.applyMixin(d.DocumentImpl, m.DocumentOrShadowRootImpl), n.applyMixin(B.ShadowRootImpl, m.DocumentOrShadowRootImpl), n.applyMixin(b.ElementImpl, k.NonDocumentTypeChildNodeImpl), n.applyMixin(l.CharacterDataImpl, k.NonDocumentTypeChildNodeImpl), n.applyMixin(d.DocumentImpl, P.NonElementParentNodeImpl), n.applyMixin(f.DocumentFragmentImpl, P.NonElementParentNodeImpl), n.applyMixin(d.DocumentImpl, I.ParentNodeImpl), n.applyMixin(f.DocumentFragmentImpl, I.ParentNodeImpl), n.applyMixin(b.ElementImpl, I.ParentNodeImpl), n.applyMixin(z.TextImpl, j.SlotableImpl), n.applyMixin(b.ElementImpl, j.SlotableImpl);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), function(e2) {
          e2[e2.EOF = 0] = "EOF", e2[e2.Declaration = 1] = "Declaration", e2[e2.DocType = 2] = "DocType", e2[e2.Element = 3] = "Element", e2[e2.Text = 4] = "Text", e2[e2.CDATA = 5] = "CDATA", e2[e2.PI = 6] = "PI", e2[e2.Comment = 7] = "Comment", e2[e2.ClosingTag = 8] = "ClosingTag";
        }(t.TokenType || (t.TokenType = {}));
      }, function(e, t, r) {
        "use strict";
        r(64), r(20), r(66);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            var r2 = this, n2 = this._builderOptions, i2 = null;
            return o.isFunction(t3) ? i2 = this.parse(e3, t3.apply(this)) : o.isArray(t3) || o.isSet(t3) ? o.forEachArray(t3, function(t4) {
              return i2 = r2.parse(e3, t4);
            }, this) : o.isMap(t3) || o.isObject(t3) ? o.forEachObject(t3, function(t4, a2) {
              if (o.isFunction(a2) && (a2 = a2.apply(r2)), n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.att))
                if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.text))
                  if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.cdata))
                    if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.comment))
                      if (n2.ignoreConverters || 0 !== t4.indexOf(n2.convert.ins))
                        if ((o.isArray(a2) || o.isSet(a2)) && o.isEmpty(a2))
                          ;
                        else if ((o.isMap(a2) || o.isObject(a2)) && o.isEmpty(a2))
                          i2 = r2.element(e3, void 0, r2.sanitize(t4)) || i2;
                        else if (n2.keepNullNodes || null != a2)
                          if (o.isArray(a2) || o.isSet(a2))
                            o.forEachArray(a2, function(n3) {
                              var o2 = {};
                              o2[t4] = n3, i2 = r2.parse(e3, o2);
                            }, r2);
                          else if (o.isMap(a2) || o.isObject(a2)) {
                            (s = r2.element(e3, void 0, r2.sanitize(t4))) && (i2 = s, r2.parse(s, a2));
                          } else if (null != a2 && "" !== a2) {
                            var s;
                            (s = r2.element(e3, void 0, r2.sanitize(t4))) && (i2 = s, r2.text(s, r2._decodeText(r2.sanitize(a2))));
                          } else
                            i2 = r2.element(e3, void 0, r2.sanitize(t4)) || i2;
                        else
                          ;
                      else if (o.isString(a2)) {
                        var u = a2.indexOf(" "), l = -1 === u ? a2 : a2.substr(0, u), c = -1 === u ? "" : a2.substr(u + 1);
                        i2 = r2.instruction(e3, r2.sanitize(l), r2.sanitize(c)) || i2;
                      } else
                        o.isArray(a2) || o.isSet(a2) ? o.forEachArray(a2, function(t5) {
                          var n3 = t5.indexOf(" "), o2 = -1 === n3 ? t5 : t5.substr(0, n3), a3 = -1 === n3 ? "" : t5.substr(n3 + 1);
                          i2 = r2.instruction(e3, r2.sanitize(o2), r2.sanitize(a3)) || i2;
                        }, r2) : o.forEachObject(a2, function(t5, n3) {
                          return i2 = r2.instruction(e3, r2.sanitize(t5), r2.sanitize(n3)) || i2;
                        }, r2);
                    else
                      o.isArray(a2) || o.isSet(a2) ? o.forEachArray(a2, function(t5) {
                        return i2 = r2.comment(e3, r2.sanitize(t5)) || i2;
                      }, r2) : i2 = r2.comment(e3, r2.sanitize(a2)) || i2;
                  else
                    o.isArray(a2) || o.isSet(a2) ? o.forEachArray(a2, function(t5) {
                      return i2 = r2.cdata(e3, r2.sanitize(t5)) || i2;
                    }, r2) : i2 = r2.cdata(e3, r2.sanitize(a2)) || i2;
                else
                  i2 = o.isMap(a2) || o.isObject(a2) ? r2.parse(e3, a2) : r2.text(e3, r2._decodeText(r2.sanitize(a2))) || i2;
              else if (t4 === n2.convert.att) {
                if (o.isArray(a2) || o.isSet(a2))
                  throw new Error("Invalid attribute: " + a2.toString() + ". " + e3._debugInfo());
                o.forEachObject(a2, function(t5, n3) {
                  i2 = r2.attribute(e3, void 0, r2.sanitize(t5), r2._decodeAttributeValue(r2.sanitize(n3))) || i2;
                });
              } else
                i2 = r2.attribute(e3, void 0, r2.sanitize(t4.substr(n2.convert.att.length)), r2._decodeAttributeValue(r2.sanitize(a2))) || i2;
            }, this) : (n2.keepNullNodes || null != t3) && (i2 = this.text(e3, this._decodeText(this.sanitize(t3))) || i2), i2 || e3;
          }, t2;
        }(r(75).BaseReader);
        t.ObjectReader = a;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ explicit: [r(287), r(288), r(289)] });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function(e2) {
          this.level = 0, this._builderOptions = e2, this._writerOptions = e2;
        };
        t.BaseCBWriter = n;
      }, function(e, t, r) {
        var n = r(16), i = r(8), o = r(116);
        e.exports = !n && !i(function() {
          return 7 != Object.defineProperty(o("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e, t, r) {
        var n = r(11), i = r(13), o = n.document, a = i(o) && i(o.createElement);
        e.exports = function(e2) {
          return a ? o.createElement(e2) : {};
        };
      }, function(e, t, r) {
        var n = r(118), i = Function.toString;
        "function" != typeof n.inspectSource && (n.inspectSource = function(e2) {
          return i.call(e2);
        }), e.exports = n.inspectSource;
      }, function(e, t, r) {
        var n = r(11), i = r(80), o = n["__core-js_shared__"] || i("__core-js_shared__", {});
        e.exports = o;
      }, function(e, t, r) {
        var n = r(14), i = r(187), o = r(55), a = r(15);
        e.exports = function(e2, t2) {
          for (var r2 = i(t2), s = a.f, u = o.f, l = 0; l < r2.length; l++) {
            var c = r2[l];
            n(e2, c) || s(e2, c, u(t2, c));
          }
        };
      }, function(e, t, r) {
        var n = r(11);
        e.exports = n;
      }, function(e, t, r) {
        var n = r(14), i = r(24), o = r(122).indexOf, a = r(45);
        e.exports = function(e2, t2) {
          var r2, s = i(e2), u = 0, l = [];
          for (r2 in s)
            !n(a, r2) && n(s, r2) && l.push(r2);
          for (; t2.length > u; )
            n(s, r2 = t2[u++]) && (~o(l, r2) || l.push(r2));
          return l;
        };
      }, function(e, t, r) {
        var n = r(24), i = r(26), o = r(83), a = function(e2) {
          return function(t2, r2, a2) {
            var s, u = n(t2), l = i(u.length), c = o(a2, l);
            if (e2 && r2 != r2) {
              for (; l > c; )
                if ((s = u[c++]) != s)
                  return true;
            } else
              for (; l > c; c++)
                if ((e2 || c in u) && u[c] === r2)
                  return e2 || c || 0;
            return !e2 && -1;
          };
        };
        e.exports = { includes: a(true), indexOf: a(false) };
      }, function(e, t, r) {
        var n = r(8), i = /#|\.prototype\./, o = function(e2, t2) {
          var r2 = s[a(e2)];
          return r2 == l || r2 != u && ("function" == typeof t2 ? n(t2) : !!t2);
        }, a = o.normalize = function(e2) {
          return String(e2).replace(i, ".").toLowerCase();
        }, s = o.data = {}, u = o.NATIVE = "N", l = o.POLYFILL = "P";
        e.exports = o;
      }, function(e, t, r) {
        var n = r(86);
        e.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator;
      }, function(e, t, r) {
        var n = r(5);
        t.f = n;
      }, function(e, t, r) {
        var n = r(120), i = r(14), o = r(125), a = r(15).f;
        e.exports = function(e2) {
          var t2 = n.Symbol || (n.Symbol = {});
          i(t2, e2) || a(t2, e2, { value: o.f(e2) });
        };
      }, function(e, t) {
        e.exports = function(e2) {
          if ("function" != typeof e2)
            throw TypeError(String(e2) + " is not a function");
          return e2;
        };
      }, function(e, t, r) {
        var n = r(13), i = r(59), o = r(5)("species");
        e.exports = function(e2, t2) {
          var r2;
          return i(e2) && ("function" != typeof (r2 = e2.constructor) || r2 !== Array && !i(r2.prototype) ? n(r2) && null === (r2 = r2[o]) && (r2 = void 0) : r2 = void 0), new (void 0 === r2 ? Array : r2)(0 === t2 ? 0 : t2);
        };
      }, function(e, t, r) {
        var n, i, o = r(11), a = r(193), s = o.process, u = s && s.versions, l = u && u.v8;
        l ? i = (n = l.split("."))[0] + n[1] : a && (!(n = a.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = a.match(/Chrome\/(\d+)/)) && (i = n[1]), e.exports = i && +i;
      }, function(e, t, r) {
        var n = r(5), i = r(60), o = r(15), a = n("unscopables"), s = Array.prototype;
        null == s[a] && o.f(s, a, { configurable: true, value: i(null) }), e.exports = function(e2) {
          s[a][e2] = true;
        };
      }, function(e, t, r) {
        "use strict";
        var n, i, o, a = r(132), s = r(21), u = r(14), l = r(5), c = r(44), h = l("iterator"), p = false;
        [].keys && ("next" in (o = [].keys()) ? (i = a(a(o))) !== Object.prototype && (n = i) : p = true), null == n && (n = {}), c || u(n, h) || s(n, h, function() {
          return this;
        }), e.exports = { IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: p };
      }, function(e, t, r) {
        var n = r(14), i = r(27), o = r(57), a = r(196), s = o("IE_PROTO"), u = Object.prototype;
        e.exports = a ? Object.getPrototypeOf : function(e2) {
          return e2 = i(e2), n(e2, s) ? e2[s] : "function" == typeof e2.constructor && e2 instanceof e2.constructor ? e2.constructor.prototype : e2 instanceof Object ? u : null;
        };
      }, function(e, t, r) {
        var n = r(18), i = r(197);
        e.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var e2, t2 = false, r2 = {};
          try {
            (e2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(r2, []), t2 = r2 instanceof Array;
          } catch (e3) {
          }
          return function(r3, o) {
            return n(r3), i(o), t2 ? e2.call(r3, o) : r3.__proto__ = o, r3;
          };
        }() : void 0);
      }, function(e, t, r) {
        "use strict";
        var n = r(56), i = r(15), o = r(40);
        e.exports = function(e2, t2, r2) {
          var a = n(t2);
          a in e2 ? i.f(e2, a, o(0, r2)) : e2[a] = r2;
        };
      }, function(e, t, r) {
        var n = r(90), i = r(42), o = r(5)("toStringTag"), a = "Arguments" == i(function() {
          return arguments;
        }());
        e.exports = n ? i : function(e2) {
          var t2, r2, n2;
          return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (r2 = function(e3, t3) {
            try {
              return e3[t3];
            } catch (e4) {
            }
          }(t2 = Object(e2), o)) ? r2 : a ? i(t2) : "Object" == (n2 = i(t2)) && "function" == typeof t2.callee ? "Arguments" : n2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(18);
        e.exports = function() {
          var e2 = n(this), t2 = "";
          return e2.global && (t2 += "g"), e2.ignoreCase && (t2 += "i"), e2.multiline && (t2 += "m"), e2.dotAll && (t2 += "s"), e2.unicode && (t2 += "u"), e2.sticky && (t2 += "y"), t2;
        };
      }, function(e, t, r) {
        var n = r(47), i = r(35), o = function(e2) {
          return function(t2, r2) {
            var o2, a, s = String(i(t2)), u = n(r2), l = s.length;
            return u < 0 || u >= l ? e2 ? "" : void 0 : (o2 = s.charCodeAt(u)) < 55296 || o2 > 56319 || u + 1 === l || (a = s.charCodeAt(u + 1)) < 56320 || a > 57343 ? e2 ? s.charAt(u) : o2 : e2 ? s.slice(u, u + 2) : a - 56320 + (o2 - 55296 << 10) + 65536;
          };
        };
        e.exports = { codeAt: o(false), charAt: o(true) };
      }, function(e, t, r) {
        var n = r(4), i = r(27), o = r(61);
        n({ target: "Object", stat: true, forced: r(8)(function() {
          o(1);
        }) }, { keys: function(e2) {
          return o(i(e2));
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(11), o = r(123), a = r(25), s = r(140), u = r(141), l = r(142), c = r(13), h = r(8), p = r(208), f = r(62), d = r(209);
        e.exports = function(e2, t2, r2) {
          var m = -1 !== e2.indexOf("Map"), y = -1 !== e2.indexOf("Weak"), v = m ? "set" : "add", _ = i[e2], g = _ && _.prototype, b = _, x = {}, w = function(e3) {
            var t3 = g[e3];
            a(g, e3, "add" == e3 ? function(e4) {
              return t3.call(this, 0 === e4 ? 0 : e4), this;
            } : "delete" == e3 ? function(e4) {
              return !(y && !c(e4)) && t3.call(this, 0 === e4 ? 0 : e4);
            } : "get" == e3 ? function(e4) {
              return y && !c(e4) ? void 0 : t3.call(this, 0 === e4 ? 0 : e4);
            } : "has" == e3 ? function(e4) {
              return !(y && !c(e4)) && t3.call(this, 0 === e4 ? 0 : e4);
            } : function(e4, r3) {
              return t3.call(this, 0 === e4 ? 0 : e4, r3), this;
            });
          };
          if (o(e2, "function" != typeof _ || !(y || g.forEach && !h(function() {
            new _().entries().next();
          }))))
            b = r2.getConstructor(t2, e2, m, v), s.REQUIRED = true;
          else if (o(e2, true)) {
            var E = new b(), D = E[v](y ? {} : -0, 1) != E, S = h(function() {
              E.has(1);
            }), C = p(function(e3) {
              new _(e3);
            }), A = !y && h(function() {
              for (var e3 = new _(), t3 = 5; t3--; )
                e3[v](t3, t3);
              return !e3.has(-0);
            });
            C || ((b = t2(function(t3, r3) {
              l(t3, b, e2);
              var n2 = d(new _(), t3, b);
              return null != r3 && u(r3, n2[v], n2, m), n2;
            })).prototype = g, g.constructor = b), (S || A) && (w("delete"), w("has"), m && w("get")), (A || D) && w(v), y && g.clear && delete g.clear;
          }
          return x[e2] = b, n({ global: true, forced: b != _ }, x), f(b, e2), y || r2.setStrong(b, e2, m), b;
        };
      }, function(e, t, r) {
        var n = r(45), i = r(13), o = r(14), a = r(15).f, s = r(58), u = r(204), l = s("meta"), c = 0, h = Object.isExtensible || function() {
          return true;
        }, p = function(e2) {
          a(e2, l, { value: { objectID: "O" + ++c, weakData: {} } });
        }, f = e.exports = { REQUIRED: false, fastKey: function(e2, t2) {
          if (!i(e2))
            return "symbol" == typeof e2 ? e2 : ("string" == typeof e2 ? "S" : "P") + e2;
          if (!o(e2, l)) {
            if (!h(e2))
              return "F";
            if (!t2)
              return "E";
            p(e2);
          }
          return e2[l].objectID;
        }, getWeakData: function(e2, t2) {
          if (!o(e2, l)) {
            if (!h(e2))
              return true;
            if (!t2)
              return false;
            p(e2);
          }
          return e2[l].weakData;
        }, onFreeze: function(e2) {
          return u && f.REQUIRED && h(e2) && !o(e2, l) && p(e2), e2;
        } };
        n[l] = true;
      }, function(e, t, r) {
        var n = r(18), i = r(205), o = r(26), a = r(87), s = r(206), u = r(207), l = function(e2, t2) {
          this.stopped = e2, this.result = t2;
        };
        (e.exports = function(e2, t2, r2, c, h) {
          var p, f, d, m, y, v, _, g = a(t2, r2, c ? 2 : 1);
          if (h)
            p = e2;
          else {
            if ("function" != typeof (f = s(e2)))
              throw TypeError("Target is not iterable");
            if (i(f)) {
              for (d = 0, m = o(e2.length); m > d; d++)
                if ((y = c ? g(n(_ = e2[d])[0], _[1]) : g(e2[d])) && y instanceof l)
                  return y;
              return new l(false);
            }
            p = f.call(e2);
          }
          for (v = p.next; !(_ = v.call(p)).done; )
            if ("object" == typeof (y = u(p, g, _.value, c)) && y && y instanceof l)
              return y;
          return new l(false);
        }).stop = function(e2) {
          return new l(true, e2);
        };
      }, function(e, t) {
        e.exports = function(e2, t2, r) {
          if (!(e2 instanceof t2))
            throw TypeError("Incorrect " + (r ? r + " " : "") + "invocation");
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(15).f, i = r(60), o = r(210), a = r(87), s = r(142), u = r(141), l = r(88), c = r(211), h = r(16), p = r(140).fastKey, f = r(43), d = f.set, m = f.getterFor;
        e.exports = { getConstructor: function(e2, t2, r2, l2) {
          var c2 = e2(function(e3, n2) {
            s(e3, c2, t2), d(e3, { type: t2, index: i(null), first: void 0, last: void 0, size: 0 }), h || (e3.size = 0), null != n2 && u(n2, e3[l2], e3, r2);
          }), f2 = m(t2), y = function(e3, t3, r3) {
            var n2, i2, o2 = f2(e3), a2 = v(e3, t3);
            return a2 ? a2.value = r3 : (o2.last = a2 = { index: i2 = p(t3, true), key: t3, value: r3, previous: n2 = o2.last, next: void 0, removed: false }, o2.first || (o2.first = a2), n2 && (n2.next = a2), h ? o2.size++ : e3.size++, "F" !== i2 && (o2.index[i2] = a2)), e3;
          }, v = function(e3, t3) {
            var r3, n2 = f2(e3), i2 = p(t3);
            if ("F" !== i2)
              return n2.index[i2];
            for (r3 = n2.first; r3; r3 = r3.next)
              if (r3.key == t3)
                return r3;
          };
          return o(c2.prototype, { clear: function() {
            for (var e3 = f2(this), t3 = e3.index, r3 = e3.first; r3; )
              r3.removed = true, r3.previous && (r3.previous = r3.previous.next = void 0), delete t3[r3.index], r3 = r3.next;
            e3.first = e3.last = void 0, h ? e3.size = 0 : this.size = 0;
          }, delete: function(e3) {
            var t3 = f2(this), r3 = v(this, e3);
            if (r3) {
              var n2 = r3.next, i2 = r3.previous;
              delete t3.index[r3.index], r3.removed = true, i2 && (i2.next = n2), n2 && (n2.previous = i2), t3.first == r3 && (t3.first = n2), t3.last == r3 && (t3.last = i2), h ? t3.size-- : this.size--;
            }
            return !!r3;
          }, forEach: function(e3) {
            for (var t3, r3 = f2(this), n2 = a(e3, arguments.length > 1 ? arguments[1] : void 0, 3); t3 = t3 ? t3.next : r3.first; )
              for (n2(t3.value, t3.key, this); t3 && t3.removed; )
                t3 = t3.previous;
          }, has: function(e3) {
            return !!v(this, e3);
          } }), o(c2.prototype, r2 ? { get: function(e3) {
            var t3 = v(this, e3);
            return t3 && t3.value;
          }, set: function(e3, t3) {
            return y(this, 0 === e3 ? 0 : e3, t3);
          } } : { add: function(e3) {
            return y(this, e3 = 0 === e3 ? 0 : e3, e3);
          } }), h && n(c2.prototype, "size", { get: function() {
            return f2(this).size;
          } }), c2;
        }, setStrong: function(e2, t2, r2) {
          var n2 = t2 + " Iterator", i2 = m(t2), o2 = m(n2);
          l(e2, t2, function(e3, t3) {
            d(this, { type: n2, target: e3, state: i2(e3), kind: t3, last: void 0 });
          }, function() {
            for (var e3 = o2(this), t3 = e3.kind, r3 = e3.last; r3 && r3.removed; )
              r3 = r3.previous;
            return e3.target && (e3.last = r3 = r3 ? r3.next : e3.state.first) ? "keys" == t3 ? { value: r3.key, done: false } : "values" == t3 ? { value: r3.value, done: false } : { value: [r3.key, r3.value], done: false } : (e3.target = void 0, { value: void 0, done: true });
          }, r2 ? "entries" : "values", !r2, true), c(t2);
        } };
      }, function(e, t, r) {
        "use strict";
        var n, i = r(4), o = r(55).f, a = r(26), s = r(222), u = r(35), l = r(224), c = r(44), h = "".endsWith, p = Math.min, f = l("endsWith");
        i({ target: "String", proto: true, forced: !!(c || f || (n = o(String.prototype, "endsWith"), !n || n.writable)) && !f }, { endsWith: function(e2) {
          var t2 = String(u(this));
          s(e2);
          var r2 = arguments.length > 1 ? arguments[1] : void 0, n2 = a(t2.length), i2 = void 0 === r2 ? n2 : p(a(r2), n2), o2 = String(e2);
          return h ? h.call(t2, o2, i2) : t2.slice(i2 - o2.length, i2) === o2;
        } });
      }, function(e, t, r) {
        "use strict";
        (function(e2) {
          var n = r(229), i = r(230), o = r(231);
          function a() {
            return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function s(e3, t2) {
            if (a() < t2)
              throw new RangeError("Invalid typed array length");
            return u.TYPED_ARRAY_SUPPORT ? (e3 = new Uint8Array(t2)).__proto__ = u.prototype : (null === e3 && (e3 = new u(t2)), e3.length = t2), e3;
          }
          function u(e3, t2, r2) {
            if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u))
              return new u(e3, t2, r2);
            if ("number" == typeof e3) {
              if ("string" == typeof t2)
                throw new Error("If encoding is specified then the first argument must be a string");
              return h(this, e3);
            }
            return l(this, e3, t2, r2);
          }
          function l(e3, t2, r2, n2) {
            if ("number" == typeof t2)
              throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && t2 instanceof ArrayBuffer ? function(e4, t3, r3, n3) {
              if (t3.byteLength, r3 < 0 || t3.byteLength < r3)
                throw new RangeError("'offset' is out of bounds");
              if (t3.byteLength < r3 + (n3 || 0))
                throw new RangeError("'length' is out of bounds");
              t3 = void 0 === r3 && void 0 === n3 ? new Uint8Array(t3) : void 0 === n3 ? new Uint8Array(t3, r3) : new Uint8Array(t3, r3, n3);
              u.TYPED_ARRAY_SUPPORT ? (e4 = t3).__proto__ = u.prototype : e4 = p(e4, t3);
              return e4;
            }(e3, t2, r2, n2) : "string" == typeof t2 ? function(e4, t3, r3) {
              "string" == typeof r3 && "" !== r3 || (r3 = "utf8");
              if (!u.isEncoding(r3))
                throw new TypeError('"encoding" must be a valid string encoding');
              var n3 = 0 | d(t3, r3), i2 = (e4 = s(e4, n3)).write(t3, r3);
              i2 !== n3 && (e4 = e4.slice(0, i2));
              return e4;
            }(e3, t2, r2) : function(e4, t3) {
              if (u.isBuffer(t3)) {
                var r3 = 0 | f(t3.length);
                return 0 === (e4 = s(e4, r3)).length || t3.copy(e4, 0, 0, r3), e4;
              }
              if (t3) {
                if ("undefined" != typeof ArrayBuffer && t3.buffer instanceof ArrayBuffer || "length" in t3)
                  return "number" != typeof t3.length || (n3 = t3.length) != n3 ? s(e4, 0) : p(e4, t3);
                if ("Buffer" === t3.type && o(t3.data))
                  return p(e4, t3.data);
              }
              var n3;
              throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
            }(e3, t2);
          }
          function c(e3) {
            if ("number" != typeof e3)
              throw new TypeError('"size" argument must be a number');
            if (e3 < 0)
              throw new RangeError('"size" argument must not be negative');
          }
          function h(e3, t2) {
            if (c(t2), e3 = s(e3, t2 < 0 ? 0 : 0 | f(t2)), !u.TYPED_ARRAY_SUPPORT)
              for (var r2 = 0; r2 < t2; ++r2)
                e3[r2] = 0;
            return e3;
          }
          function p(e3, t2) {
            var r2 = t2.length < 0 ? 0 : 0 | f(t2.length);
            e3 = s(e3, r2);
            for (var n2 = 0; n2 < r2; n2 += 1)
              e3[n2] = 255 & t2[n2];
            return e3;
          }
          function f(e3) {
            if (e3 >= a())
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
            return 0 | e3;
          }
          function d(e3, t2) {
            if (u.isBuffer(e3))
              return e3.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e3) || e3 instanceof ArrayBuffer))
              return e3.byteLength;
            "string" != typeof e3 && (e3 = "" + e3);
            var r2 = e3.length;
            if (0 === r2)
              return 0;
            for (var n2 = false; ; )
              switch (t2) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r2;
                case "utf8":
                case "utf-8":
                case void 0:
                  return z(e3).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r2;
                case "hex":
                  return r2 >>> 1;
                case "base64":
                  return U(e3).length;
                default:
                  if (n2)
                    return z(e3).length;
                  t2 = ("" + t2).toLowerCase(), n2 = true;
              }
          }
          function m(e3, t2, r2) {
            var n2 = false;
            if ((void 0 === t2 || t2 < 0) && (t2 = 0), t2 > this.length)
              return "";
            if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0)
              return "";
            if ((r2 >>>= 0) <= (t2 >>>= 0))
              return "";
            for (e3 || (e3 = "utf8"); ; )
              switch (e3) {
                case "hex":
                  return T(this, t2, r2);
                case "utf8":
                case "utf-8":
                  return C(this, t2, r2);
                case "ascii":
                  return A(this, t2, r2);
                case "latin1":
                case "binary":
                  return N(this, t2, r2);
                case "base64":
                  return S(this, t2, r2);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return O(this, t2, r2);
                default:
                  if (n2)
                    throw new TypeError("Unknown encoding: " + e3);
                  e3 = (e3 + "").toLowerCase(), n2 = true;
              }
          }
          function y(e3, t2, r2) {
            var n2 = e3[t2];
            e3[t2] = e3[r2], e3[r2] = n2;
          }
          function v(e3, t2, r2, n2, i2) {
            if (0 === e3.length)
              return -1;
            if ("string" == typeof r2 ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), r2 = +r2, isNaN(r2) && (r2 = i2 ? 0 : e3.length - 1), r2 < 0 && (r2 = e3.length + r2), r2 >= e3.length) {
              if (i2)
                return -1;
              r2 = e3.length - 1;
            } else if (r2 < 0) {
              if (!i2)
                return -1;
              r2 = 0;
            }
            if ("string" == typeof t2 && (t2 = u.from(t2, n2)), u.isBuffer(t2))
              return 0 === t2.length ? -1 : _(e3, t2, r2, n2, i2);
            if ("number" == typeof t2)
              return t2 &= 255, u.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e3, t2, r2) : Uint8Array.prototype.lastIndexOf.call(e3, t2, r2) : _(e3, [t2], r2, n2, i2);
            throw new TypeError("val must be string, number or Buffer");
          }
          function _(e3, t2, r2, n2, i2) {
            var o2, a2 = 1, s2 = e3.length, u2 = t2.length;
            if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
              if (e3.length < 2 || t2.length < 2)
                return -1;
              a2 = 2, s2 /= 2, u2 /= 2, r2 /= 2;
            }
            function l2(e4, t3) {
              return 1 === a2 ? e4[t3] : e4.readUInt16BE(t3 * a2);
            }
            if (i2) {
              var c2 = -1;
              for (o2 = r2; o2 < s2; o2++)
                if (l2(e3, o2) === l2(t2, -1 === c2 ? 0 : o2 - c2)) {
                  if (-1 === c2 && (c2 = o2), o2 - c2 + 1 === u2)
                    return c2 * a2;
                } else
                  -1 !== c2 && (o2 -= o2 - c2), c2 = -1;
            } else
              for (r2 + u2 > s2 && (r2 = s2 - u2), o2 = r2; o2 >= 0; o2--) {
                for (var h2 = true, p2 = 0; p2 < u2; p2++)
                  if (l2(e3, o2 + p2) !== l2(t2, p2)) {
                    h2 = false;
                    break;
                  }
                if (h2)
                  return o2;
              }
            return -1;
          }
          function g(e3, t2, r2, n2) {
            r2 = Number(r2) || 0;
            var i2 = e3.length - r2;
            n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
            var o2 = t2.length;
            if (o2 % 2 != 0)
              throw new TypeError("Invalid hex string");
            n2 > o2 / 2 && (n2 = o2 / 2);
            for (var a2 = 0; a2 < n2; ++a2) {
              var s2 = parseInt(t2.substr(2 * a2, 2), 16);
              if (isNaN(s2))
                return a2;
              e3[r2 + a2] = s2;
            }
            return a2;
          }
          function b(e3, t2, r2, n2) {
            return G(z(t2, e3.length - r2), e3, r2, n2);
          }
          function x(e3, t2, r2, n2) {
            return G(function(e4) {
              for (var t3 = [], r3 = 0; r3 < e4.length; ++r3)
                t3.push(255 & e4.charCodeAt(r3));
              return t3;
            }(t2), e3, r2, n2);
          }
          function w(e3, t2, r2, n2) {
            return x(e3, t2, r2, n2);
          }
          function E(e3, t2, r2, n2) {
            return G(U(t2), e3, r2, n2);
          }
          function D(e3, t2, r2, n2) {
            return G(function(e4, t3) {
              for (var r3, n3, i2, o2 = [], a2 = 0; a2 < e4.length && !((t3 -= 2) < 0); ++a2)
                r3 = e4.charCodeAt(a2), n3 = r3 >> 8, i2 = r3 % 256, o2.push(i2), o2.push(n3);
              return o2;
            }(t2, e3.length - r2), e3, r2, n2);
          }
          function S(e3, t2, r2) {
            return 0 === t2 && r2 === e3.length ? n.fromByteArray(e3) : n.fromByteArray(e3.slice(t2, r2));
          }
          function C(e3, t2, r2) {
            r2 = Math.min(e3.length, r2);
            for (var n2 = [], i2 = t2; i2 < r2; ) {
              var o2, a2, s2, u2, l2 = e3[i2], c2 = null, h2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i2 + h2 <= r2)
                switch (h2) {
                  case 1:
                    l2 < 128 && (c2 = l2);
                    break;
                  case 2:
                    128 == (192 & (o2 = e3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & o2) > 127 && (c2 = u2);
                    break;
                  case 3:
                    o2 = e3[i2 + 1], a2 = e3[i2 + 2], 128 == (192 & o2) && 128 == (192 & a2) && (u2 = (15 & l2) << 12 | (63 & o2) << 6 | 63 & a2) > 2047 && (u2 < 55296 || u2 > 57343) && (c2 = u2);
                    break;
                  case 4:
                    o2 = e3[i2 + 1], a2 = e3[i2 + 2], s2 = e3[i2 + 3], 128 == (192 & o2) && 128 == (192 & a2) && 128 == (192 & s2) && (u2 = (15 & l2) << 18 | (63 & o2) << 12 | (63 & a2) << 6 | 63 & s2) > 65535 && u2 < 1114112 && (c2 = u2);
                }
              null === c2 ? (c2 = 65533, h2 = 1) : c2 > 65535 && (c2 -= 65536, n2.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), n2.push(c2), i2 += h2;
            }
            return function(e4) {
              var t3 = e4.length;
              if (t3 <= 4096)
                return String.fromCharCode.apply(String, e4);
              var r3 = "", n3 = 0;
              for (; n3 < t3; )
                r3 += String.fromCharCode.apply(String, e4.slice(n3, n3 += 4096));
              return r3;
            }(n2);
          }
          t.Buffer = u, t.SlowBuffer = function(e3) {
            +e3 != e3 && (e3 = 0);
            return u.alloc(+e3);
          }, t.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== e2.TYPED_ARRAY_SUPPORT ? e2.TYPED_ARRAY_SUPPORT : function() {
            try {
              var e3 = new Uint8Array(1);
              return e3.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, 42 === e3.foo() && "function" == typeof e3.subarray && 0 === e3.subarray(1, 1).byteLength;
            } catch (e4) {
              return false;
            }
          }(), t.kMaxLength = a(), u.poolSize = 8192, u._augment = function(e3) {
            return e3.__proto__ = u.prototype, e3;
          }, u.from = function(e3, t2, r2) {
            return l(null, e3, t2, r2);
          }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, { value: null, configurable: true })), u.alloc = function(e3, t2, r2) {
            return function(e4, t3, r3, n2) {
              return c(t3), t3 <= 0 ? s(e4, t3) : void 0 !== r3 ? "string" == typeof n2 ? s(e4, t3).fill(r3, n2) : s(e4, t3).fill(r3) : s(e4, t3);
            }(null, e3, t2, r2);
          }, u.allocUnsafe = function(e3) {
            return h(null, e3);
          }, u.allocUnsafeSlow = function(e3) {
            return h(null, e3);
          }, u.isBuffer = function(e3) {
            return !(null == e3 || !e3._isBuffer);
          }, u.compare = function(e3, t2) {
            if (!u.isBuffer(e3) || !u.isBuffer(t2))
              throw new TypeError("Arguments must be Buffers");
            if (e3 === t2)
              return 0;
            for (var r2 = e3.length, n2 = t2.length, i2 = 0, o2 = Math.min(r2, n2); i2 < o2; ++i2)
              if (e3[i2] !== t2[i2]) {
                r2 = e3[i2], n2 = t2[i2];
                break;
              }
            return r2 < n2 ? -1 : n2 < r2 ? 1 : 0;
          }, u.isEncoding = function(e3) {
            switch (String(e3).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, u.concat = function(e3, t2) {
            if (!o(e3))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e3.length)
              return u.alloc(0);
            var r2;
            if (void 0 === t2)
              for (t2 = 0, r2 = 0; r2 < e3.length; ++r2)
                t2 += e3[r2].length;
            var n2 = u.allocUnsafe(t2), i2 = 0;
            for (r2 = 0; r2 < e3.length; ++r2) {
              var a2 = e3[r2];
              if (!u.isBuffer(a2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              a2.copy(n2, i2), i2 += a2.length;
            }
            return n2;
          }, u.byteLength = d, u.prototype._isBuffer = true, u.prototype.swap16 = function() {
            var e3 = this.length;
            if (e3 % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t2 = 0; t2 < e3; t2 += 2)
              y(this, t2, t2 + 1);
            return this;
          }, u.prototype.swap32 = function() {
            var e3 = this.length;
            if (e3 % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t2 = 0; t2 < e3; t2 += 4)
              y(this, t2, t2 + 3), y(this, t2 + 1, t2 + 2);
            return this;
          }, u.prototype.swap64 = function() {
            var e3 = this.length;
            if (e3 % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t2 = 0; t2 < e3; t2 += 8)
              y(this, t2, t2 + 7), y(this, t2 + 1, t2 + 6), y(this, t2 + 2, t2 + 5), y(this, t2 + 3, t2 + 4);
            return this;
          }, u.prototype.toString = function() {
            var e3 = 0 | this.length;
            return 0 === e3 ? "" : 0 === arguments.length ? C(this, 0, e3) : m.apply(this, arguments);
          }, u.prototype.equals = function(e3) {
            if (!u.isBuffer(e3))
              throw new TypeError("Argument must be a Buffer");
            return this === e3 || 0 === u.compare(this, e3);
          }, u.prototype.inspect = function() {
            var e3 = "", r2 = t.INSPECT_MAX_BYTES;
            return this.length > 0 && (e3 = this.toString("hex", 0, r2).match(/.{2}/g).join(" "), this.length > r2 && (e3 += " ... ")), "<Buffer " + e3 + ">";
          }, u.prototype.compare = function(e3, t2, r2, n2, i2) {
            if (!u.isBuffer(e3))
              throw new TypeError("Argument must be a Buffer");
            if (void 0 === t2 && (t2 = 0), void 0 === r2 && (r2 = e3 ? e3.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), t2 < 0 || r2 > e3.length || n2 < 0 || i2 > this.length)
              throw new RangeError("out of range index");
            if (n2 >= i2 && t2 >= r2)
              return 0;
            if (n2 >= i2)
              return -1;
            if (t2 >= r2)
              return 1;
            if (this === e3)
              return 0;
            for (var o2 = (i2 >>>= 0) - (n2 >>>= 0), a2 = (r2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(o2, a2), l2 = this.slice(n2, i2), c2 = e3.slice(t2, r2), h2 = 0; h2 < s2; ++h2)
              if (l2[h2] !== c2[h2]) {
                o2 = l2[h2], a2 = c2[h2];
                break;
              }
            return o2 < a2 ? -1 : a2 < o2 ? 1 : 0;
          }, u.prototype.includes = function(e3, t2, r2) {
            return -1 !== this.indexOf(e3, t2, r2);
          }, u.prototype.indexOf = function(e3, t2, r2) {
            return v(this, e3, t2, r2, true);
          }, u.prototype.lastIndexOf = function(e3, t2, r2) {
            return v(this, e3, t2, r2, false);
          }, u.prototype.write = function(e3, t2, r2, n2) {
            if (void 0 === t2)
              n2 = "utf8", r2 = this.length, t2 = 0;
            else if (void 0 === r2 && "string" == typeof t2)
              n2 = t2, r2 = this.length, t2 = 0;
            else {
              if (!isFinite(t2))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              t2 |= 0, isFinite(r2) ? (r2 |= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
            }
            var i2 = this.length - t2;
            if ((void 0 === r2 || r2 > i2) && (r2 = i2), e3.length > 0 && (r2 < 0 || t2 < 0) || t2 > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            n2 || (n2 = "utf8");
            for (var o2 = false; ; )
              switch (n2) {
                case "hex":
                  return g(this, e3, t2, r2);
                case "utf8":
                case "utf-8":
                  return b(this, e3, t2, r2);
                case "ascii":
                  return x(this, e3, t2, r2);
                case "latin1":
                case "binary":
                  return w(this, e3, t2, r2);
                case "base64":
                  return E(this, e3, t2, r2);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return D(this, e3, t2, r2);
                default:
                  if (o2)
                    throw new TypeError("Unknown encoding: " + n2);
                  n2 = ("" + n2).toLowerCase(), o2 = true;
              }
          }, u.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          function A(e3, t2, r2) {
            var n2 = "";
            r2 = Math.min(e3.length, r2);
            for (var i2 = t2; i2 < r2; ++i2)
              n2 += String.fromCharCode(127 & e3[i2]);
            return n2;
          }
          function N(e3, t2, r2) {
            var n2 = "";
            r2 = Math.min(e3.length, r2);
            for (var i2 = t2; i2 < r2; ++i2)
              n2 += String.fromCharCode(e3[i2]);
            return n2;
          }
          function T(e3, t2, r2) {
            var n2 = e3.length;
            (!t2 || t2 < 0) && (t2 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
            for (var i2 = "", o2 = t2; o2 < r2; ++o2)
              i2 += R(e3[o2]);
            return i2;
          }
          function O(e3, t2, r2) {
            for (var n2 = e3.slice(t2, r2), i2 = "", o2 = 0; o2 < n2.length; o2 += 2)
              i2 += String.fromCharCode(n2[o2] + 256 * n2[o2 + 1]);
            return i2;
          }
          function F(e3, t2, r2) {
            if (e3 % 1 != 0 || e3 < 0)
              throw new RangeError("offset is not uint");
            if (e3 + t2 > r2)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function k(e3, t2, r2, n2, i2, o2) {
            if (!u.isBuffer(e3))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t2 > i2 || t2 < o2)
              throw new RangeError('"value" argument is out of bounds');
            if (r2 + n2 > e3.length)
              throw new RangeError("Index out of range");
          }
          function P(e3, t2, r2, n2) {
            t2 < 0 && (t2 = 65535 + t2 + 1);
            for (var i2 = 0, o2 = Math.min(e3.length - r2, 2); i2 < o2; ++i2)
              e3[r2 + i2] = (t2 & 255 << 8 * (n2 ? i2 : 1 - i2)) >>> 8 * (n2 ? i2 : 1 - i2);
          }
          function I(e3, t2, r2, n2) {
            t2 < 0 && (t2 = 4294967295 + t2 + 1);
            for (var i2 = 0, o2 = Math.min(e3.length - r2, 4); i2 < o2; ++i2)
              e3[r2 + i2] = t2 >>> 8 * (n2 ? i2 : 3 - i2) & 255;
          }
          function L(e3, t2, r2, n2, i2, o2) {
            if (r2 + n2 > e3.length)
              throw new RangeError("Index out of range");
            if (r2 < 0)
              throw new RangeError("Index out of range");
          }
          function M(e3, t2, r2, n2, o2) {
            return o2 || L(e3, 0, r2, 4), i.write(e3, t2, r2, n2, 23, 4), r2 + 4;
          }
          function B(e3, t2, r2, n2, o2) {
            return o2 || L(e3, 0, r2, 8), i.write(e3, t2, r2, n2, 52, 8), r2 + 8;
          }
          u.prototype.slice = function(e3, t2) {
            var r2, n2 = this.length;
            if ((e3 = ~~e3) < 0 ? (e3 += n2) < 0 && (e3 = 0) : e3 > n2 && (e3 = n2), (t2 = void 0 === t2 ? n2 : ~~t2) < 0 ? (t2 += n2) < 0 && (t2 = 0) : t2 > n2 && (t2 = n2), t2 < e3 && (t2 = e3), u.TYPED_ARRAY_SUPPORT)
              (r2 = this.subarray(e3, t2)).__proto__ = u.prototype;
            else {
              var i2 = t2 - e3;
              r2 = new u(i2, void 0);
              for (var o2 = 0; o2 < i2; ++o2)
                r2[o2] = this[o2 + e3];
            }
            return r2;
          }, u.prototype.readUIntLE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = this[e3], i2 = 1, o2 = 0; ++o2 < t2 && (i2 *= 256); )
              n2 += this[e3 + o2] * i2;
            return n2;
          }, u.prototype.readUIntBE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = this[e3 + --t2], i2 = 1; t2 > 0 && (i2 *= 256); )
              n2 += this[e3 + --t2] * i2;
            return n2;
          }, u.prototype.readUInt8 = function(e3, t2) {
            return t2 || F(e3, 1, this.length), this[e3];
          }, u.prototype.readUInt16LE = function(e3, t2) {
            return t2 || F(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
          }, u.prototype.readUInt16BE = function(e3, t2) {
            return t2 || F(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
          }, u.prototype.readUInt32LE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
          }, u.prototype.readUInt32BE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
          }, u.prototype.readIntLE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = this[e3], i2 = 1, o2 = 0; ++o2 < t2 && (i2 *= 256); )
              n2 += this[e3 + o2] * i2;
            return n2 >= (i2 *= 128) && (n2 -= Math.pow(2, 8 * t2)), n2;
          }, u.prototype.readIntBE = function(e3, t2, r2) {
            e3 |= 0, t2 |= 0, r2 || F(e3, t2, this.length);
            for (var n2 = t2, i2 = 1, o2 = this[e3 + --n2]; n2 > 0 && (i2 *= 256); )
              o2 += this[e3 + --n2] * i2;
            return o2 >= (i2 *= 128) && (o2 -= Math.pow(2, 8 * t2)), o2;
          }, u.prototype.readInt8 = function(e3, t2) {
            return t2 || F(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
          }, u.prototype.readInt16LE = function(e3, t2) {
            t2 || F(e3, 2, this.length);
            var r2 = this[e3] | this[e3 + 1] << 8;
            return 32768 & r2 ? 4294901760 | r2 : r2;
          }, u.prototype.readInt16BE = function(e3, t2) {
            t2 || F(e3, 2, this.length);
            var r2 = this[e3 + 1] | this[e3] << 8;
            return 32768 & r2 ? 4294901760 | r2 : r2;
          }, u.prototype.readInt32LE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
          }, u.prototype.readInt32BE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
          }, u.prototype.readFloatLE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), i.read(this, e3, true, 23, 4);
          }, u.prototype.readFloatBE = function(e3, t2) {
            return t2 || F(e3, 4, this.length), i.read(this, e3, false, 23, 4);
          }, u.prototype.readDoubleLE = function(e3, t2) {
            return t2 || F(e3, 8, this.length), i.read(this, e3, true, 52, 8);
          }, u.prototype.readDoubleBE = function(e3, t2) {
            return t2 || F(e3, 8, this.length), i.read(this, e3, false, 52, 8);
          }, u.prototype.writeUIntLE = function(e3, t2, r2, n2) {
            (e3 = +e3, t2 |= 0, r2 |= 0, n2) || k(this, e3, t2, r2, Math.pow(2, 8 * r2) - 1, 0);
            var i2 = 1, o2 = 0;
            for (this[t2] = 255 & e3; ++o2 < r2 && (i2 *= 256); )
              this[t2 + o2] = e3 / i2 & 255;
            return t2 + r2;
          }, u.prototype.writeUIntBE = function(e3, t2, r2, n2) {
            (e3 = +e3, t2 |= 0, r2 |= 0, n2) || k(this, e3, t2, r2, Math.pow(2, 8 * r2) - 1, 0);
            var i2 = r2 - 1, o2 = 1;
            for (this[t2 + i2] = 255 & e3; --i2 >= 0 && (o2 *= 256); )
              this[t2 + i2] = e3 / o2 & 255;
            return t2 + r2;
          }, u.prototype.writeUInt8 = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (e3 = Math.floor(e3)), this[t2] = 255 & e3, t2 + 1;
          }, u.prototype.writeUInt16LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e3, this[t2 + 1] = e3 >>> 8) : P(this, e3, t2, true), t2 + 2;
          }, u.prototype.writeUInt16BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 8, this[t2 + 1] = 255 & e3) : P(this, e3, t2, false), t2 + 2;
          }, u.prototype.writeUInt32LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e3 >>> 24, this[t2 + 2] = e3 >>> 16, this[t2 + 1] = e3 >>> 8, this[t2] = 255 & e3) : I(this, e3, t2, true), t2 + 4;
          }, u.prototype.writeUInt32BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = 255 & e3) : I(this, e3, t2, false), t2 + 4;
          }, u.prototype.writeIntLE = function(e3, t2, r2, n2) {
            if (e3 = +e3, t2 |= 0, !n2) {
              var i2 = Math.pow(2, 8 * r2 - 1);
              k(this, e3, t2, r2, i2 - 1, -i2);
            }
            var o2 = 0, a2 = 1, s2 = 0;
            for (this[t2] = 255 & e3; ++o2 < r2 && (a2 *= 256); )
              e3 < 0 && 0 === s2 && 0 !== this[t2 + o2 - 1] && (s2 = 1), this[t2 + o2] = (e3 / a2 >> 0) - s2 & 255;
            return t2 + r2;
          }, u.prototype.writeIntBE = function(e3, t2, r2, n2) {
            if (e3 = +e3, t2 |= 0, !n2) {
              var i2 = Math.pow(2, 8 * r2 - 1);
              k(this, e3, t2, r2, i2 - 1, -i2);
            }
            var o2 = r2 - 1, a2 = 1, s2 = 0;
            for (this[t2 + o2] = 255 & e3; --o2 >= 0 && (a2 *= 256); )
              e3 < 0 && 0 === s2 && 0 !== this[t2 + o2 + 1] && (s2 = 1), this[t2 + o2] = (e3 / a2 >> 0) - s2 & 255;
            return t2 + r2;
          }, u.prototype.writeInt8 = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (e3 = Math.floor(e3)), e3 < 0 && (e3 = 255 + e3 + 1), this[t2] = 255 & e3, t2 + 1;
          }, u.prototype.writeInt16LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e3, this[t2 + 1] = e3 >>> 8) : P(this, e3, t2, true), t2 + 2;
          }, u.prototype.writeInt16BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 8, this[t2 + 1] = 255 & e3) : P(this, e3, t2, false), t2 + 2;
          }, u.prototype.writeInt32LE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e3, this[t2 + 1] = e3 >>> 8, this[t2 + 2] = e3 >>> 16, this[t2 + 3] = e3 >>> 24) : I(this, e3, t2, true), t2 + 4;
          }, u.prototype.writeInt32BE = function(e3, t2, r2) {
            return e3 = +e3, t2 |= 0, r2 || k(this, e3, t2, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), u.TYPED_ARRAY_SUPPORT ? (this[t2] = e3 >>> 24, this[t2 + 1] = e3 >>> 16, this[t2 + 2] = e3 >>> 8, this[t2 + 3] = 255 & e3) : I(this, e3, t2, false), t2 + 4;
          }, u.prototype.writeFloatLE = function(e3, t2, r2) {
            return M(this, e3, t2, true, r2);
          }, u.prototype.writeFloatBE = function(e3, t2, r2) {
            return M(this, e3, t2, false, r2);
          }, u.prototype.writeDoubleLE = function(e3, t2, r2) {
            return B(this, e3, t2, true, r2);
          }, u.prototype.writeDoubleBE = function(e3, t2, r2) {
            return B(this, e3, t2, false, r2);
          }, u.prototype.copy = function(e3, t2, r2, n2) {
            if (r2 || (r2 = 0), n2 || 0 === n2 || (n2 = this.length), t2 >= e3.length && (t2 = e3.length), t2 || (t2 = 0), n2 > 0 && n2 < r2 && (n2 = r2), n2 === r2)
              return 0;
            if (0 === e3.length || 0 === this.length)
              return 0;
            if (t2 < 0)
              throw new RangeError("targetStart out of bounds");
            if (r2 < 0 || r2 >= this.length)
              throw new RangeError("sourceStart out of bounds");
            if (n2 < 0)
              throw new RangeError("sourceEnd out of bounds");
            n2 > this.length && (n2 = this.length), e3.length - t2 < n2 - r2 && (n2 = e3.length - t2 + r2);
            var i2, o2 = n2 - r2;
            if (this === e3 && r2 < t2 && t2 < n2)
              for (i2 = o2 - 1; i2 >= 0; --i2)
                e3[i2 + t2] = this[i2 + r2];
            else if (o2 < 1e3 || !u.TYPED_ARRAY_SUPPORT)
              for (i2 = 0; i2 < o2; ++i2)
                e3[i2 + t2] = this[i2 + r2];
            else
              Uint8Array.prototype.set.call(e3, this.subarray(r2, r2 + o2), t2);
            return o2;
          }, u.prototype.fill = function(e3, t2, r2, n2) {
            if ("string" == typeof e3) {
              if ("string" == typeof t2 ? (n2 = t2, t2 = 0, r2 = this.length) : "string" == typeof r2 && (n2 = r2, r2 = this.length), 1 === e3.length) {
                var i2 = e3.charCodeAt(0);
                i2 < 256 && (e3 = i2);
              }
              if (void 0 !== n2 && "string" != typeof n2)
                throw new TypeError("encoding must be a string");
              if ("string" == typeof n2 && !u.isEncoding(n2))
                throw new TypeError("Unknown encoding: " + n2);
            } else
              "number" == typeof e3 && (e3 &= 255);
            if (t2 < 0 || this.length < t2 || this.length < r2)
              throw new RangeError("Out of range index");
            if (r2 <= t2)
              return this;
            var o2;
            if (t2 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, e3 || (e3 = 0), "number" == typeof e3)
              for (o2 = t2; o2 < r2; ++o2)
                this[o2] = e3;
            else {
              var a2 = u.isBuffer(e3) ? e3 : z(new u(e3, n2).toString()), s2 = a2.length;
              for (o2 = 0; o2 < r2 - t2; ++o2)
                this[o2 + t2] = a2[o2 % s2];
            }
            return this;
          };
          var j = /[^+\/0-9A-Za-z-_]/g;
          function R(e3) {
            return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
          }
          function z(e3, t2) {
            var r2;
            t2 = t2 || 1 / 0;
            for (var n2 = e3.length, i2 = null, o2 = [], a2 = 0; a2 < n2; ++a2) {
              if ((r2 = e3.charCodeAt(a2)) > 55295 && r2 < 57344) {
                if (!i2) {
                  if (r2 > 56319) {
                    (t2 -= 3) > -1 && o2.push(239, 191, 189);
                    continue;
                  }
                  if (a2 + 1 === n2) {
                    (t2 -= 3) > -1 && o2.push(239, 191, 189);
                    continue;
                  }
                  i2 = r2;
                  continue;
                }
                if (r2 < 56320) {
                  (t2 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
                  continue;
                }
                r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
              } else
                i2 && (t2 -= 3) > -1 && o2.push(239, 191, 189);
              if (i2 = null, r2 < 128) {
                if ((t2 -= 1) < 0)
                  break;
                o2.push(r2);
              } else if (r2 < 2048) {
                if ((t2 -= 2) < 0)
                  break;
                o2.push(r2 >> 6 | 192, 63 & r2 | 128);
              } else if (r2 < 65536) {
                if ((t2 -= 3) < 0)
                  break;
                o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              } else {
                if (!(r2 < 1114112))
                  throw new Error("Invalid code point");
                if ((t2 -= 4) < 0)
                  break;
                o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
              }
            }
            return o2;
          }
          function U(e3) {
            return n.toByteArray(function(e4) {
              if ((e4 = function(e5) {
                return e5.trim ? e5.trim() : e5.replace(/^\s+|\s+$/g, "");
              }(e4).replace(j, "")).length < 2)
                return "";
              for (; e4.length % 4 != 0; )
                e4 += "=";
              return e4;
            }(e3));
          }
          function G(e3, t2, r2, n2) {
            for (var i2 = 0; i2 < n2 && !(i2 + r2 >= t2.length || i2 >= e3.length); ++i2)
              t2[i2 + r2] = e3[i2];
            return i2;
          }
        }).call(this, r(78));
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.isASCIIByte = function(e2) {
          return e2 >= 0 && e2 <= 127;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o = r2.call(e2), a = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o.next()).done; )
              a.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o.return) && r2.call(o);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a;
        }, i = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(n(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.length = function(e2) {
          return e2.length;
        }, t.byteLowercase = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2[t2];
            r2 >= 65 && r2 <= 90 && (e2[t2] = r2 + 32);
          }
        }, t.byteUppercase = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2[t2];
            r2 >= 97 && r2 <= 122 && (e2[t2] = r2 - 32);
          }
        }, t.byteCaseInsensitiveMatch = function(e2, t2) {
          if (e2.length !== t2.length)
            return false;
          for (var r2 = 0; r2 < e2.length; r2++) {
            var n2 = e2[r2], i2 = t2[r2];
            if (n2 >= 65 && n2 <= 90 && (n2 += 32), i2 >= 65 && i2 <= 90 && (i2 += 32), n2 !== i2)
              return false;
          }
          return true;
        }, t.startsWith = function(e2, t2) {
          for (var r2 = 0; ; ) {
            if (r2 >= e2.length)
              return false;
            if (r2 >= t2.length)
              return true;
            if (e2[r2] !== t2[r2])
              return false;
            r2++;
          }
        }, t.byteLessThan = function(e2, t2) {
          for (var r2 = 0; ; ) {
            if (r2 >= e2.length)
              return false;
            if (r2 >= t2.length)
              return true;
            var n2 = e2[r2], i2 = t2[r2];
            if (n2 < i2)
              return true;
            if (n2 > i2)
              return false;
            r2++;
          }
        }, t.isomorphicDecode = function(e2) {
          return String.fromCodePoint.apply(String, i(e2));
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(6), i = r(7), o = r(0), a = r(12), s = function() {
          function e2(e3) {
            this._associatedDocument = e3 || n.dom.window.document;
          }
          return e2.prototype.createDocumentType = function(e3, t2, r2) {
            return o.namespace_validate(e3), o.create_documentType(this._associatedDocument, e3, t2, r2);
          }, e2.prototype.createDocument = function(e3, t2, r2) {
            void 0 === r2 && (r2 = null);
            var n2 = o.create_xmlDocument(), a2 = null;
            return t2 && (a2 = o.document_internalCreateElementNS(n2, e3, t2)), r2 && n2.appendChild(r2), a2 && n2.appendChild(a2), n2._origin = this._associatedDocument._origin, e3 === i.namespace.HTML ? n2._contentType = "application/xhtml+xml" : e3 === i.namespace.SVG ? n2._contentType = "image/svg+xml" : n2._contentType = "application/xml", n2;
          }, e2.prototype.createHTMLDocument = function(e3) {
            var t2 = o.create_document();
            t2._type = "html", t2._contentType = "text/html", t2.appendChild(o.create_documentType(t2, "html", "", ""));
            var r2 = o.element_createAnElement(t2, "html", i.namespace.HTML);
            t2.appendChild(r2);
            var n2 = o.element_createAnElement(t2, "head", i.namespace.HTML);
            if (r2.appendChild(n2), void 0 !== e3) {
              var a2 = o.element_createAnElement(t2, "title", i.namespace.HTML);
              n2.appendChild(a2);
              var s2 = o.create_text(t2, e3);
              a2.appendChild(s2);
            }
            var u = o.element_createAnElement(t2, "body", i.namespace.HTML);
            return r2.appendChild(u), t2._origin = this._associatedDocument._origin, t2;
          }, e2.prototype.hasFeature = function() {
            return true;
          }, e2._create = function(t2) {
            return new e2(t2);
          }, e2;
        }();
        t.DOMImplementationImpl = s, a.idl_defineConst(s.prototype, "_ID", "@oozcitak/dom");
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(70), a = r(2), s = r(0), u = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._signalSlots = /* @__PURE__ */ new Set(), t3._mutationObserverMicrotaskQueued = false, t3._mutationObservers = /* @__PURE__ */ new Set(), t3._iteratorList = new a.FixedSizeSet(), t3._associatedDocument = s.create_document(), t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "document", { get: function() {
            return this._associatedDocument;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "event", { get: function() {
            return this._currentEvent;
          }, enumerable: true, configurable: true }), t2._create = function() {
            return new t2();
          }, t2;
        }(o.EventTargetImpl);
        t.WindowImpl = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = function() {
          function e2() {
          }
          return e2.isNode = function(e3) {
            return !!e3 && void 0 !== e3._nodeType;
          }, e2.isDocumentNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Document;
          }, e2.isDocumentTypeNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.DocumentType;
          }, e2.isDocumentFragmentNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.DocumentFragment;
          }, e2.isAttrNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Attribute;
          }, e2.isCharacterDataNode = function(t2) {
            if (!e2.isNode(t2))
              return false;
            var r2 = t2._nodeType;
            return r2 === n.NodeType.Text || r2 === n.NodeType.ProcessingInstruction || r2 === n.NodeType.Comment || r2 === n.NodeType.CData;
          }, e2.isTextNode = function(t2) {
            return e2.isNode(t2) && (t2._nodeType === n.NodeType.Text || t2._nodeType === n.NodeType.CData);
          }, e2.isExclusiveTextNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Text;
          }, e2.isCDATASectionNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.CData;
          }, e2.isCommentNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Comment;
          }, e2.isProcessingInstructionNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.ProcessingInstruction;
          }, e2.isElementNode = function(t2) {
            return e2.isNode(t2) && t2._nodeType === n.NodeType.Element;
          }, e2.isCustomElementNode = function(t2) {
            return e2.isElementNode(t2) && "custom" === t2._customElementState;
          }, e2.isShadowRoot = function(e3) {
            return !!e3 && void 0 !== e3.host;
          }, e2.isMouseEvent = function(e3) {
            return !!e3 && void 0 !== e3.screenX && null != e3.screenY;
          }, e2.isSlotable = function(t2) {
            return !!t2 && void 0 !== t2._name && void 0 !== t2._assignedSlot && (e2.isTextNode(t2) || e2.isElementNode(t2));
          }, e2.isSlot = function(t2) {
            return !!t2 && void 0 !== t2._name && void 0 !== t2._assignedNodes && e2.isElementNode(t2);
          }, e2.isWindow = function(e3) {
            return !!e3 && void 0 !== e3.navigator;
          }, e2.isEventListener = function(e3) {
            return !!e3 && void 0 !== e3.handleEvent;
          }, e2.isRegisteredObserver = function(e3) {
            return !!e3 && void 0 !== e3.observer && void 0 !== e3.options;
          }, e2.isTransientRegisteredObserver = function(t2) {
            return !!t2 && void 0 !== t2.source && e2.isRegisteredObserver(t2);
          }, e2;
        }();
        t.Guard = i;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2() {
            return e2.call(this) || this;
          }
          return i(t2, e2), t2;
        }(r(98).DocumentImpl);
        t.XMLDocumentImpl = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o, a = r(2), s = r(243), u = r(7), l = r(244), c = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, h = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, p = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, f = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, d = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, m = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/, y = /[\0\t\f\r #%/:?@\[\\\]]/;
        function v(e2) {
          void 0 !== o && o.call(null, "Validation Error: " + e2);
        }
        function _() {
          return { scheme: "", username: "", password: "", host: null, port: null, path: [], query: null, fragment: null, _cannotBeABaseURLFlag: false, _blobURLEntry: null };
        }
        function g(e2) {
          return e2 in c;
        }
        function b(e2) {
          return g(e2.scheme);
        }
        function x(e2) {
          return c[e2] || null;
        }
        function w(e2) {
          return "" !== e2.username || "" !== e2.password;
        }
        function E(e2, t2) {
          var r2, i2;
          void 0 === t2 && (t2 = false);
          var o2 = e2.scheme + ":";
          if (null !== e2.host ? (o2 += "//", w(e2) && (o2 += e2.username, "" !== e2.password && (o2 += ":" + e2.password), o2 += "@"), o2 += D(e2.host), null !== e2.port && (o2 += ":" + e2.port)) : null === e2.host && "file" === e2.scheme && (o2 += "//"), e2._cannotBeABaseURLFlag)
            o2 += e2.path[0];
          else
            try {
              for (var a2 = n(e2.path), s2 = a2.next(); !s2.done; s2 = a2.next()) {
                o2 += "/" + s2.value;
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          return null !== e2.query && (o2 += "?" + e2.query), t2 || null === e2.fragment || (o2 += "#" + e2.fragment), o2;
        }
        function D(e2) {
          return a.isNumber(e2) ? S(e2) : a.isArray(e2) ? "[" + C(e2) + "]" : e2;
        }
        function S(e2) {
          for (var t2 = "", r2 = e2, n2 = 1; n2 <= 4; n2++)
            t2 = (r2 % 256).toString() + t2, 4 !== n2 && (t2 = "." + t2), r2 = Math.floor(r2 / 256);
          return t2;
        }
        function C(e2) {
          for (var t2 = "", r2 = null, n2 = -1, i2 = 0, o2 = 0, a2 = 0; a2 < 8; a2++)
            if (0 === e2[a2]) {
              i2 = 1;
              for (var s2 = a2 + 1; s2 < 8 && 0 === e2[s2]; s2++)
                i2++;
              i2 > o2 && (o2 = i2, n2 = a2);
            }
          o2 > 1 && (r2 = n2);
          for (var u2 = false, l2 = 0; l2 < 8; l2++)
            u2 && 0 === e2[l2] || (u2 && (u2 = false), r2 !== l2 ? (t2 += e2[l2].toString(16), 7 !== l2 && (t2 += ":")) : (t2 += 0 === l2 ? "::" : ":", u2 = true));
          return t2;
        }
        function A(e2, t2, r2, i2, o2) {
          var l2, c2, y2, _2;
          if (void 0 === i2) {
            i2 = { scheme: "", username: "", password: "", host: null, port: null, path: [], query: null, fragment: null, _cannotBeABaseURLFlag: false, _blobURLEntry: null };
            var E2 = /^[\u0000-\u001F\u0020]+/, D2 = /[\u0000-\u001F\u0020]+$/;
            (E2.test(e2) || D2.test(e2)) && v("Input string contains leading or trailing control characters or space."), e2 = (e2 = e2.replace(E2, "")).replace(D2, "");
          }
          var S2 = /[\u0009\u000A\u000D]/g;
          S2.test(e2) && v("Input string contains tab or newline characters."), e2 = e2.replace(S2, "");
          var C2 = void 0 === o2 ? s.ParserState.SchemeStart : o2;
          void 0 === t2 && (t2 = null);
          for (var A2 = void 0 === r2 || "replacement" === r2 || "UTF-16BE" === r2 || "UTF-16LE" === r2 ? "UTF-8" : r2, L2 = "", M2 = false, B2 = false, j2 = false, R2 = new a.StringWalker(e2); ; ) {
            switch (C2) {
              case s.ParserState.SchemeStart:
                if (u.codePoint.ASCIIAlpha.test(R2.c()))
                  L2 += R2.c().toLowerCase(), C2 = s.ParserState.Scheme;
                else {
                  if (void 0 !== o2)
                    return v("Invalid scheme start character."), null;
                  C2 = s.ParserState.NoScheme, R2.pointer--;
                }
                break;
              case s.ParserState.Scheme:
                if (u.codePoint.ASCIIAlphanumeric.test(R2.c()) || "+" === R2.c() || "-" === R2.c() || "." === R2.c())
                  L2 += R2.c().toLowerCase();
                else {
                  if (":" !== R2.c()) {
                    if (void 0 === o2) {
                      L2 = "", C2 = s.ParserState.NoScheme, R2.pointer = 0;
                      continue;
                    }
                    return v("Invalid input string."), null;
                  }
                  if (void 0 !== o2) {
                    if (g(i2.scheme) && !g(L2))
                      return i2;
                    if (!g(i2.scheme) && g(L2))
                      return i2;
                    if ((w(i2) || null !== i2.port) && "file" === L2)
                      return i2;
                    if ("file" === i2.scheme && ("" === i2.host || null === i2.host))
                      return i2;
                  }
                  if (i2.scheme = L2, void 0 !== o2)
                    return i2.port === x(i2.scheme) && (i2.port = null), i2;
                  L2 = "", "file" === i2.scheme ? (R2.remaining().startsWith("//") || v("Invalid file URL scheme, '//' expected."), C2 = s.ParserState.File) : b(i2) && null !== t2 && t2.scheme === i2.scheme ? C2 = s.ParserState.SpecialRelativeOrAuthority : b(i2) ? C2 = s.ParserState.SpecialAuthoritySlashes : R2.remaining().startsWith("/") ? (C2 = s.ParserState.PathOrAuthority, R2.pointer++) : (i2._cannotBeABaseURLFlag = true, i2.path.push(""), C2 = s.ParserState.CannotBeABaseURLPath);
                }
                break;
              case s.ParserState.NoScheme:
                if (null === t2 || t2._cannotBeABaseURLFlag && "#" !== R2.c())
                  return v("Invalid input string."), null;
                t2._cannotBeABaseURLFlag && "#" === R2.c() ? (i2.scheme = t2.scheme, i2.path = u.list.clone(t2.path), i2.query = t2.query, i2.fragment = "", i2._cannotBeABaseURLFlag = true, C2 = s.ParserState.Fragment) : "file" !== t2.scheme ? (C2 = s.ParserState.Relative, R2.pointer--) : (C2 = s.ParserState.File, R2.pointer--);
                break;
              case s.ParserState.SpecialRelativeOrAuthority:
                "/" === R2.c() && R2.remaining().startsWith("/") ? (C2 = s.ParserState.SpecialAuthorityIgnoreSlashes, R2.pointer++) : (v("Invalid input string."), C2 = s.ParserState.Relative, R2.pointer--);
                break;
              case s.ParserState.PathOrAuthority:
                "/" === R2.c() ? C2 = s.ParserState.Authority : (C2 = s.ParserState.Path, R2.pointer--);
                break;
              case s.ParserState.Relative:
                if (null === t2)
                  throw new Error("Invalid parser state. Base URL is null.");
                switch (i2.scheme = t2.scheme, R2.c()) {
                  case "":
                    i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), i2.query = t2.query;
                    break;
                  case "/":
                    C2 = s.ParserState.RelativeSlash;
                    break;
                  case "?":
                    i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), i2.query = "", C2 = s.ParserState.Query;
                    break;
                  case "#":
                    i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), i2.query = t2.query, i2.fragment = "", C2 = s.ParserState.Fragment;
                    break;
                  default:
                    b(i2) && "\\" === R2.c() ? (v("Invalid input string."), C2 = s.ParserState.RelativeSlash) : (i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, i2.path = u.list.clone(t2.path), 0 !== i2.path.length && i2.path.splice(i2.path.length - 1, 1), C2 = s.ParserState.Path, R2.pointer--);
                }
                break;
              case s.ParserState.RelativeSlash:
                if (!b(i2) || "/" !== R2.c() && "\\" !== R2.c())
                  if ("/" === R2.c())
                    C2 = s.ParserState.Authority;
                  else {
                    if (null === t2)
                      throw new Error("Invalid parser state. Base URL is null.");
                    i2.username = t2.username, i2.password = t2.password, i2.host = t2.host, i2.port = t2.port, C2 = s.ParserState.Path, R2.pointer--;
                  }
                else
                  "\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.SpecialAuthorityIgnoreSlashes;
                break;
              case s.ParserState.SpecialAuthoritySlashes:
                "/" === R2.c() && R2.remaining().startsWith("/") ? (C2 = s.ParserState.SpecialAuthorityIgnoreSlashes, R2.pointer++) : (v("Expected '//'."), C2 = s.ParserState.SpecialAuthorityIgnoreSlashes, R2.pointer--);
                break;
              case s.ParserState.SpecialAuthorityIgnoreSlashes:
                "/" !== R2.c() && "\\" !== R2.c() ? (C2 = s.ParserState.Authority, R2.pointer--) : v("Unexpected '/' or '\\'.");
                break;
              case s.ParserState.Authority:
                if ("@" === R2.c()) {
                  v("Unexpected '@'."), M2 && (L2 = "%40" + L2), M2 = true;
                  try {
                    for (var U2 = (l2 = void 0, n(L2)), G2 = U2.next(); !G2.done; G2 = U2.next()) {
                      var q2 = G2.value;
                      if (":" !== q2 || j2) {
                        var W2 = X(q2, d);
                        j2 ? i2.password += W2 : i2.username += W2;
                      } else
                        j2 = true;
                    }
                  } catch (e3) {
                    l2 = { error: e3 };
                  } finally {
                    try {
                      G2 && !G2.done && (c2 = U2.return) && c2.call(U2);
                    } finally {
                      if (l2)
                        throw l2.error;
                    }
                  }
                  L2 = "";
                } else if ("" === R2.c() || "/" === R2.c() || "?" === R2.c() || "#" === R2.c() || b(i2) && "\\" === R2.c()) {
                  if (M2 && "" === L2)
                    return v("Invalid input string."), null;
                  R2.pointer -= L2.length + 1, L2 = "", C2 = s.ParserState.Host;
                } else
                  L2 += R2.c();
                break;
              case s.ParserState.Host:
              case s.ParserState.Hostname:
                if (void 0 !== o2 && "file" === i2.scheme)
                  R2.pointer--, C2 = s.ParserState.FileHost;
                else if (":" !== R2.c() || B2)
                  if ("" === R2.c() || "/" === R2.c() || "?" === R2.c() || "#" === R2.c() || b(i2) && "\\" === R2.c()) {
                    if (R2.pointer--, b(i2) && "" === L2)
                      return v("Invalid input string."), null;
                    if (void 0 !== o2 && "" === L2 && (w(i2) || null !== i2.port))
                      return v("Invalid input string."), i2;
                    if (null === (J = I(L2, !b(i2))))
                      return null;
                    if (i2.host = J, L2 = "", C2 = s.ParserState.PathStart, void 0 !== o2)
                      return i2;
                  } else
                    "[" === R2.c() && (B2 = true), "]" === R2.c() && (B2 = false), L2 += R2.c();
                else {
                  if ("" === L2)
                    return v("Invalid input string."), null;
                  if (null === (J = I(L2, !b(i2))))
                    return null;
                  if (i2.host = J, L2 = "", C2 = s.ParserState.Port, o2 === s.ParserState.Hostname)
                    return i2;
                }
                break;
              case s.ParserState.Port:
                if (u.codePoint.ASCIIDigit.test(R2.c()))
                  L2 += R2.c();
                else {
                  if (!("" === R2.c() || "/" === R2.c() || "?" === R2.c() || "#" === R2.c() || b(i2) && "\\" === R2.c() || o2))
                    return v("Invalid input string."), null;
                  if ("" !== L2 && "" !== L2) {
                    var H2 = parseInt(L2, 10);
                    if (H2 > Math.pow(2, 16) - 1)
                      return v("Invalid port number."), null;
                    i2.port = H2 === x(i2.scheme) ? null : H2, L2 = "";
                  }
                  if (void 0 !== o2)
                    return i2;
                  C2 = s.ParserState.PathStart, R2.pointer--;
                }
                break;
              case s.ParserState.File:
                if (i2.scheme = "file", "/" === R2.c() || "\\" === R2.c())
                  "\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.FileSlash;
                else if (null !== t2 && "file" === t2.scheme)
                  switch (R2.c()) {
                    case "":
                      i2.host = t2.host, i2.path = u.list.clone(t2.path), i2.query = t2.query;
                      break;
                    case "?":
                      i2.host = t2.host, i2.path = u.list.clone(t2.path), i2.query = "", C2 = s.ParserState.Query;
                      break;
                    case "#":
                      i2.host = t2.host, i2.path = u.list.clone(t2.path), i2.query = t2.query, i2.fragment = "", C2 = s.ParserState.Fragment;
                      break;
                    default:
                      P(R2.substring()) ? v("Unexpected windows drive letter in input string.") : (i2.host = t2.host, i2.path = u.list.clone(t2.path), O(i2)), C2 = s.ParserState.Path, R2.pointer--;
                  }
                else
                  C2 = s.ParserState.Path, R2.pointer--;
                break;
              case s.ParserState.FileSlash:
                "/" === R2.c() || "\\" === R2.c() ? ("\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.FileHost) : (null === t2 || "file" !== t2.scheme || P(R2.substring()) || (F(t2.path[0]) ? i2.path.push(t2.path[0]) : i2.host = t2.host), C2 = s.ParserState.Path, R2.pointer--);
                break;
              case s.ParserState.FileHost:
                if ("" === R2.c() || "/" === R2.c() || "\\" === R2.c() || "?" === R2.c() || "#" === R2.c())
                  if (R2.pointer--, void 0 === o2 && k(L2))
                    v("Unexpected windows drive letter in input string."), C2 = s.ParserState.Path;
                  else if ("" === L2) {
                    if (i2.host = "", void 0 !== o2)
                      return i2;
                    C2 = s.ParserState.PathStart;
                  } else {
                    var J;
                    if (null === (J = I(L2, !b(i2))))
                      return null;
                    if ("localhost" === J && (J = ""), i2.host = J, void 0 !== o2)
                      return i2;
                    L2 = "", C2 = s.ParserState.PathStart;
                  }
                else
                  L2 += R2.c();
                break;
              case s.ParserState.PathStart:
                b(i2) ? ("\\" === R2.c() && v("Invalid input string."), C2 = s.ParserState.Path, "/" !== R2.c() && "\\" !== R2.c() && R2.pointer--) : void 0 === o2 && "?" === R2.c() ? (i2.query = "", C2 = s.ParserState.Query) : void 0 === o2 && "#" === R2.c() ? (i2.fragment = "", C2 = s.ParserState.Fragment) : "" !== R2.c() && (C2 = s.ParserState.Path, "/" !== R2.c() && R2.pointer--);
                break;
              case s.ParserState.Path:
                if ("" === R2.c() || "/" === R2.c() || b(i2) && "\\" === R2.c() || void 0 === o2 && ("?" === R2.c() || "#" === R2.c())) {
                  if (b(i2) && "\\" === R2.c() && v("Invalid input string."), T(L2))
                    O(i2), "/" === R2.c() || b(i2) && "\\" === R2.c() || i2.path.push("");
                  else if (!N(L2) || "/" === R2.c() || b(i2) && "\\" === R2.c()) {
                    if (!N(L2)) {
                      if ("file" === i2.scheme && 0 === i2.path.length && k(L2)) {
                        null !== i2.host && "" !== i2.host && (v("Invalid input string."), i2.host = "");
                        var Y = Array.from(L2);
                        L2 = Y.slice(0, 1) + ":" + Y.slice(2);
                      }
                      i2.path.push(L2);
                    }
                  } else
                    i2.path.push("");
                  if (L2 = "", "file" === i2.scheme && ("" === R2.c() || "?" === R2.c() || "#" === R2.c()))
                    for (; i2.path.length > 1 && "" === i2.path[0]; )
                      v("Invalid input string."), i2.path.splice(0, 1);
                  "?" === R2.c() && (i2.query = "", C2 = s.ParserState.Query), "#" === R2.c() && (i2.fragment = "", C2 = s.ParserState.Fragment);
                } else
                  m.test(R2.c()) || "%" === R2.c() || v("Character is not a URL code point or a percent encoded character."), "%" !== R2.c() || /^[0-9a-fA-F][0-9a-fA-F]/.test(R2.remaining()) || v("Percent encoded character must be followed by two hex digits."), L2 += X(R2.c(), f);
                break;
              case s.ParserState.CannotBeABaseURLPath:
                "?" === R2.c() ? (i2.query = "", C2 = s.ParserState.Query) : "#" === R2.c() ? (i2.fragment = "", C2 = s.ParserState.Fragment) : ("" === R2.c() || m.test(R2.c()) || "%" === R2.c() || v("Character is not a URL code point or a percent encoded character."), "%" !== R2.c() || /^[0-9a-fA-F][0-9a-fA-F]/.test(R2.remaining()) || v("Percent encoded character must be followed by two hex digits."), "" !== R2.c() && (i2.path[0] += X(R2.c(), h)));
                break;
              case s.ParserState.Query:
                if ("UTF-8" === A2 || b(i2) && "ws" !== i2.scheme && "wss" !== i2.scheme || (A2 = "UTF-8"), void 0 === o2 && "#" === R2.c())
                  i2.fragment = "", C2 = s.ParserState.Fragment;
                else if ("" !== R2.c()) {
                  if (m.test(R2.c()) || "%" === R2.c() || v("Character is not a URL code point or a percent encoded character."), "%" !== R2.c() || /^[0-9a-fA-F][0-9a-fA-F]/.test(R2.remaining()) || v("Percent encoded character must be followed by two hex digits."), "UTF-8" !== A2.toUpperCase())
                    throw new Error("Only UTF-8 encoding is supported.");
                  var V = a.utf8Encode(R2.c());
                  if (V.length >= 3 && 38 === V[0] && 35 === V[1] && 59 === V[V.length - 1])
                    V = V.subarray(2, V.length - 1), i2.query += "%26%23" + u.byteSequence.isomorphicDecode(V) + "%3B";
                  else
                    try {
                      for (var K = (y2 = void 0, n(V)), $ = K.next(); !$.done; $ = K.next()) {
                        var Q = $.value;
                        Q < 33 || Q > 126 || 34 === Q || 35 === Q || 60 === Q || 62 === Q || 39 === Q && b(i2) ? i2.query += z(Q) : i2.query += String.fromCharCode(Q);
                      }
                    } catch (e3) {
                      y2 = { error: e3 };
                    } finally {
                      try {
                        $ && !$.done && (_2 = K.return) && _2.call(K);
                      } finally {
                        if (y2)
                          throw y2.error;
                      }
                    }
                }
                break;
              case s.ParserState.Fragment:
                "" === R2.c() || ("\0" === R2.c() ? v("NULL character in input string.") : (m.test(R2.c()) || "%" === R2.c() || v("Unexpected character in fragment string."), "%" !== R2.c() || /^[A-Za-z0-9][A-Za-z0-9]/.test(R2.remaining()) || v("Unexpected character in fragment string."), i2.fragment += X(R2.c(), p)));
            }
            if (R2.eof)
              break;
            R2.pointer++;
          }
          return i2;
        }
        function N(e2) {
          return "." === e2 || "%2e" === e2.toLowerCase();
        }
        function T(e2) {
          var t2 = e2.toLowerCase();
          return ".." === t2 || ".%2e" === t2 || "%2e." === t2 || "%2e%2e" === t2;
        }
        function O(e2) {
          var t2 = e2.path;
          0 !== t2.length && ("file" === e2.scheme && 1 === t2.length && F(t2[0]) || e2.path.splice(e2.path.length - 1, 1));
        }
        function F(e2) {
          return e2.length >= 2 && u.codePoint.ASCIIAlpha.test(e2[0]) && ":" === e2[1];
        }
        function k(e2) {
          return e2.length >= 2 && u.codePoint.ASCIIAlpha.test(e2[0]) && (":" === e2[1] || "|" === e2[1]);
        }
        function P(e2) {
          return e2.length >= 2 && k(e2) && (2 === e2.length || "/" === e2[2] || "\\" === e2[2] || "?" === e2[2] || "#" === e2[2]);
        }
        function I(e2, t2) {
          if (void 0 === t2 && (t2 = false), e2.startsWith("["))
            return e2.endsWith("]") ? B(e2.substring(1, e2.length - 1)) : (v("Expected ']' after '['."), null);
          if (t2)
            return j(e2);
          var r2 = H(a.utf8Decode(G(e2)));
          if (null === r2)
            return v("Invalid domain."), null;
          if (y.test(r2))
            return v("Invalid domain."), null;
          var n2 = M(r2);
          return null === n2 || a.isNumber(n2) ? n2 : r2;
        }
        function L(e2, t2) {
          void 0 === t2 && (t2 = { value: false });
          var r2 = 10;
          return e2.startsWith("0x") || e2.startsWith("0X") ? (t2.value = true, e2 = e2.substr(2), r2 = 16) : e2.length >= 2 && "0" === e2[0] && (t2.value = true, e2 = e2.substr(1), r2 = 8), "" === e2 ? 0 : (10 === r2 ? /^[0-9]+$/ : 16 === r2 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/).test(e2) ? parseInt(e2, r2) : null;
        }
        function M(e2) {
          var t2, r2, i2, o2, a2 = { value: false }, s2 = e2.split(".");
          if ("" === s2[s2.length - 1] && (a2.value = true, s2.length > 1 && s2.pop()), s2.length > 4)
            return e2;
          var u2 = [];
          try {
            for (var l2 = n(s2), c2 = l2.next(); !c2.done; c2 = l2.next()) {
              var h2 = c2.value;
              if ("" === h2)
                return e2;
              if (null === (_2 = L(h2, a2)))
                return e2;
              u2.push(_2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (r2 = l2.return) && r2.call(l2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          a2.value && v("Invalid IP v4 address.");
          for (var p2 = 0; p2 < u2.length; p2++) {
            if (u2[p2] > 255 && (v("Invalid IP v4 address."), p2 < u2.length - 1))
              return null;
          }
          if (u2[u2.length - 1] >= Math.pow(256, 5 - u2.length))
            return v("Invalid IP v4 address."), null;
          var f2 = u2[u2.length - 1];
          u2.pop();
          var d2 = 0;
          try {
            for (var m2 = n(u2), y2 = m2.next(); !y2.done; y2 = m2.next()) {
              var _2;
              f2 += (_2 = y2.value) * Math.pow(256, 3 - d2), d2++;
            }
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              y2 && !y2.done && (o2 = m2.return) && o2.call(m2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return f2;
        }
        function B(e2) {
          var t2, r2 = [0, 0, 0, 0, 0, 0, 0, 0], n2 = 0, o2 = null, s2 = new a.StringWalker(e2);
          if (":" === s2.c()) {
            if (!s2.remaining().startsWith(":"))
              return v("Invalid IP v6 address."), null;
            s2.pointer += 2, o2 = n2 += 1;
          }
          for (; "" !== s2.c(); ) {
            if (8 === n2)
              return v("Invalid IP v6 address."), null;
            if (":" !== s2.c()) {
              for (var l2 = 0, c2 = 0; c2 < 4 && u.codePoint.ASCIIHexDigit.test(s2.c()); )
                l2 = 16 * l2 + parseInt(s2.c(), 16), s2.pointer++, c2++;
              if ("." === s2.c()) {
                if (0 === c2)
                  return v("Invalid IP v6 address."), null;
                if (s2.pointer -= c2, n2 > 6)
                  return v("Invalid IP v6 address."), null;
                for (var h2 = 0; "" !== s2.c(); ) {
                  var p2 = null;
                  if (h2 > 0) {
                    if (!("." === s2.c() && h2 < 4))
                      return v("Invalid IP v6 address."), null;
                    s2.pointer++;
                  }
                  if (!u.codePoint.ASCIIDigit.test(s2.c()))
                    return v("Invalid IP v6 address."), null;
                  for (; u.codePoint.ASCIIDigit.test(s2.c()); ) {
                    var f2 = parseInt(s2.c(), 10);
                    if (null === p2)
                      p2 = f2;
                    else {
                      if (0 === p2)
                        return v("Invalid IP v6 address."), null;
                      p2 = 10 * p2 + f2;
                    }
                    if (p2 > 255)
                      return v("Invalid IP v6 address."), null;
                    s2.pointer++;
                  }
                  if (null === p2)
                    return v("Invalid IP v6 address."), null;
                  r2[n2] = 256 * r2[n2] + p2, 2 !== ++h2 && 4 !== h2 || n2++;
                }
                if (4 !== h2)
                  return v("Invalid IP v6 address."), null;
                break;
              }
              if (":" === s2.c()) {
                if (s2.pointer++, "" === s2.c())
                  return v("Invalid IP v6 address."), null;
              } else if ("" !== s2.c())
                return v("Invalid IP v6 address."), null;
              r2[n2] = l2, n2++;
            } else {
              if (null !== o2)
                return v("Invalid IP v6 address."), null;
              s2.pointer++, o2 = ++n2;
            }
          }
          if (null !== o2) {
            var d2 = n2 - o2;
            for (n2 = 7; 0 !== n2 && d2 > 0; )
              t2 = i([r2[o2 + d2 - 1], r2[n2]], 2), r2[n2] = t2[0], r2[o2 + d2 - 1] = t2[1], n2--, d2--;
          } else if (null === o2 && 8 !== n2)
            return v("Invalid IP v6 address."), null;
          return r2;
        }
        function j(e2) {
          var t2, r2;
          if (/[\x00\t\f\r #/:?@\[\\\]]/.test(e2))
            return v("Invalid host string."), null;
          var i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              i2 += X(a2.value, h);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          return i2;
        }
        function R(e2) {
          return null;
        }
        function z(e2) {
          return "%" + ("00" + e2.toString(16).toUpperCase()).slice(-2);
        }
        function U(e2) {
          for (var t2 = function(e3) {
            return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
          }, r2 = new Uint8Array(e2.length), n2 = 0, i2 = 0; i2 < e2.length; i2++) {
            var o2 = e2[i2];
            if (37 !== o2)
              r2[n2] = o2, n2++;
            else if (37 === o2 && i2 >= e2.length - 2)
              r2[n2] = o2, n2++;
            else if (37 !== o2 || t2(e2[i2 + 1]) && t2(e2[i2 + 2])) {
              var s2 = parseInt(a.utf8Decode(Uint8Array.of(e2[i2 + 1], e2[i2 + 2])), 16);
              r2[n2] = s2, n2++, i2 += 2;
            } else
              r2[n2] = o2, n2++;
          }
          return r2.subarray(0, n2);
        }
        function G(e2) {
          return U(a.utf8Encode(e2));
        }
        function X(e2, t2) {
          var r2, i2;
          if (!t2.test(e2))
            return e2;
          var o2 = a.utf8Encode(e2), s2 = "";
          try {
            for (var u2 = n(o2), l2 = u2.next(); !l2.done; l2 = u2.next()) {
              s2 += z(l2.value);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              l2 && !l2.done && (i2 = u2.return) && i2.call(u2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return s2;
        }
        function q(e2) {
          var t2, r2, i2, o2, s2 = [], u2 = [];
          try {
            for (var l2 = n(e2), c2 = l2.next(); !c2.done; c2 = l2.next()) {
              var h2 = c2.value;
              38 === h2 ? (s2.push(Uint8Array.from(u2)), u2 = []) : u2.push(h2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              c2 && !c2.done && (r2 = l2.return) && r2.call(l2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          0 !== u2.length && s2.push(Uint8Array.from(u2));
          var p2 = [];
          try {
            for (var f2 = n(s2), d2 = f2.next(); !d2.done; d2 = f2.next()) {
              var m2 = d2.value;
              if (0 !== m2.length) {
                for (var y2 = m2.indexOf(61), v2 = -1 !== y2 ? m2.slice(0, y2) : m2, _2 = -1 !== y2 ? m2.slice(y2 + 1) : new Uint8Array(), g2 = 0; g2 < v2.length; g2++)
                  43 === v2[g2] && (v2[g2] = 32);
                for (g2 = 0; g2 < _2.length; g2++)
                  43 === _2[g2] && (_2[g2] = 32);
                var b2 = a.utf8Decode(v2), x2 = a.utf8Decode(_2);
                p2.push([b2, x2]);
              }
            }
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              d2 && !d2.done && (o2 = f2.return) && o2.call(f2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return p2;
        }
        function W(e2) {
          var t2, r2, i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value;
              i2 += 32 === s2 ? "+" : 42 === s2 || 45 === s2 || 46 === s2 || s2 >= 48 && s2 <= 57 || s2 >= 65 && s2 <= 90 || 95 === s2 || s2 >= 97 && s2 <= 122 ? String.fromCodePoint(s2) : z(s2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          return i2;
        }
        function H(e2, t2) {
          void 0 === t2 && (t2 = false);
          var r2 = l.domainToASCII(e2);
          return "" === r2 ? (v("Invalid domain name."), null) : r2;
        }
        t.setValidationErrorCallback = function(e2) {
          o = e2;
        }, t.newURL = _, t.isSpecialScheme = g, t.isSpecial = b, t.defaultPort = x, t.includesCredentials = w, t.cannotHaveAUsernamePasswordPort = function(e2) {
          return null === e2.host || "" === e2.host || e2._cannotBeABaseURLFlag || "file" === e2.scheme;
        }, t.urlSerializer = E, t.hostSerializer = D, t.iPv4Serializer = S, t.iPv6Serializer = C, t.urlParser = function(e2, t2, r2) {
          var n2 = A(e2, t2, r2);
          return null === n2 ? null : ("blob" !== n2.scheme || (n2._blobURLEntry = null), n2);
        }, t.basicURLParser = A, t.setTheUsername = function(e2, t2) {
          var r2, i2, o2 = "";
          try {
            for (var a2 = n(t2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              o2 += X(s2.value, d);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          e2.username = o2;
        }, t.setThePassword = function(e2, t2) {
          var r2, i2, o2 = "";
          try {
            for (var a2 = n(t2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              o2 += X(s2.value, d);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          e2.password = o2;
        }, t.isSingleDotPathSegment = N, t.isDoubleDotPathSegment = T, t.shorten = O, t.isNormalizedWindowsDriveLetter = F, t.isWindowsDriveLetter = k, t.startsWithAWindowsDriveLetter = P, t.hostParser = I, t.iPv4NumberParser = L, t.iPv4Parser = M, t.iPv6Parser = B, t.opaqueHostParser = j, t.resolveABlobURL = R, t.percentEncode = z, t.percentDecode = U, t.stringPercentDecode = G, t.utf8PercentEncode = X, t.hostEquals = function(e2, t2) {
          return e2 === t2;
        }, t.urlEquals = function(e2, t2, r2) {
          return void 0 === r2 && (r2 = false), E(e2, r2) === E(t2, r2);
        }, t.urlEncodedStringParser = function(e2) {
          return q(a.utf8Encode(e2));
        }, t.urlEncodedParser = q, t.urlEncodedByteSerializer = W, t.urlEncodedSerializer = function(e2, t2) {
          var r2, i2;
          if ("UTF-8" !== (void 0 === t2 || "replacement" === t2 || "UTF-16BE" === t2 || "UTF-16LE" === t2 ? "UTF-8" : t2).toUpperCase())
            throw new Error("Only UTF-8 encoding is supported.");
          var o2 = "";
          try {
            for (var s2 = n(e2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
              var l2 = u2.value, c2 = W(a.utf8Encode(l2[0])), h2 = l2[1];
              h2 = W(a.utf8Encode(h2)), "" !== o2 && (o2 += "&"), o2 += c2 + "=" + h2;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return o2;
        }, t.origin = function e2(t2) {
          switch (t2.scheme) {
            case "blob":
              t2._blobURLEntry;
              var r2 = A(t2.path[0]);
              return null === r2 ? s.OpaqueOrigin : e2(r2);
            case "ftp":
            case "http":
            case "https":
            case "ws":
            case "wss":
              return [t2.scheme, null === t2.host ? "" : t2.host, t2.port, null];
            case "file":
            default:
              return s.OpaqueOrigin;
          }
        }, t.domainToASCII = H, t.domainToUnicode = function(e2, t2) {
          void 0 === t2 && (t2 = false);
          var r2 = l.domainToUnicode(e2);
          return "" === r2 && v("Invalid domain name."), r2;
        }, t.asciiSerializationOfAnOrigin = function(e2) {
          if ("" === e2[0] && "" === e2[1] && null === e2[2] && null === e2[3])
            return "null";
          var t2 = e2[0] + "://" + D(e2[1]);
          return null !== e2[2] && (t2 += ":" + e2[2].toString()), t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(0), i = function() {
          function e2() {
            this._signal = n.create_abortSignal();
          }
          return Object.defineProperty(e2.prototype, "signal", { get: function() {
            return this._signal;
          }, enumerable: true, configurable: true }), e2.prototype.abort = function() {
            n.abort_signalAbort(this._signal);
          }, e2;
        }();
        t.AbortControllerImpl = i;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(70), a = r(0), s = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this;
            return t3._abortedFlag = false, t3._abortAlgorithms = /* @__PURE__ */ new Set(), t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "aborted", { get: function() {
            return this._abortedFlag;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "onabort", { get: function() {
            return a.event_getterEventHandlerIDLAttribute(this, "onabort");
          }, set: function(e3) {
            a.event_setterEventHandlerIDLAttribute(this, "onabort", e3);
          }, enumerable: true, configurable: true }), t2._create = function() {
            return new t2();
          }, t2;
        }(o.EventTargetImpl);
        t.AbortSignalImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(34), s = r(12), u = function(e2) {
          function t2(t3, r2, n2) {
            var i2 = e2.call(this) || this;
            return i2._name = "", i2._publicId = "", i2._systemId = "", i2._name = t3, i2._publicId = r2, i2._systemId = n2, i2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "name", { get: function() {
            return this._name;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "publicId", { get: function() {
            return this._publicId;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "systemId", { get: function() {
            return this._systemId;
          }, enumerable: true, configurable: true }), t2.prototype.before = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.after = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.replaceWith = function() {
            for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
              e3[t3] = arguments[t3];
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2.prototype.remove = function() {
            throw new Error("Mixin: ChildNode not implemented.");
          }, t2._create = function(e3, r2, n2, i2) {
            void 0 === n2 && (n2 = ""), void 0 === i2 && (i2 = "");
            var o2 = new t2(r2, n2, i2);
            return o2._nodeDocument = e3, o2;
          }, t2;
        }(a.NodeImpl);
        t.DocumentTypeImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.DocumentType);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(100), a = r(2), s = r(0), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this) || this;
            return n2._host = t3, n2._mode = r2, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "mode", { get: function() {
            return this._mode;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "host", { get: function() {
            return this._host;
          }, enumerable: true, configurable: true }), t2.prototype._getTheParent = function(e3) {
            return e3._composedFlag || a.isEmpty(e3._path) || s.tree_rootNode(e3._path[0].invocationTarget) !== this ? this._host : null;
          }, t2._create = function(e3, r2) {
            return new t2(r2, "closed");
          }, t2;
        }(o.DocumentFragmentImpl);
        t.ShadowRootImpl = u;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(34), s = r(0), u = r(12), l = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this) || this;
            return r2._namespace = null, r2._namespacePrefix = null, r2._element = null, r2._value = "", r2._localName = t3, r2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "ownerElement", { get: function() {
            return this._element;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "namespaceURI", { get: function() {
            return this._namespace;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "prefix", { get: function() {
            return this._namespacePrefix;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "localName", { get: function() {
            return this._localName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "name", { get: function() {
            return this._qualifiedName;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "value", { get: function() {
            return this._value;
          }, set: function(e3) {
            s.attr_setAnExistingAttributeValue(this, e3);
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "_qualifiedName", { get: function() {
            return null !== this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2) {
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(a.NodeImpl);
        t.AttrImpl = l, u.idl_defineConst(l.prototype, "_nodeType", o.NodeType.Attribute), u.idl_defineConst(l.prototype, "specified", true);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(101), a = r(1), s = r(12), u = function(e2) {
          function t2(t3) {
            return e2.call(this, t3) || this;
          }
          return i(t2, e2), t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(o.TextImpl);
        t.CDATASectionImpl = u, s.idl_defineConst(u.prototype, "_nodeType", a.NodeType.CData);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(71), s = r(12), u = function(e2) {
          function t2(t3) {
            return void 0 === t3 && (t3 = ""), e2.call(this, t3) || this;
          }
          return i(t2, e2), t2._create = function(e3, r2) {
            void 0 === r2 && (r2 = "");
            var n2 = new t2(r2);
            return n2._nodeDocument = e3, n2;
          }, t2;
        }(a.CharacterDataImpl);
        t.CommentImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.Comment);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(71), s = r(12), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, r2) || this;
            return n2._target = t3, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "target", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), t2._create = function(e3, r2, n2) {
            var i2 = new t2(r2, n2);
            return i2._nodeDocument = e3, i2;
          }, t2;
        }(a.CharacterDataImpl);
        t.ProcessingInstructionImpl = u, s.idl_defineConst(u.prototype, "_nodeType", o.NodeType.ProcessingInstruction);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(7), i = r(0), o = r(3), a = r(2), s = function() {
          function e2(e3, t2) {
            return this._live = true, this._root = e3, this._filter = t2, new Proxy(this, this);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            for (var e3 = this, t2 = 0, r2 = i.tree_getFirstDescendantNode(this._root, false, false, function(t3) {
              return o.Guard.isElementNode(t3) && e3._filter(t3);
            }); null !== r2; )
              t2++, r2 = i.tree_getNextDescendantNode(this._root, r2, false, false, function(t3) {
                return o.Guard.isElementNode(t3) && e3._filter(t3);
              });
            return t2;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            for (var t2 = this, r2 = 0, n2 = i.tree_getFirstDescendantNode(this._root, false, false, function(e4) {
              return o.Guard.isElementNode(e4) && t2._filter(e4);
            }); null !== n2; ) {
              if (r2 === e3)
                return n2;
              r2++, n2 = i.tree_getNextDescendantNode(this._root, n2, false, false, function(e4) {
                return o.Guard.isElementNode(e4) && t2._filter(e4);
              });
            }
            return null;
          }, e2.prototype.namedItem = function(e3) {
            var t2 = this;
            if ("" === e3)
              return null;
            for (var r2 = i.tree_getFirstDescendantNode(this._root, false, false, function(e4) {
              return o.Guard.isElementNode(e4) && t2._filter(e4);
            }); null != r2; ) {
              if (r2._uniqueIdentifier === e3)
                return r2;
              if (r2._namespace === n.namespace.HTML)
                for (var a2 = 0; a2 < r2._attributeList.length; a2++) {
                  var s2 = r2._attributeList[a2];
                  if ("name" === s2._localName && null === s2._namespace && null === s2._namespacePrefix && s2._value === e3)
                    return r2;
                }
              r2 = i.tree_getNextDescendantNode(this._root, r2, false, false, function(e4) {
                return o.Guard.isElementNode(e4) && t2._filter(e4);
              });
            }
            return null;
          }, e2.prototype[Symbol.iterator] = function() {
            var e3 = this._root, t2 = this._filter, r2 = i.tree_getFirstDescendantNode(e3, false, false, function(e4) {
              return o.Guard.isElementNode(e4) && t2(e4);
            });
            return { next: function() {
              if (null === r2)
                return { done: true, value: null };
              var n2 = { done: false, value: r2 };
              return r2 = i.tree_getNextDescendantNode(e3, r2, false, false, function(e4) {
                return o.Guard.isElementNode(e4) && t2(e4);
              }), n2;
            } };
          }, e2.prototype.get = function(t2, r2, n2) {
            if (!a.isString(r2) || -1 !== e2.reservedNames.indexOf(r2))
              return Reflect.get(t2, r2, n2);
            var i2 = Number(r2);
            return isNaN(i2) ? t2.namedItem(r2) || void 0 : t2.item(i2) || void 0;
          }, e2.prototype.set = function(t2, r2, n2, o2) {
            if (!a.isString(r2) || -1 !== e2.reservedNames.indexOf(r2))
              return Reflect.set(t2, r2, n2, o2);
            var s2 = Number(r2), u = isNaN(s2) ? t2.namedItem(r2) || void 0 : t2.item(s2) || void 0;
            return !(!u || !u._parent) && (i.mutation_replace(u, n2, u._parent), true);
          }, e2._create = function(t2, r2) {
            return void 0 === r2 && (r2 = function() {
              return true;
            }), new e2(t2, r2);
          }, e2.reservedNames = ["_root", "_live", "_filter", "length", "item", "namedItem", "get", "set"], e2;
        }();
        t.HTMLCollectionImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(2), a = r(0), s = function() {
          function e2(e3) {
            return this._live = true, this._filter = null, this._length = 0, this._root = e3, new Proxy(this, this);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._root._children.size;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            if (e3 < 0 || e3 > this.length - 1)
              return null;
            if (e3 < this.length / 2) {
              for (var t2 = 0, r2 = this._root._firstChild; null !== r2 && t2 !== e3; )
                r2 = r2._nextSibling, t2++;
              return r2;
            }
            for (t2 = this.length - 1, r2 = this._root._lastChild; null !== r2 && t2 !== e3; )
              r2 = r2._previousSibling, t2--;
            return r2;
          }, e2.prototype.keys = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = function() {
              var e4 = 0;
              return { next: function() {
                return e4 === this.length ? { done: true, value: null } : { done: false, value: e4++ };
              }.bind(this) };
            }.bind(this), e3;
          }, e2.prototype.values = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = function() {
              var e4 = this[Symbol.iterator]();
              return { next: function() {
                return e4.next();
              } };
            }.bind(this), e3;
          }, e2.prototype.entries = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = function() {
              var e4 = this[Symbol.iterator](), t2 = 0;
              return { next: function() {
                var r2 = e4.next();
                return r2.done ? { done: true, value: null } : { done: false, value: [t2++, r2.value] };
              } };
            }.bind(this), e3;
          }, e2.prototype[Symbol.iterator] = function() {
            return this._root._children[Symbol.iterator]();
          }, e2.prototype.forEach = function(e3, t2) {
            var r2, o2;
            void 0 === t2 && (t2 = i.dom.window);
            var a2 = 0;
            try {
              for (var s2 = n(this._root._children), u = s2.next(); !u.done; u = s2.next()) {
                var l = u.value;
                e3.call(t2, l, a2++, this);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u && !u.done && (o2 = s2.return) && o2.call(s2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, e2.prototype.get = function(e3, t2, r2) {
            if (!o.isString(t2))
              return Reflect.get(e3, t2, r2);
            var n2 = Number(t2);
            return isNaN(n2) ? Reflect.get(e3, t2, r2) : e3.item(n2) || void 0;
          }, e2.prototype.set = function(e3, t2, r2, n2) {
            if (!o.isString(t2))
              return Reflect.set(e3, t2, r2, n2);
            var i2 = Number(t2);
            if (isNaN(i2))
              return Reflect.set(e3, t2, r2, n2);
            var s2 = e3.item(i2) || void 0;
            return !!s2 && (!!s2._parent && (a.mutation_replace(s2, r2, s2._parent), true));
          }, e2._create = function(t2) {
            return new e2(t2);
          }, e2;
        }();
        t.NodeListImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(2), a = function() {
          function e2(e3) {
            return this._live = false, this._items = [], this._length = 0, this._root = e3, this._items = [], this._filter = function(e4) {
              return true;
            }, new Proxy(this, this);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._items.length;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            return e3 < 0 || e3 > this.length - 1 ? null : this._items[e3];
          }, e2.prototype.keys = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = function() {
              var e4 = 0;
              return { next: function() {
                return e4 === this.length ? { done: true, value: null } : { done: false, value: e4++ };
              }.bind(this) };
            }.bind(this), e3;
          }, e2.prototype.values = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = function() {
              var e4 = this[Symbol.iterator]();
              return { next: function() {
                return e4.next();
              } };
            }.bind(this), e3;
          }, e2.prototype.entries = function() {
            var e3;
            return (e3 = {})[Symbol.iterator] = function() {
              var e4 = this[Symbol.iterator](), t2 = 0;
              return { next: function() {
                var r2 = e4.next();
                return r2.done ? { done: true, value: null } : { done: false, value: [t2++, r2.value] };
              } };
            }.bind(this), e3;
          }, e2.prototype[Symbol.iterator] = function() {
            var e3 = this._items[Symbol.iterator]();
            return { next: function() {
              return e3.next();
            } };
          }, e2.prototype.forEach = function(e3, t2) {
            var r2, o2;
            void 0 === t2 && (t2 = i.dom.window);
            var a2 = 0;
            try {
              for (var s = n(this._items), u = s.next(); !u.done; u = s.next()) {
                var l = u.value;
                e3.call(t2, l, a2++, this);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u && !u.done && (o2 = s.return) && o2.call(s);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }, e2.prototype.get = function(e3, t2, r2) {
            if (!o.isString(t2))
              return Reflect.get(e3, t2, r2);
            var n2 = Number(t2);
            return isNaN(n2) ? Reflect.get(e3, t2, r2) : e3._items[n2] || void 0;
          }, e2.prototype.set = function(e3, t2, r2, n2) {
            if (!o.isString(t2))
              return Reflect.set(e3, t2, r2, n2);
            var i2 = Number(t2);
            return isNaN(i2) ? Reflect.set(e3, t2, r2, n2) : i2 >= 0 && i2 < e3._items.length && (e3._items[i2] = r2, true);
          }, e2._create = function(t2, r2) {
            var n2 = new e2(t2);
            return n2._items = r2, n2;
          }, e2;
        }();
        t.NodeListStaticImpl = a;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(9), a = r(0), s = function(e2) {
          function t2(r2) {
            var n2 = e2.call(this) || this;
            return n2._element = r2, Object.setPrototypeOf(n2, t2.prototype), n2;
          }
          return i(t2, e2), t2.prototype._asArray = function() {
            return this;
          }, t2.prototype.item = function(e3) {
            return this[e3] || null;
          }, t2.prototype.getNamedItem = function(e3) {
            return a.element_getAnAttributeByName(e3, this._element);
          }, t2.prototype.getNamedItemNS = function(e3, t3) {
            return a.element_getAnAttributeByNamespaceAndLocalName(e3 || "", t3, this._element);
          }, t2.prototype.setNamedItem = function(e3) {
            return a.element_setAnAttribute(e3, this._element);
          }, t2.prototype.setNamedItemNS = function(e3) {
            return a.element_setAnAttribute(e3, this._element);
          }, t2.prototype.removeNamedItem = function(e3) {
            var t3 = a.element_removeAnAttributeByName(e3, this._element);
            if (null === t3)
              throw new o.NotFoundError();
            return t3;
          }, t2.prototype.removeNamedItemNS = function(e3, t3) {
            var r2 = a.element_removeAnAttributeByNamespaceAndLocalName(e3 || "", t3, this._element);
            if (null === r2)
              throw new o.NotFoundError();
            return r2;
          }, t2._create = function(e3) {
            return new t2(e3);
          }, t2;
        }(Array);
        t.NamedNodeMapImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(6), s = r(1), u = r(102), l = r(9), c = r(0), h = r(12), p = r(3), f = function(e2) {
          function t2() {
            var t3 = e2.call(this) || this, r2 = a.dom.window._associatedDocument;
            return t3._start = [r2, 0], t3._end = [r2, 0], a.dom.rangeList.add(t3), t3;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "commonAncestorContainer", { get: function() {
            for (var e3 = this._start[0]; !c.tree_isAncestorOf(this._end[0], e3, true); ) {
              if (null === e3._parent)
                throw new Error("Parent node  is null.");
              e3 = e3._parent;
            }
            return e3;
          }, enumerable: true, configurable: true }), t2.prototype.setStart = function(e3, t3) {
            c.range_setTheStart(this, e3, t3);
          }, t2.prototype.setEnd = function(e3, t3) {
            c.range_setTheEnd(this, e3, t3);
          }, t2.prototype.setStartBefore = function(e3) {
            var t3 = e3._parent;
            if (null === t3)
              throw new l.InvalidNodeTypeError();
            c.range_setTheStart(this, t3, c.tree_index(e3));
          }, t2.prototype.setStartAfter = function(e3) {
            var t3 = e3._parent;
            if (null === t3)
              throw new l.InvalidNodeTypeError();
            c.range_setTheStart(this, t3, c.tree_index(e3) + 1);
          }, t2.prototype.setEndBefore = function(e3) {
            var t3 = e3._parent;
            if (null === t3)
              throw new l.InvalidNodeTypeError();
            c.range_setTheEnd(this, t3, c.tree_index(e3));
          }, t2.prototype.setEndAfter = function(e3) {
            var t3 = e3._parent;
            if (null === t3)
              throw new l.InvalidNodeTypeError();
            c.range_setTheEnd(this, t3, c.tree_index(e3) + 1);
          }, t2.prototype.collapse = function(e3) {
            e3 ? this._end = this._start : this._start = this._end;
          }, t2.prototype.selectNode = function(e3) {
            c.range_select(e3, this);
          }, t2.prototype.selectNodeContents = function(e3) {
            if (p.Guard.isDocumentTypeNode(e3))
              throw new l.InvalidNodeTypeError();
            var t3 = c.tree_nodeLength(e3);
            this._start = [e3, 0], this._end = [e3, t3];
          }, t2.prototype.compareBoundaryPoints = function(e3, t3) {
            if (e3 !== s.HowToCompare.StartToStart && e3 !== s.HowToCompare.StartToEnd && e3 !== s.HowToCompare.EndToEnd && e3 !== s.HowToCompare.EndToStart)
              throw new l.NotSupportedError();
            if (c.range_root(this) !== c.range_root(t3))
              throw new l.WrongDocumentError();
            var r2, n2;
            switch (e3) {
              case s.HowToCompare.StartToStart:
                r2 = this._start, n2 = t3._start;
                break;
              case s.HowToCompare.StartToEnd:
                r2 = this._end, n2 = t3._start;
                break;
              case s.HowToCompare.EndToEnd:
                r2 = this._end, n2 = t3._end;
                break;
              case s.HowToCompare.EndToStart:
                r2 = this._start, n2 = t3._end;
                break;
              default:
                throw new l.NotSupportedError();
            }
            var i2 = c.boundaryPoint_position(r2, n2);
            return i2 === s.BoundaryPosition.Before ? -1 : i2 === s.BoundaryPosition.After ? 1 : 0;
          }, t2.prototype.deleteContents = function() {
            var e3, t3, r2, n2;
            if (!c.range_collapsed(this)) {
              var i2 = this._startNode, a2 = this._startOffset, s2 = this._endNode, u2 = this._endOffset;
              if (i2 === s2 && p.Guard.isCharacterDataNode(i2))
                c.characterData_replaceData(i2, a2, u2 - a2, "");
              else {
                var l2, h2, f2 = [];
                try {
                  for (var d = o(c.range_getContainedNodes(this)), m = d.next(); !m.done; m = d.next()) {
                    var y = (b = m.value)._parent;
                    null !== y && c.range_isContained(y, this) || f2.push(b);
                  }
                } catch (t4) {
                  e3 = { error: t4 };
                } finally {
                  try {
                    m && !m.done && (t3 = d.return) && t3.call(d);
                  } finally {
                    if (e3)
                      throw e3.error;
                  }
                }
                if (c.tree_isAncestorOf(s2, i2, true))
                  l2 = i2, h2 = a2;
                else {
                  for (var v = i2; null !== v._parent && !c.tree_isAncestorOf(s2, v._parent, true); )
                    v = v._parent;
                  if (null === v._parent)
                    throw new Error("Parent node is null.");
                  l2 = v._parent, h2 = c.tree_index(v) + 1;
                }
                p.Guard.isCharacterDataNode(i2) && c.characterData_replaceData(i2, a2, c.tree_nodeLength(i2) - a2, "");
                try {
                  for (var _ = o(f2), g = _.next(); !g.done; g = _.next()) {
                    var b;
                    (b = g.value)._parent && c.mutation_remove(b, b._parent);
                  }
                } catch (e4) {
                  r2 = { error: e4 };
                } finally {
                  try {
                    g && !g.done && (n2 = _.return) && n2.call(_);
                  } finally {
                    if (r2)
                      throw r2.error;
                  }
                }
                p.Guard.isCharacterDataNode(s2) && c.characterData_replaceData(s2, 0, u2, ""), this._start = [l2, h2], this._end = [l2, h2];
              }
            }
          }, t2.prototype.extractContents = function() {
            return c.range_extract(this);
          }, t2.prototype.cloneContents = function() {
            return c.range_cloneTheContents(this);
          }, t2.prototype.insertNode = function(e3) {
            return c.range_insert(e3, this);
          }, t2.prototype.surroundContents = function(e3) {
            var t3, r2;
            try {
              for (var n2 = o(c.range_getPartiallyContainedNodes(this)), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                var a2 = i2.value;
                if (!p.Guard.isTextNode(a2))
                  throw new l.InvalidStateError();
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                i2 && !i2.done && (r2 = n2.return) && r2.call(n2);
              } finally {
                if (t3)
                  throw t3.error;
              }
            }
            if (p.Guard.isDocumentNode(e3) || p.Guard.isDocumentTypeNode(e3) || p.Guard.isDocumentFragmentNode(e3))
              throw new l.InvalidNodeTypeError();
            var s2 = c.range_extract(this);
            0 !== e3._children.size && c.mutation_replaceAll(null, e3), c.range_insert(e3, this), c.mutation_append(s2, e3), c.range_select(e3, this);
          }, t2.prototype.cloneRange = function() {
            return c.create_range(this._start, this._end);
          }, t2.prototype.detach = function() {
            a.dom.rangeList.delete(this);
          }, t2.prototype.isPointInRange = function(e3, t3) {
            if (c.tree_rootNode(e3) !== c.range_root(this))
              return false;
            if (p.Guard.isDocumentTypeNode(e3))
              throw new l.InvalidNodeTypeError();
            if (t3 > c.tree_nodeLength(e3))
              throw new l.IndexSizeError();
            var r2 = [e3, t3];
            return c.boundaryPoint_position(r2, this._start) !== s.BoundaryPosition.Before && c.boundaryPoint_position(r2, this._end) !== s.BoundaryPosition.After;
          }, t2.prototype.comparePoint = function(e3, t3) {
            if (c.tree_rootNode(e3) !== c.range_root(this))
              throw new l.WrongDocumentError();
            if (p.Guard.isDocumentTypeNode(e3))
              throw new l.InvalidNodeTypeError();
            if (t3 > c.tree_nodeLength(e3))
              throw new l.IndexSizeError();
            var r2 = [e3, t3];
            return c.boundaryPoint_position(r2, this._start) === s.BoundaryPosition.Before ? -1 : c.boundaryPoint_position(r2, this._end) === s.BoundaryPosition.After ? 1 : 0;
          }, t2.prototype.intersectsNode = function(e3) {
            if (c.tree_rootNode(e3) !== c.range_root(this))
              return false;
            var t3 = e3._parent;
            if (null === t3)
              return true;
            var r2 = c.tree_index(e3);
            return c.boundaryPoint_position([t3, r2], this._end) === s.BoundaryPosition.Before && c.boundaryPoint_position([t3, r2 + 1], this._start) === s.BoundaryPosition.After;
          }, t2.prototype.toString = function() {
            var e3, t3, r2 = "";
            if (this._startNode === this._endNode && p.Guard.isTextNode(this._startNode))
              return this._startNode._data.substring(this._startOffset, this._endOffset);
            p.Guard.isTextNode(this._startNode) && (r2 += this._startNode._data.substring(this._startOffset));
            try {
              for (var n2 = o(c.range_getContainedNodes(this)), i2 = n2.next(); !i2.done; i2 = n2.next()) {
                var a2 = i2.value;
                p.Guard.isTextNode(a2) && (r2 += a2._data);
              }
            } catch (t4) {
              e3 = { error: t4 };
            } finally {
              try {
                i2 && !i2.done && (t3 = n2.return) && t3.call(n2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            return p.Guard.isTextNode(this._endNode) && (r2 += this._endNode._data.substring(0, this._endOffset)), r2;
          }, t2._create = function(e3, r2) {
            var n2 = new t2();
            return e3 && (n2._start = e3), r2 && (n2._end = r2), n2;
          }, t2.START_TO_START = 0, t2.START_TO_END = 1, t2.END_TO_END = 2, t2.END_TO_START = 3, t2;
        }(u.AbstractRangeImpl);
        t.RangeImpl = f, h.idl_defineConst(f.prototype, "START_TO_START", 0), h.idl_defineConst(f.prototype, "START_TO_END", 1), h.idl_defineConst(f.prototype, "END_TO_END", 2), h.idl_defineConst(f.prototype, "END_TO_START", 3);
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(103), a = r(0), s = function(e2) {
          function t2(t3, r2, n2) {
            var i2 = e2.call(this, t3) || this;
            return i2._iteratorCollection = void 0, i2._reference = r2, i2._pointerBeforeReference = n2, a.nodeIterator_iteratorList().add(i2), i2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "referenceNode", { get: function() {
            return this._reference;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "pointerBeforeReferenceNode", { get: function() {
            return this._pointerBeforeReference;
          }, enumerable: true, configurable: true }), t2.prototype.nextNode = function() {
            return a.nodeIterator_traverse(this, true);
          }, t2.prototype.previousNode = function() {
            return a.nodeIterator_traverse(this, false);
          }, t2.prototype.detach = function() {
            a.nodeIterator_iteratorList().delete(this);
          }, t2._create = function(e3, r2, n2) {
            return new t2(e3, r2, n2);
          }, t2;
        }(o.TraverserImpl);
        t.NodeIteratorImpl = s;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(1), a = r(103), s = r(0), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._current = r2, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "currentNode", { get: function() {
            return this._current;
          }, set: function(e3) {
            this._current = e3;
          }, enumerable: true, configurable: true }), t2.prototype.parentNode = function() {
            for (var e3 = this._current; null !== e3 && e3 !== this._root; )
              if (null !== (e3 = e3._parent) && s.traversal_filter(this, e3) === o.FilterResult.Accept)
                return this._current = e3, e3;
            return null;
          }, t2.prototype.firstChild = function() {
            return s.treeWalker_traverseChildren(this, true);
          }, t2.prototype.lastChild = function() {
            return s.treeWalker_traverseChildren(this, false);
          }, t2.prototype.nextSibling = function() {
            return s.treeWalker_traverseSiblings(this, true);
          }, t2.prototype.previousNode = function() {
            for (var e3 = this._current; e3 !== this._root; ) {
              for (var t3 = e3._previousSibling; t3; ) {
                e3 = t3;
                for (var r2 = s.traversal_filter(this, e3); r2 !== o.FilterResult.Reject && e3._lastChild; )
                  e3 = e3._lastChild, r2 = s.traversal_filter(this, e3);
                if (r2 === o.FilterResult.Accept)
                  return this._current = e3, e3;
                t3 = e3._previousSibling;
              }
              if (e3 === this._root || null === e3._parent)
                return null;
              if (e3 = e3._parent, s.traversal_filter(this, e3) === o.FilterResult.Accept)
                return this._current = e3, e3;
            }
            return null;
          }, t2.prototype.previousSibling = function() {
            return s.treeWalker_traverseSiblings(this, false);
          }, t2.prototype.nextNode = function() {
            for (var e3 = this._current, t3 = o.FilterResult.Accept; ; ) {
              for (; t3 !== o.FilterResult.Reject && e3._firstChild; )
                if (e3 = e3._firstChild, (t3 = s.traversal_filter(this, e3)) === o.FilterResult.Accept)
                  return this._current = e3, e3;
              for (var r2 = null, n2 = e3; null !== n2; ) {
                if (n2 === this._root)
                  return null;
                if (null !== (r2 = n2._nextSibling)) {
                  e3 = r2;
                  break;
                }
                n2 = n2._parent;
              }
              if ((t3 = s.traversal_filter(this, e3)) === o.FilterResult.Accept)
                return this._current = e3, e3;
            }
          }, t2._create = function(e3, r2) {
            return new t2(e3, r2);
          }, t2;
        }(a.TraverserImpl);
        t.TreeWalkerImpl = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = r(12), o = function() {
          function e2() {
          }
          return e2.prototype.acceptNode = function(e3) {
            return n.FilterResult.Accept;
          }, e2._create = function() {
            return new e2();
          }, e2.FILTER_ACCEPT = 1, e2.FILTER_REJECT = 2, e2.FILTER_SKIP = 3, e2.SHOW_ALL = 4294967295, e2.SHOW_ELEMENT = 1, e2.SHOW_ATTRIBUTE = 2, e2.SHOW_TEXT = 4, e2.SHOW_CDATA_SECTION = 8, e2.SHOW_ENTITY_REFERENCE = 16, e2.SHOW_ENTITY = 32, e2.SHOW_PROCESSING_INSTRUCTION = 64, e2.SHOW_COMMENT = 128, e2.SHOW_DOCUMENT = 256, e2.SHOW_DOCUMENT_TYPE = 512, e2.SHOW_DOCUMENT_FRAGMENT = 1024, e2.SHOW_NOTATION = 2048, e2;
        }();
        t.NodeFilterImpl = o, i.idl_defineConst(o.prototype, "FILTER_ACCEPT", 1), i.idl_defineConst(o.prototype, "FILTER_REJECT", 2), i.idl_defineConst(o.prototype, "FILTER_SKIP", 3), i.idl_defineConst(o.prototype, "SHOW_ALL", 4294967295), i.idl_defineConst(o.prototype, "SHOW_ELEMENT", 1), i.idl_defineConst(o.prototype, "SHOW_ATTRIBUTE", 2), i.idl_defineConst(o.prototype, "SHOW_TEXT", 4), i.idl_defineConst(o.prototype, "SHOW_CDATA_SECTION", 8), i.idl_defineConst(o.prototype, "SHOW_ENTITY_REFERENCE", 16), i.idl_defineConst(o.prototype, "SHOW_ENTITY", 32), i.idl_defineConst(o.prototype, "SHOW_PROCESSING_INSTRUCTION", 64), i.idl_defineConst(o.prototype, "SHOW_COMMENT", 128), i.idl_defineConst(o.prototype, "SHOW_DOCUMENT", 256), i.idl_defineConst(o.prototype, "SHOW_DOCUMENT_TYPE", 512), i.idl_defineConst(o.prototype, "SHOW_DOCUMENT_FRAGMENT", 1024), i.idl_defineConst(o.prototype, "SHOW_NOTATION", 2048);
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3, t2, r2, n2, i, o, a, s, u) {
            this._type = e3, this._target = t2, this._addedNodes = r2, this._removedNodes = n2, this._previousSibling = i, this._nextSibling = o, this._attributeName = a, this._attributeNamespace = s, this._oldValue = u;
          }
          return Object.defineProperty(e2.prototype, "type", { get: function() {
            return this._type;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "target", { get: function() {
            return this._target;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "addedNodes", { get: function() {
            return this._addedNodes;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "removedNodes", { get: function() {
            return this._removedNodes;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "previousSibling", { get: function() {
            return this._previousSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "nextSibling", { get: function() {
            return this._nextSibling;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "attributeName", { get: function() {
            return this._attributeName;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "attributeNamespace", { get: function() {
            return this._attributeNamespace;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "oldValue", { get: function() {
            return this._oldValue;
          }, enumerable: true, configurable: true }), e2._create = function(t2, r2, n2, i, o, a, s, u, l) {
            return new e2(t2, r2, n2, i, o, a, s, u, l);
          }, e2;
        }();
        t.MutationRecordImpl = n;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(9), a = r(7), s = r(0), u = function() {
          function e2(e3, t2) {
            this._element = e3, this._attribute = t2, this._tokenSet = /* @__PURE__ */ new Set();
            var r2 = t2._localName, n2 = s.element_getAnAttributeValue(e3, r2), o2 = this;
            this._element._attributeChangeSteps.push(function(e4, t3, r3, n3, i2) {
              t3 === o2._attribute._localName && null === i2 && (n3 ? o2._tokenSet = s.orderedSet_parse(n3) : o2._tokenSet.clear());
            }), i.dom.features.steps && s.dom_runAttributeChangeSteps(e3, r2, n2, n2, null);
          }
          return Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._tokenSet.size;
          }, enumerable: true, configurable: true }), e2.prototype.item = function(e3) {
            var t2, r2, i2 = 0;
            try {
              for (var o2 = n(this._tokenSet), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s2 = a2.value;
                if (i2 === e3)
                  return s2;
                i2++;
              }
            } catch (e4) {
              t2 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
              } finally {
                if (t2)
                  throw t2.error;
              }
            }
            return null;
          }, e2.prototype.contains = function(e3) {
            return this._tokenSet.has(e3);
          }, e2.prototype.add = function() {
            for (var e3, t2, r2 = [], i2 = 0; i2 < arguments.length; i2++)
              r2[i2] = arguments[i2];
            try {
              for (var u2 = n(r2), l = u2.next(); !l.done; l = u2.next()) {
                var c = l.value;
                if ("" === c)
                  throw new o.SyntaxError("Cannot add an empty token.");
                if (a.codePoint.ASCIIWhiteSpace.test(c))
                  throw new o.InvalidCharacterError("Token cannot contain whitespace.");
                this._tokenSet.add(c);
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                l && !l.done && (t2 = u2.return) && t2.call(u2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            s.tokenList_updateSteps(this);
          }, e2.prototype.remove = function() {
            for (var e3, t2, r2 = [], i2 = 0; i2 < arguments.length; i2++)
              r2[i2] = arguments[i2];
            try {
              for (var u2 = n(r2), l = u2.next(); !l.done; l = u2.next()) {
                var c = l.value;
                if ("" === c)
                  throw new o.SyntaxError("Cannot remove an empty token.");
                if (a.codePoint.ASCIIWhiteSpace.test(c))
                  throw new o.InvalidCharacterError("Token cannot contain whitespace.");
                this._tokenSet.delete(c);
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                l && !l.done && (t2 = u2.return) && t2.call(u2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            s.tokenList_updateSteps(this);
          }, e2.prototype.toggle = function(e3, t2) {
            if (void 0 === t2 && (t2 = void 0), "" === e3)
              throw new o.SyntaxError("Cannot toggle an empty token.");
            if (a.codePoint.ASCIIWhiteSpace.test(e3))
              throw new o.InvalidCharacterError("Token cannot contain whitespace.");
            return this._tokenSet.has(e3) ? void 0 !== t2 && false !== t2 || (this._tokenSet.delete(e3), s.tokenList_updateSteps(this), false) : (void 0 === t2 || true === t2) && (this._tokenSet.add(e3), s.tokenList_updateSteps(this), true);
          }, e2.prototype.replace = function(e3, t2) {
            if ("" === e3 || "" === t2)
              throw new o.SyntaxError("Cannot replace an empty token.");
            if (a.codePoint.ASCIIWhiteSpace.test(e3) || a.codePoint.ASCIIWhiteSpace.test(t2))
              throw new o.InvalidCharacterError("Token cannot contain whitespace.");
            return !!this._tokenSet.has(e3) && (a.set.replace(this._tokenSet, e3, t2), s.tokenList_updateSteps(this), true);
          }, e2.prototype.supports = function(e3) {
            return s.tokenList_validationSteps(this, e3);
          }, Object.defineProperty(e2.prototype, "value", { get: function() {
            return s.tokenList_serializeSteps(this);
          }, set: function(e3) {
            s.element_setAnAttributeValue(this._element, this._attribute._localName, e3);
          }, enumerable: true, configurable: true }), e2.prototype[Symbol.iterator] = function() {
            var e3 = this._tokenSet[Symbol.iterator]();
            return { next: function() {
              return e3.next();
            } };
          }, e2._create = function(t2, r2) {
            return new e2(t2, r2);
          }, e2;
        }();
        t.DOMTokenListImpl = u;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(104), a = r(0), s = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3, r2) || this;
            return n2._detail = null, n2._detail = r2 && r2.detail || null, n2;
          }
          return i(t2, e2), Object.defineProperty(t2.prototype, "detail", { get: function() {
            return this._detail;
          }, enumerable: true, configurable: true }), t2.prototype.initCustomEvent = function(e3, t3, r2, n2) {
            void 0 === t3 && (t3 = false), void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = null), this._dispatchFlag || (a.event_initialize(this, e3, t3, r2), this._detail = n2);
          }, t2;
        }(o.EventImpl);
        t.CustomEventImpl = s;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(6), i = r(1), o = r(105), a = r(17);
        t.nodeIterator_traverse = function(e2, t2) {
          for (var r2 = e2._reference, n2 = e2._pointerBeforeReference; ; ) {
            if (t2)
              if (n2)
                n2 = false;
              else {
                var s = a.tree_getFollowingNode(e2._root, r2);
                if (!s)
                  return null;
                r2 = s;
              }
            else if (n2) {
              var u = a.tree_getPrecedingNode(e2.root, r2);
              if (!u)
                return null;
              r2 = u;
            } else
              n2 = true;
            if (o.traversal_filter(e2, r2) === i.FilterResult.Accept)
              break;
          }
          return e2._reference = r2, e2._pointerBeforeReference = n2, r2;
        }, t.nodeIterator_iteratorList = function() {
          return n.dom.window._iteratorList;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(9), i = r(7), o = r(174);
        function a(e2) {
          if (!o.xml_isName(e2))
            throw new n.InvalidCharacterError("Invalid XML name: " + e2);
          if (!o.xml_isQName(e2))
            throw new n.InvalidCharacterError("Invalid XML qualified name: " + e2 + ".");
        }
        t.namespace_validate = a, t.namespace_validateAndExtract = function(e2, t2) {
          e2 || (e2 = null), a(t2);
          var r2 = t2.split(":"), o2 = 2 === r2.length ? r2[0] : null, s = 2 === r2.length ? r2[1] : t2;
          if (o2 && null === e2)
            throw new n.NamespaceError("Qualified name includes a prefix but the namespace is null.");
          if ("xml" === o2 && e2 !== i.namespace.XML)
            throw new n.NamespaceError('Qualified name includes the "xml" prefix but the namespace is not the XML namespace.');
          if (e2 !== i.namespace.XMLNS && ("xmlns" === o2 || "xmlns" === t2))
            throw new n.NamespaceError('Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.');
          if (e2 === i.namespace.XMLNS && "xmlns" !== o2 && "xmlns" !== t2)
            throw new n.NamespaceError('Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.');
          return [e2, o2, s];
        }, t.namespace_extractQName = function(e2) {
          a(e2);
          var t2 = e2.split(":");
          return [2 === t2.length ? t2[0] : null, 2 === t2.length ? t2[1] : e2];
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.xml_isName = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2.charCodeAt(t2);
            if (!(r2 >= 97 && r2 <= 122 || r2 >= 65 && r2 <= 90 || 58 === r2 || 95 === r2 || r2 >= 192 && r2 <= 214 || r2 >= 216 && r2 <= 246 || r2 >= 248 && r2 <= 767 || r2 >= 880 && r2 <= 893 || r2 >= 895 && r2 <= 8191 || r2 >= 8204 && r2 <= 8205 || r2 >= 8304 && r2 <= 8591 || r2 >= 11264 && r2 <= 12271 || r2 >= 12289 && r2 <= 55295 || r2 >= 63744 && r2 <= 64975 || r2 >= 65008 && r2 <= 65533) && (0 === t2 || !(45 === r2 || 46 === r2 || r2 >= 48 && r2 <= 57 || 183 === r2 || r2 >= 768 && r2 <= 879 || r2 >= 8255 && r2 <= 8256))) {
              if (r2 >= 55296 && r2 <= 56319 && t2 < e2.length - 1) {
                var n = e2.charCodeAt(t2 + 1);
                if (n >= 56320 && n <= 57343 && (t2++, (r2 = 1024 * (r2 - 55296) + n - 56320 + 65536) >= 65536 && r2 <= 983039))
                  continue;
              }
              return false;
            }
          }
          return true;
        }, t.xml_isQName = function(e2) {
          for (var t2 = false, r2 = 0; r2 < e2.length; r2++) {
            var n = e2.charCodeAt(r2);
            if (!(n >= 97 && n <= 122 || n >= 65 && n <= 90 || 95 === n || n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) && (0 === r2 || !(45 === n || 46 === n || n >= 48 && n <= 57 || 183 === n || n >= 768 && n <= 879 || n >= 8255 && n <= 8256))) {
              if (0 === r2 || 58 !== n) {
                if (n >= 55296 && n <= 56319 && r2 < e2.length - 1) {
                  var i = e2.charCodeAt(r2 + 1);
                  if (i >= 56320 && i <= 57343 && (r2++, (n = 1024 * (n - 55296) + i - 56320 + 65536) >= 65536 && n <= 983039))
                    continue;
                }
                return false;
              }
              if (t2)
                return false;
              if (r2 === e2.length - 1)
                return false;
              t2 = true;
            }
          }
          return true;
        }, t.xml_isLegalChar = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2.charCodeAt(t2);
            if (!(9 === r2 || 10 === r2 || 13 === r2 || r2 >= 32 && r2 <= 55295 || r2 >= 57344 && r2 <= 65533)) {
              if (r2 >= 55296 && r2 <= 56319 && t2 < e2.length - 1) {
                var n = e2.charCodeAt(t2 + 1);
                if (n >= 56320 && n <= 57343 && (t2++, (r2 = 1024 * (r2 - 55296) + n - 56320 + 65536) >= 65536 && r2 <= 1114111))
                  continue;
              }
              return false;
            }
          }
          return true;
        }, t.xml_isPubidChar = function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var r2 = e2.charCodeAt(t2);
            if (!(r2 >= 97 && r2 <= 122 || r2 >= 65 && r2 <= 90 || r2 >= 39 && r2 <= 59 || 32 === r2 || 13 === r2 || 10 === r2 || r2 >= 35 && r2 <= 37 || 33 === r2 || 61 === r2 || 63 === r2 || 64 === r2 || 95 === r2))
              return false;
          }
          return true;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = r(17);
        t.boundaryPoint_position = function e2(t2, r2) {
          var o = t2[0], a = t2[1], s = r2[0], u = r2[1];
          if (console.assert(i.tree_rootNode(o) === i.tree_rootNode(s), "Boundary points must share the same root node."), o === s)
            return a === u ? n.BoundaryPosition.Equal : a < u ? n.BoundaryPosition.Before : n.BoundaryPosition.After;
          if (i.tree_isFollowing(s, o)) {
            var l = e2([s, u], [o, a]);
            if (l === n.BoundaryPosition.Before)
              return n.BoundaryPosition.After;
            if (l === n.BoundaryPosition.After)
              return n.BoundaryPosition.Before;
          }
          if (i.tree_isAncestorOf(s, o)) {
            for (var c = s; !i.tree_isChildOf(o, c); )
              null !== c._parent && (c = c._parent);
            if (i.tree_index(c) < a)
              return n.BoundaryPosition.After;
          }
          return n.BoundaryPosition.Before;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(7), s = r(29), u = r(108), l = r(30), c = r(37), h = r(52);
        t.node_stringReplaceAll = function(e2, t2) {
          var r2 = null;
          "" !== e2 && (r2 = s.create_text(t2._nodeDocument, e2)), c.mutation_replaceAll(r2, t2);
        }, t.node_clone = function e2(t2, r2, a2) {
          var u2, p, f, d, m;
          if (void 0 === r2 && (r2 = null), void 0 === a2 && (a2 = false), null === r2 && (r2 = t2._nodeDocument), o.Guard.isElementNode(t2)) {
            m = h.element_createAnElement(r2, t2._localName, t2._namespace, t2._namespacePrefix, t2._is, false);
            try {
              for (var y = n(t2._attributeList), v = y.next(); !v.done; v = y.next()) {
                var _ = e2(v.value, r2);
                h.element_append(_, m);
              }
            } catch (e3) {
              u2 = { error: e3 };
            } finally {
              try {
                v && !v.done && (p = y.return) && p.call(y);
              } finally {
                if (u2)
                  throw u2.error;
              }
            }
          } else if (o.Guard.isDocumentNode(t2)) {
            var g = s.create_document();
            g._encoding = t2._encoding, g._contentType = t2._contentType, g._URL = t2._URL, g._origin = t2._origin, g._type = t2._type, g._mode = t2._mode, m = g;
          } else if (o.Guard.isDocumentTypeNode(t2)) {
            m = s.create_documentType(r2, t2._name, t2._publicId, t2._systemId);
          } else if (o.Guard.isAttrNode(t2)) {
            var b = s.create_attr(r2, t2.localName);
            b._namespace = t2._namespace, b._namespacePrefix = t2._namespacePrefix, b._value = t2._value, m = b;
          } else
            m = o.Guard.isExclusiveTextNode(t2) ? s.create_text(r2, t2._data) : o.Guard.isCDATASectionNode(t2) ? s.create_cdataSection(r2, t2._data) : o.Guard.isCommentNode(t2) ? s.create_comment(r2, t2._data) : o.Guard.isProcessingInstructionNode(t2) ? s.create_processingInstruction(r2, t2._target, t2._data) : o.Guard.isDocumentFragmentNode(t2) ? s.create_documentFragment(r2) : Object.create(t2);
          if (o.Guard.isDocumentNode(m) ? (m._nodeDocument = m, r2 = m) : m._nodeDocument = r2, i.dom.features.steps && l.dom_runCloningSteps(m, t2, r2, a2), a2)
            try {
              for (var x = n(t2._children), w = x.next(); !w.done; w = x.next()) {
                var E = e2(w.value, r2, true);
                c.mutation_append(E, m);
              }
            } catch (e3) {
              f = { error: e3 };
            } finally {
              try {
                w && !w.done && (d = x.return) && d.call(x);
              } finally {
                if (f)
                  throw f.error;
              }
            }
          return m;
        }, t.node_equals = function e2(t2, r2) {
          var i2, a2, s2, u2;
          if (t2._nodeType !== r2._nodeType)
            return false;
          if (o.Guard.isDocumentTypeNode(t2) && o.Guard.isDocumentTypeNode(r2)) {
            if (t2._name !== r2._name || t2._publicId !== r2._publicId || t2._systemId !== r2._systemId)
              return false;
          } else if (o.Guard.isElementNode(t2) && o.Guard.isElementNode(r2)) {
            if (t2._namespace !== r2._namespace || t2._namespacePrefix !== r2._namespacePrefix || t2._localName !== r2._localName || t2._attributeList.length !== r2._attributeList.length)
              return false;
          } else if (o.Guard.isAttrNode(t2) && o.Guard.isAttrNode(r2)) {
            if (t2._namespace !== r2._namespace || t2._localName !== r2._localName || t2._value !== r2._value)
              return false;
          } else if (o.Guard.isProcessingInstructionNode(t2) && o.Guard.isProcessingInstructionNode(r2)) {
            if (t2._target !== r2._target || t2._data !== r2._data)
              return false;
          } else if (o.Guard.isCharacterDataNode(t2) && o.Guard.isCharacterDataNode(r2) && t2._data !== r2._data)
            return false;
          if (o.Guard.isElementNode(t2) && o.Guard.isElementNode(r2)) {
            var l2 = {};
            try {
              for (var c2 = n(t2._attributeList), h2 = c2.next(); !h2.done; h2 = c2.next()) {
                l2[(d = h2.value)._localName] = d;
              }
            } catch (e3) {
              i2 = { error: e3 };
            } finally {
              try {
                h2 && !h2.done && (a2 = c2.return) && a2.call(c2);
              } finally {
                if (i2)
                  throw i2.error;
              }
            }
            try {
              for (var p = n(r2._attributeList), f = p.next(); !f.done; f = p.next()) {
                var d, m = f.value;
                if (!(d = l2[m._localName]))
                  return false;
                if (!e2(d, m))
                  return false;
              }
            } catch (e3) {
              s2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (u2 = p.return) && u2.call(p);
              } finally {
                if (s2)
                  throw s2.error;
              }
            }
          }
          if (t2._children.size !== r2._children.size)
            return false;
          for (var y = t2._children[Symbol.iterator](), v = r2._children[Symbol.iterator](), _ = y.next(), g = v.next(); !_.done && !g.done; ) {
            if (!e2(_.value, g.value))
              return false;
            _ = y.next(), g = v.next();
          }
          return true;
        }, t.node_listOfElementsWithQualifiedName = function(e2, t2) {
          return "*" === e2 ? s.create_htmlCollection(t2) : "html" === t2._nodeDocument._type ? s.create_htmlCollection(t2, function(t3) {
            return t3._namespace === a.namespace.HTML && t3._qualifiedName === e2.toLowerCase() || t3._namespace !== a.namespace.HTML && t3._qualifiedName === e2;
          }) : s.create_htmlCollection(t2, function(t3) {
            return t3._qualifiedName === e2;
          });
        }, t.node_listOfElementsWithNamespace = function(e2, t2, r2) {
          return "" === e2 && (e2 = null), "*" === e2 && "*" === t2 ? s.create_htmlCollection(r2) : "*" === e2 ? s.create_htmlCollection(r2, function(e3) {
            return e3._localName === t2;
          }) : "*" === t2 ? s.create_htmlCollection(r2, function(t3) {
            return t3._namespace === e2;
          }) : s.create_htmlCollection(r2, function(r3) {
            return r3._localName === t2 && r3._namespace === e2;
          });
        }, t.node_listOfElementsWithClassNames = function(e2, t2) {
          var r2 = u.orderedSet_parse(e2);
          if (0 === r2.size)
            return s.create_htmlCollection(t2, function() {
              return false;
            });
          var n2 = "quirks" !== t2._nodeDocument._mode;
          return s.create_htmlCollection(t2, function(e3) {
            var t3 = e3.classList;
            return u.orderedSet_contains(t3._tokenSet, r2, n2);
          });
        }, t.node_locateANamespacePrefix = function e2(t2, r2) {
          if (t2._namespace === r2 && null !== t2._namespacePrefix)
            return t2._namespacePrefix;
          for (var n2 = 0; n2 < t2._attributeList.length; n2++) {
            var i2 = t2._attributeList[n2];
            if ("xmlns" === i2._namespacePrefix && i2._value === r2)
              return i2._localName;
          }
          return t2._parent && o.Guard.isElementNode(t2._parent) ? e2(t2._parent, r2) : null;
        }, t.node_locateANamespace = function e2(t2, r2) {
          if (o.Guard.isElementNode(t2)) {
            if (null !== t2._namespace && t2._namespacePrefix === r2)
              return t2._namespace;
            for (var n2 = 0; n2 < t2._attributeList.length; n2++) {
              var i2 = t2._attributeList[n2];
              if (i2._namespace === a.namespace.XMLNS && "xmlns" === i2._namespacePrefix && i2._localName === r2)
                return i2._value || null;
              if (null === r2 && i2._namespace === a.namespace.XMLNS && null === i2._namespacePrefix && "xmlns" === i2._localName)
                return i2._value || null;
            }
            return null === t2.parentElement ? null : e2(t2.parentElement, r2);
          }
          return o.Guard.isDocumentNode(t2) ? null === t2.documentElement ? null : e2(t2.documentElement, r2) : o.Guard.isDocumentTypeNode(t2) || o.Guard.isDocumentFragmentNode(t2) ? null : o.Guard.isAttrNode(t2) ? null === t2._element ? null : e2(t2._element, r2) : t2._parent && o.Guard.isElementNode(t2._parent) ? e2(t2._parent, r2) : null;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(9), s = r(29), u = r(17), l = r(107), c = r(37);
        t.text_contiguousTextNodes = function(e2, t2) {
          var r2;
          return void 0 === t2 && (t2 = false), (r2 = {})[Symbol.iterator] = function() {
            for (var r3 = e2; r3 && o.Guard.isTextNode(r3._previousSibling); )
              r3 = r3._previousSibling;
            return { next: function() {
              if (r3 && !t2 && r3 === e2 && (r3 = o.Guard.isTextNode(r3._nextSibling) ? r3._nextSibling : null), null === r3)
                return { done: true, value: null };
              var n2 = { done: false, value: r3 };
              return r3 = o.Guard.isTextNode(r3._nextSibling) ? r3._nextSibling : null, n2;
            } };
          }, r2;
        }, t.text_contiguousExclusiveTextNodes = function(e2, t2) {
          var r2;
          return void 0 === t2 && (t2 = false), (r2 = {})[Symbol.iterator] = function() {
            for (var r3 = e2; r3 && o.Guard.isExclusiveTextNode(r3._previousSibling); )
              r3 = r3._previousSibling;
            return { next: function() {
              if (r3 && !t2 && r3 === e2 && (r3 = o.Guard.isExclusiveTextNode(r3._nextSibling) ? r3._nextSibling : null), null === r3)
                return { done: true, value: null };
              var n2 = { done: false, value: r3 };
              return r3 = o.Guard.isExclusiveTextNode(r3._nextSibling) ? r3._nextSibling : null, n2;
            } };
          }, r2;
        }, t.text_descendantTextContent = function(e2) {
          for (var t2 = "", r2 = u.tree_getFirstDescendantNode(e2, false, false, function(e3) {
            return o.Guard.isTextNode(e3);
          }); null !== r2; )
            t2 += r2._data, r2 = u.tree_getNextDescendantNode(e2, r2, false, false, function(e3) {
              return o.Guard.isTextNode(e3);
            });
          return t2;
        }, t.text_split = function(e2, t2) {
          var r2, o2, h = e2._data.length;
          if (t2 > h)
            throw new a.IndexSizeError();
          var p = h - t2, f = l.characterData_substringData(e2, t2, p), d = s.create_text(e2._nodeDocument, f), m = e2._parent;
          if (null !== m) {
            c.mutation_insert(d, m, e2._nextSibling);
            try {
              for (var y = n(i.dom.rangeList), v = y.next(); !v.done; v = y.next()) {
                var _ = v.value;
                _._start[0] === e2 && _._start[1] > t2 && (_._start[0] = d, _._start[1] -= t2), _._end[0] === e2 && _._end[1] > t2 && (_._end[0] = d, _._end[1] -= t2);
                var g = u.tree_index(e2);
                _._start[0] === m && _._start[1] === g + 1 && _._start[1]++, _._end[0] === m && _._end[1] === g + 1 && _._end[1]++;
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                v && !v.done && (o2 = y.return) && o2.call(y);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }
          return l.characterData_replaceData(e2, t2, p, ""), d;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(41), o = r(24), a = r(48), s = [].join, u = i != Object, l = a("join", ",");
        n({ target: "Array", proto: true, forced: u || !l }, { join: function(e2) {
          return s.call(o(this), void 0 === e2 ? "," : e2);
        } });
      }, function(e, t, r) {
        var n = r(4), i = r(83), o = String.fromCharCode, a = String.fromCodePoint;
        n({ target: "String", stat: true, forced: !!a && 1 != a.length }, { fromCodePoint: function(e2) {
          for (var t2, r2 = [], n2 = arguments.length, a2 = 0; n2 > a2; ) {
            if (t2 = +arguments[a2++], i(t2, 1114111) !== t2)
              throw RangeError(t2 + " is not a valid code point");
            r2.push(t2 < 65536 ? o(t2) : o(55296 + ((t2 -= 65536) >> 10), t2 % 1024 + 56320));
          }
          return r2.join("");
        } });
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(111), o = function() {
          function e2(e3, t2) {
            this._options = { skipWhitespaceOnlyText: false }, this.err = { line: -1, col: -1, index: -1, str: "" }, this._str = e3, this._index = 0, this._length = e3.length, t2 && (this._options.skipWhitespaceOnlyText = t2.skipWhitespaceOnlyText || false);
          }
          return e2.prototype.nextToken = function() {
            if (this.eof())
              return { type: i.TokenType.EOF };
            var t2 = this.skipIfStartsWith("<") ? this.openBracket() : this.text();
            return this._options.skipWhitespaceOnlyText && t2.type === i.TokenType.Text && e2.isWhiteSpaceToken(t2) && (t2 = this.nextToken()), t2;
          }, e2.prototype.openBracket = function() {
            return this.skipIfStartsWith("?") ? this.skipIfStartsWith("xml") ? e2.isSpace(this._str[this._index]) ? this.declaration() : (this.seek(-3), this.pi()) : this.pi() : this.skipIfStartsWith("!") ? this.skipIfStartsWith("--") ? this.comment() : this.skipIfStartsWith("[CDATA[") ? this.cdata() : this.skipIfStartsWith("DOCTYPE") ? this.doctype() : void this.throwError("Invalid '!' in opening tag.") : this.skipIfStartsWith("/") ? this.closeTag() : this.openTag();
          }, e2.prototype.declaration = function() {
            for (var e3 = "", t2 = "", r2 = ""; !this.eof(); ) {
              if (this.skipSpace(), this.skipIfStartsWith("?>"))
                return { type: i.TokenType.Declaration, version: e3, encoding: t2, standalone: r2 };
              var o2 = n(this.attribute(), 2), a = o2[0], s = o2[1];
              "version" === a ? e3 = s : "encoding" === a ? t2 = s : "standalone" === a ? r2 = s : this.throwError("Invalid attribute name: " + a);
            }
            this.throwError("Missing declaration end symbol `?>`");
          }, e2.prototype.doctype = function() {
            var e3 = "", t2 = "";
            this.skipSpace();
            var r2 = this.takeUntil2("[", ">", true);
            return this.skipSpace(), this.skipIfStartsWith("PUBLIC") ? (e3 = this.quotedString(), t2 = this.quotedString()) : this.skipIfStartsWith("SYSTEM") && (t2 = this.quotedString()), this.skipSpace(), this.skipIfStartsWith("[") && (this.skipUntil("]"), this.skipIfStartsWith("]") || this.throwError("Missing end bracket of DTD internal subset")), this.skipSpace(), this.skipIfStartsWith(">") || this.throwError("Missing doctype end symbol `>`"), { type: i.TokenType.DocType, name: r2, pubId: e3, sysId: t2 };
          }, e2.prototype.pi = function() {
            var e3 = this.takeUntilStartsWith("?>", true);
            if (this.eof() && this.throwError("Missing processing instruction end symbol `?>`"), this.skipSpace(), this.skipIfStartsWith("?>"))
              return { type: i.TokenType.PI, target: e3, data: "" };
            var t2 = this.takeUntilStartsWith("?>");
            return this.eof() && this.throwError("Missing processing instruction end symbol `?>`"), this.seek(2), { type: i.TokenType.PI, target: e3, data: t2 };
          }, e2.prototype.text = function() {
            var e3 = this.takeUntil("<");
            return { type: i.TokenType.Text, data: e3 };
          }, e2.prototype.comment = function() {
            var e3 = this.takeUntilStartsWith("-->");
            return this.eof() && this.throwError("Missing comment end symbol `-->`"), this.seek(3), { type: i.TokenType.Comment, data: e3 };
          }, e2.prototype.cdata = function() {
            var e3 = this.takeUntilStartsWith("]]>");
            return this.eof() && this.throwError("Missing CDATA end symbol `]>`"), this.seek(3), { type: i.TokenType.CDATA, data: e3 };
          }, e2.prototype.openTag = function() {
            this.skipSpace();
            var e3 = this.takeUntil2(">", "/", true);
            if (this.skipSpace(), this.skipIfStartsWith(">"))
              return { type: i.TokenType.Element, name: e3, attributes: [], selfClosing: false };
            if (this.skipIfStartsWith("/>"))
              return { type: i.TokenType.Element, name: e3, attributes: [], selfClosing: true };
            for (var t2 = []; !this.eof(); ) {
              if (this.skipSpace(), this.skipIfStartsWith(">"))
                return { type: i.TokenType.Element, name: e3, attributes: t2, selfClosing: false };
              if (this.skipIfStartsWith("/>"))
                return { type: i.TokenType.Element, name: e3, attributes: t2, selfClosing: true };
              var r2 = this.attribute();
              t2.push(r2);
            }
            this.throwError("Missing opening element tag end symbol `>`");
          }, e2.prototype.closeTag = function() {
            this.skipSpace();
            var e3 = this.takeUntil(">", true);
            return this.skipSpace(), this.skipIfStartsWith(">") || this.throwError("Missing closing element tag end symbol `>`"), { type: i.TokenType.ClosingTag, name: e3 };
          }, e2.prototype.attribute = function() {
            this.skipSpace();
            var e3 = this.takeUntil("=", true);
            return this.skipSpace(), this.skipIfStartsWith("=") || this.throwError("Missing equals sign before attribute value"), [e3, this.quotedString()];
          }, e2.prototype.quotedString = function() {
            this.skipSpace();
            var t2 = this.take(1);
            e2.isQuote(t2) || this.throwError("Missing start quote character before quoted value");
            var r2 = this.takeUntil(t2);
            return this.skipIfStartsWith(t2) || this.throwError("Missing end quote character after quoted value"), r2;
          }, e2.prototype.eof = function() {
            return this._index >= this._length;
          }, e2.prototype.skipIfStartsWith = function(e3) {
            var t2 = e3.length;
            if (1 === t2)
              return this._str[this._index] === e3 && (this._index++, true);
            for (var r2 = 0; r2 < t2; r2++)
              if (this._str[this._index + r2] !== e3[r2])
                return false;
            return this._index += t2, true;
          }, e2.prototype.seek = function(e3) {
            this._index += e3, this._index < 0 && (this._index = 0), this._index > this._length && (this._index = this._length);
          }, e2.prototype.skipSpace = function() {
            for (; !this.eof() && e2.isSpace(this._str[this._index]); )
              this._index++;
          }, e2.prototype.take = function(e3) {
            if (1 === e3)
              return this._str[this._index++];
            var t2 = this._index;
            return this.seek(e3), this._str.slice(t2, this._index);
          }, e2.prototype.takeUntil = function(t2, r2) {
            void 0 === r2 && (r2 = false);
            for (var n2 = this._index; this._index < this._length; ) {
              var i2 = this._str[this._index];
              if (i2 === t2 || r2 && e2.isSpace(i2))
                break;
              this._index++;
            }
            return this._str.slice(n2, this._index);
          }, e2.prototype.takeUntil2 = function(t2, r2, n2) {
            void 0 === n2 && (n2 = false);
            for (var i2 = this._index; this._index < this._length; ) {
              var o2 = this._str[this._index];
              if (o2 === t2 || o2 === r2 || n2 && e2.isSpace(o2))
                break;
              this._index++;
            }
            return this._str.slice(i2, this._index);
          }, e2.prototype.takeUntilStartsWith = function(t2, r2) {
            void 0 === r2 && (r2 = false);
            for (var n2 = this._index, i2 = t2.length; this._index < this._length; ) {
              for (var o2 = true, a = 0; a < i2; a++) {
                var s = this._str[this._index + a], u = t2[a];
                if (r2 && e2.isSpace(s))
                  return this._str.slice(n2, this._index);
                if (s !== u) {
                  this._index++, o2 = false;
                  break;
                }
              }
              if (o2)
                return this._str.slice(n2, this._index);
            }
            return this._index = this._length, this._str.slice(n2);
          }, e2.prototype.skipUntil = function(e3) {
            for (; this._index < this._length; ) {
              if (this._str[this._index] === e3)
                break;
              this._index++;
            }
          }, e2.isWhiteSpaceToken = function(e3) {
            for (var t2 = e3.data, r2 = 0; r2 < t2.length; r2++) {
              var n2 = t2[r2];
              if (" " !== n2 && "\n" !== n2 && "\r" !== n2 && "	" !== n2 && "\f" !== n2)
                return false;
            }
            return true;
          }, e2.isSpace = function(e3) {
            return " " === e3 || "\n" === e3 || "\r" === e3 || "	" === e3;
          }, e2.isQuote = function(e3) {
            return '"' === e3 || "'" === e3;
          }, e2.prototype.throwError = function(e3) {
            for (var t2 = /\r\n|\r|\n/g, r2 = null, n2 = 0, i2 = 0, o2 = this._str.length; null !== (r2 = t2.exec(this._str)) && null !== r2; )
              if (n2++, r2.index < this._index && (i2 = t2.lastIndex), r2.index > this._index) {
                o2 = r2.index;
                break;
              }
            throw this.err = { line: n2, col: this._index - i2, index: this._index, str: this._str.substring(i2, o2) }, new Error(e3 + "\nIndex: " + this.err.index + "\nLn: " + this.err.line + ", Col: " + this.err.col + "\nInput: " + this.err.str);
          }, e2.prototype[Symbol.iterator] = function() {
            return this._index = 0, { next: function() {
              var e3 = this.nextToken();
              return e3.type === i.TokenType.EOF ? { done: true, value: null } : { done: false, value: e3 };
            }.bind(this) };
          }, e2;
        }();
        t.XMLStringLexer = o;
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ include: [r(182)] });
      }, function(e, t, r) {
        "use strict";
        var n = r(39);
        e.exports = new n({ include: [r(113)], implicit: [r(290), r(291), r(292), r(293)] });
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(91), i = r(2), o = r(3), a = r(77), s = r(109);
        function u(e2, t2) {
          var r2 = c(void 0 === e2 || l(e2) ? e2 : n.DefaultBuilderOptions), i2 = l(e2) ? t2 : e2, o2 = s.createDocument();
          h(o2, r2);
          var u2 = new a.XMLBuilderImpl(o2);
          return void 0 !== i2 && u2.ele(i2), u2;
        }
        function l(e2) {
          if (!i.isPlainObject(e2))
            return false;
          for (var t2 in e2)
            if (e2.hasOwnProperty(t2) && !n.XMLBuilderOptionKeys.has(t2))
              return false;
          return true;
        }
        function c(e2) {
          void 0 === e2 && (e2 = {});
          var t2 = i.applyDefaults(e2, n.DefaultBuilderOptions);
          if (0 === t2.convert.att.length || 0 === t2.convert.ins.length || 0 === t2.convert.text.length || 0 === t2.convert.cdata.length || 0 === t2.convert.comment.length)
            throw new Error("JS object converter strings cannot be zero length.");
          return t2;
        }
        function h(e2, t2, r2) {
          var n2 = e2;
          n2._xmlBuilderOptions = t2, n2._isFragment = r2;
        }
        t.builder = function(e2, t2) {
          var r2 = c(l(e2) ? e2 : n.DefaultBuilderOptions), s2 = o.Guard.isNode(e2) || i.isArray(e2) ? e2 : t2;
          if (void 0 === s2)
            throw new Error("Invalid arguments.");
          if (i.isArray(s2)) {
            for (var u2 = [], h2 = 0; h2 < s2.length; h2++) {
              var p = new a.XMLBuilderImpl(s2[h2]);
              p.set(r2), u2.push(p);
            }
            return u2;
          }
          var f = new a.XMLBuilderImpl(s2);
          return f.set(r2), f;
        }, t.create = u, t.fragment = function(e2, t2) {
          var r2 = c(void 0 === e2 || l(e2) ? e2 : n.DefaultBuilderOptions), i2 = l(e2) ? t2 : e2, o2 = s.createDocument();
          h(o2, r2, true);
          var u2 = new a.XMLBuilderImpl(o2.createDocumentFragment());
          return void 0 !== i2 && u2.ele(i2), u2;
        }, t.convert = function(e2, t2, r2) {
          var i2, o2, a2;
          return l(e2) && void 0 !== t2 ? (i2 = e2, o2 = t2, a2 = r2) : (i2 = n.DefaultBuilderOptions, o2 = e2, a2 = t2 || void 0), u(i2, o2).end(a2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(77);
        t.builder = n.builder, t.create = n.create, t.fragment = n.fragment, t.convert = n.convert, t.createCB = n.createCB, t.fragmentCB = n.fragmentCB;
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(191), r(192), r(194), r(64), r(19), r(198), r(199), r(89), r(201), r(65), r(20), r(66), r(22), r(23);
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(91), a = r(2), s = r(217), u = r(1), l = r(3), c = r(0), h = r(109), p = r(7), f = r(277), d = function() {
          function e2(e3) {
            this._domNode = e3;
          }
          return Object.defineProperty(e2.prototype, "node", { get: function() {
            return this._domNode;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "options", { get: function() {
            return this._options;
          }, enumerable: true, configurable: true }), e2.prototype.set = function(e3) {
            return this._options = a.applyDefaults(a.applyDefaults(this._options, e3, true), o.DefaultBuilderOptions), this;
          }, e2.prototype.ele = function(t2, r2, i2) {
            var o2, s2, u2, l2, p2, d2;
            if (a.isObject(t2))
              return new f.ObjectReader(this._options).parse(this, t2);
            if (null !== t2 && /^\s*</.test(t2))
              return new f.XMLReader(this._options).parse(this, t2);
            if (null !== t2 && /^\s*[\{\[]/.test(t2))
              return new f.JSONReader(this._options).parse(this, t2);
            if (null !== t2 && /^(\s*|(#.*)|(%.*))*---/.test(t2))
              return new f.YAMLReader(this._options).parse(this, t2);
            if ((null === t2 || a.isString(t2)) && a.isString(r2))
              l2 = (o2 = n([t2, r2, i2], 3))[0], p2 = o2[1], d2 = o2[2];
            else {
              if (null === t2)
                throw new Error("Element name cannot be null. " + this._debugInfo());
              l2 = (s2 = n([void 0, t2, a.isObject(r2) ? r2 : void 0], 3))[0], p2 = s2[1], d2 = s2[2];
            }
            if (d2 && (d2 = a.getValue(d2)), l2 = (u2 = n(this._extractNamespace(h.sanitizeInput(l2, this._options.invalidCharReplacement), h.sanitizeInput(p2, this._options.invalidCharReplacement), true), 2))[0], p2 = u2[1], void 0 === l2) {
              var m = n(c.namespace_extractQName(p2), 1)[0];
              l2 = this.node.lookupNamespaceURI(m);
            }
            var y = null != l2 ? this._doc.createElementNS(l2, p2) : this._doc.createElement(p2);
            this.node.appendChild(y);
            var v = new e2(y), _ = this._doc.doctype;
            if (y === this._doc.documentElement && null !== _) {
              var g = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, _.publicId, _.systemId);
              this._doc.replaceChild(g, _);
            }
            return d2 && !a.isEmpty(d2) && v.att(d2), v;
          }, e2.prototype.remove = function() {
            var e3 = this.up();
            return e3.node.removeChild(this.node), e3;
          }, e2.prototype.att = function(e3, t2, r2) {
            var i2, o2, s2, u2, f2, d2, m = this;
            if (a.isMap(e3) || a.isObject(e3))
              return a.forEachObject(e3, function(e4, t3) {
                return m.att(e4, t3);
              }, this), this;
            if (null != e3 && (e3 = a.getValue(e3 + "")), null != t2 && (t2 = a.getValue(t2 + "")), null != r2 && (r2 = a.getValue(r2 + "")), null !== e3 && !a.isString(e3) || !a.isString(t2) || null !== r2 && !a.isString(r2)) {
              if (!a.isString(e3) || null != t2 && !a.isString(t2))
                throw new Error("Attribute name and value not specified. " + this._debugInfo());
              u2 = (o2 = n([void 0, e3, t2], 3))[0], f2 = o2[1], d2 = o2[2];
            } else
              u2 = (i2 = n([e3, t2, r2], 3))[0], f2 = i2[1], d2 = i2[2];
            if (this._options.keepNullAttributes && null == d2)
              d2 = "";
            else if (null == d2)
              return this;
            if (!l.Guard.isElementNode(this.node))
              throw new Error("An attribute can only be assigned to an element node.");
            var y = this.node;
            u2 = (s2 = n(this._extractNamespace(u2, f2, false), 2))[0], f2 = s2[1], f2 = h.sanitizeInput(f2, this._options.invalidCharReplacement), u2 = h.sanitizeInput(u2, this._options.invalidCharReplacement), d2 = h.sanitizeInput(d2, this._options.invalidCharReplacement);
            var v = n(c.namespace_extractQName(f2), 2), _ = v[0], g = v[1], b = n(c.namespace_extractQName(y.prefix ? y.prefix + ":" + y.localName : y.localName), 1)[0], x = null;
            return "xmlns" === _ ? (u2 = p.namespace.XMLNS, null === y.namespaceURI && b === g && (x = d2)) : null === _ && "xmlns" === g && null === b && (u2 = p.namespace.XMLNS, x = d2), null !== x && (this._updateNamespace(x), y = this.node), void 0 !== u2 ? y.setAttributeNS(u2, f2, d2) : y.setAttribute(f2, d2), this;
          }, e2.prototype.removeAtt = function(e3, t2) {
            var r2, n2, i2 = this;
            if (!l.Guard.isElementNode(this.node))
              throw new Error("An attribute can only be removed from an element node.");
            if (e3 = a.getValue(e3), void 0 !== t2 && (t2 = a.getValue(t2)), null !== e3 && void 0 === t2)
              n2 = e3;
            else {
              if (null !== e3 && !a.isString(e3) || void 0 === t2)
                throw new Error("Attribute namespace must be a string. " + this._debugInfo());
              r2 = e3, n2 = t2;
            }
            return a.isArray(n2) || a.isSet(n2) ? a.forEachArray(n2, function(e4) {
              return void 0 === r2 ? i2.removeAtt(e4) : i2.removeAtt(r2, e4);
            }, this) : void 0 !== r2 ? (n2 = h.sanitizeInput(n2, this._options.invalidCharReplacement), r2 = h.sanitizeInput(r2, this._options.invalidCharReplacement), this.node.removeAttributeNS(r2, n2)) : (n2 = h.sanitizeInput(n2, this._options.invalidCharReplacement), this.node.removeAttribute(n2)), this;
          }, e2.prototype.txt = function(e3) {
            if (null == e3) {
              if (!this._options.keepNullNodes)
                return this;
              e3 = "";
            }
            var t2 = this._doc.createTextNode(h.sanitizeInput(e3, this._options.invalidCharReplacement));
            return this.node.appendChild(t2), this;
          }, e2.prototype.com = function(e3) {
            if (null == e3) {
              if (!this._options.keepNullNodes)
                return this;
              e3 = "";
            }
            var t2 = this._doc.createComment(h.sanitizeInput(e3, this._options.invalidCharReplacement));
            return this.node.appendChild(t2), this;
          }, e2.prototype.dat = function(e3) {
            if (null == e3) {
              if (!this._options.keepNullNodes)
                return this;
              e3 = "";
            }
            var t2 = this._doc.createCDATASection(h.sanitizeInput(e3, this._options.invalidCharReplacement));
            return this.node.appendChild(t2), this;
          }, e2.prototype.ins = function(e3, t2) {
            var r2 = this;
            if (void 0 === t2 && (t2 = ""), null == t2) {
              if (!this._options.keepNullNodes)
                return this;
              t2 = "";
            }
            if (a.isArray(e3) || a.isSet(e3))
              a.forEachArray(e3, function(e4) {
                var t3 = (e4 += "").indexOf(" "), n3 = -1 === t3 ? e4 : e4.substr(0, t3), i2 = -1 === t3 ? "" : e4.substr(t3 + 1);
                r2.ins(n3, i2);
              }, this);
            else if (a.isMap(e3) || a.isObject(e3))
              a.forEachObject(e3, function(e4, t3) {
                return r2.ins(e4, t3);
              }, this);
            else {
              var n2 = this._doc.createProcessingInstruction(h.sanitizeInput(e3, this._options.invalidCharReplacement), h.sanitizeInput(t2, this._options.invalidCharReplacement));
              this.node.appendChild(n2);
            }
            return this;
          }, e2.prototype.dec = function(e3) {
            return this._options.version = e3.version || "1.0", this._options.encoding = e3.encoding, this._options.standalone = e3.standalone, this;
          }, e2.prototype.dtd = function(e3) {
            var t2 = h.sanitizeInput(e3 && e3.name || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement), r2 = h.sanitizeInput(e3 && e3.pubID || "", this._options.invalidCharReplacement), n2 = h.sanitizeInput(e3 && e3.sysID || "", this._options.invalidCharReplacement);
            if (null !== this._doc.documentElement && t2 !== this._doc.documentElement.tagName)
              throw new Error("DocType name does not match document element name.");
            var i2 = this._doc.implementation.createDocumentType(t2, r2, n2);
            return null !== this._doc.doctype ? this._doc.replaceChild(i2, this._doc.doctype) : this._doc.insertBefore(i2, this._doc.documentElement), this;
          }, e2.prototype.import = function(t2) {
            var r2, o2, a2 = this._domNode, s2 = this._doc, u2 = t2.node;
            if (l.Guard.isDocumentNode(u2)) {
              var h2 = u2.documentElement;
              if (null === h2)
                throw new Error("Imported document has no document element node. " + this._debugInfo());
              var p2 = s2.importNode(h2, true);
              a2.appendChild(p2);
              var f2 = n(c.namespace_extractQName(p2.prefix ? p2.prefix + ":" + p2.localName : p2.localName), 1)[0], d2 = a2.lookupNamespaceURI(f2);
              new e2(p2)._updateNamespace(d2);
            } else if (l.Guard.isDocumentFragmentNode(u2))
              try {
                for (var m = i(u2.childNodes), y = m.next(); !y.done; y = m.next()) {
                  var v = y.value;
                  p2 = s2.importNode(v, true);
                  if (a2.appendChild(p2), l.Guard.isElementNode(p2)) {
                    f2 = n(c.namespace_extractQName(p2.prefix ? p2.prefix + ":" + p2.localName : p2.localName), 1)[0], d2 = a2.lookupNamespaceURI(f2);
                    new e2(p2)._updateNamespace(d2);
                  }
                }
              } catch (e3) {
                r2 = { error: e3 };
              } finally {
                try {
                  y && !y.done && (o2 = m.return) && o2.call(m);
                } finally {
                  if (r2)
                    throw r2.error;
                }
              }
            else {
              p2 = s2.importNode(u2, true);
              if (a2.appendChild(p2), l.Guard.isElementNode(p2)) {
                f2 = n(c.namespace_extractQName(p2.prefix ? p2.prefix + ":" + p2.localName : p2.localName), 1)[0], d2 = a2.lookupNamespaceURI(f2);
                new e2(p2)._updateNamespace(d2);
              }
            }
            return this;
          }, e2.prototype.doc = function() {
            if (this._doc._isFragment) {
              for (var t2 = this.node; t2 && t2.nodeType !== u.NodeType.DocumentFragment; )
                t2 = t2.parentNode;
              if (null === t2)
                throw new Error("Node has no parent node while searching for document fragment ancestor. " + this._debugInfo());
              return new e2(t2);
            }
            return new e2(this._doc);
          }, e2.prototype.root = function() {
            var t2 = this._doc.documentElement;
            if (!t2)
              throw new Error("Document root element is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.up = function() {
            var t2 = this._domNode.parentNode;
            if (!t2)
              throw new Error("Parent node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.prev = function() {
            var t2 = this._domNode.previousSibling;
            if (!t2)
              throw new Error("Previous sibling node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.next = function() {
            var t2 = this._domNode.nextSibling;
            if (!t2)
              throw new Error("Next sibling node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.first = function() {
            var t2 = this._domNode.firstChild;
            if (!t2)
              throw new Error("First child node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.last = function() {
            var t2 = this._domNode.lastChild;
            if (!t2)
              throw new Error("Last child node is null. " + this._debugInfo());
            return new e2(t2);
          }, e2.prototype.each = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
              t2.call(i2, new e2(o2[0]), o2[1], o2[2]), o2 = a2;
            }
            return this;
          }, e2.prototype.map = function(e3, t2, r2, n2) {
            void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false);
            var i2 = [];
            return this.each(function(t3, r3, o2) {
              return i2.push(e3.call(n2, t3, r3, o2));
            }, t2, r2), i2;
          }, e2.prototype.reduce = function(e3, t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            var o2 = t2;
            return this.each(function(t3, r3, n3) {
              return o2 = e3.call(i2, o2, t3, r3, n3);
            }, r2, n2), o2;
          }, e2.prototype.find = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = new e2(o2[0]);
              if (t2.call(i2, a2, o2[1], o2[2]))
                return a2;
              o2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
            }
          }, e2.prototype.filter = function(e3, t2, r2, n2) {
            void 0 === t2 && (t2 = false), void 0 === r2 && (r2 = false);
            var i2 = [];
            return this.each(function(t3, r3, o2) {
              e3.call(n2, t3, r3, o2) && i2.push(t3);
            }, t2, r2), i2;
          }, e2.prototype.every = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = new e2(o2[0]);
              if (!t2.call(i2, a2, o2[1], o2[2]))
                return false;
              o2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
            }
            return true;
          }, e2.prototype.some = function(t2, r2, n2, i2) {
            void 0 === r2 && (r2 = false), void 0 === n2 && (n2 = false);
            for (var o2 = this._getFirstDescendantNode(this._domNode, r2, n2); o2[0]; ) {
              var a2 = new e2(o2[0]);
              if (t2.call(i2, a2, o2[1], o2[2]))
                return true;
              o2 = this._getNextDescendantNode(this._domNode, o2[0], n2, o2[1], o2[2]);
            }
            return false;
          }, e2.prototype.toArray = function(e3, t2) {
            void 0 === e3 && (e3 = false), void 0 === t2 && (t2 = false);
            var r2 = [];
            return this.each(function(e4) {
              return r2.push(e4);
            }, e3, t2), r2;
          }, e2.prototype.toString = function(e3) {
            return void 0 === (e3 = e3 || {}).format && (e3.format = "xml"), this._serialize(e3);
          }, e2.prototype.toObject = function(e3) {
            return void 0 === (e3 = e3 || {}).format && (e3.format = "object"), this._serialize(e3);
          }, e2.prototype.end = function(e3) {
            return void 0 === (e3 = e3 || {}).format && (e3.format = "xml"), this.doc()._serialize(e3);
          }, e2.prototype._getFirstDescendantNode = function(e3, t2, r2) {
            return t2 ? [this._domNode, 0, 0] : r2 ? this._getNextDescendantNode(e3, e3, r2, 0, 0) : [this._domNode.firstChild, 0, 1];
          }, e2.prototype._getNextDescendantNode = function(e3, t2, r2, n2, i2) {
            if (!r2)
              return e3 === t2 ? [t2.firstChild, 0, i2 + 1] : [t2.nextSibling, n2 + 1, i2];
            if (t2.firstChild)
              return [t2.firstChild, 0, i2 + 1];
            if (t2 === e3)
              return [null, -1, -1];
            if (t2.nextSibling)
              return [t2.nextSibling, n2 + 1, i2];
            for (var o2 = t2.parentNode; o2 && o2 !== e3; ) {
              if (o2.nextSibling)
                return [o2.nextSibling, c.tree_index(o2.nextSibling), i2 - 1];
              o2 = o2.parentNode, i2--;
            }
            return [null, -1, -1];
          }, e2.prototype._serialize = function(e3) {
            if ("xml" === e3.format)
              return new s.XMLWriter(this._options, e3).serialize(this.node);
            if ("map" === e3.format)
              return new s.MapWriter(this._options, e3).serialize(this.node);
            if ("object" === e3.format)
              return new s.ObjectWriter(this._options, e3).serialize(this.node);
            if ("json" === e3.format)
              return new s.JSONWriter(this._options, e3).serialize(this.node);
            if ("yaml" === e3.format)
              return new s.YAMLWriter(this._options, e3).serialize(this.node);
            throw new Error("Invalid writer format: " + e3.format + ". " + this._debugInfo());
          }, e2.prototype._extractNamespace = function(e3, t2, r2) {
            var n2 = t2.indexOf("@");
            if (n2 > 0 && (void 0 === e3 && (e3 = t2.slice(n2 + 1)), t2 = t2.slice(0, n2)), void 0 === e3)
              e3 = r2 ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att;
            else if (null !== e3 && "@" === e3[0]) {
              var i2 = e3.slice(1);
              if (void 0 === (e3 = this._options.namespaceAlias[i2]))
                throw new Error("Namespace alias `" + i2 + "` is not defined. " + this._debugInfo());
            }
            return [e3, t2];
          }, e2.prototype._updateNamespace = function(t2) {
            var r2, o2, a2, s2, u2 = this._domNode;
            if (l.Guard.isElementNode(u2) && null !== t2 && u2.namespaceURI !== t2) {
              var h2 = n(c.namespace_extractQName(u2.prefix ? u2.prefix + ":" + u2.localName : u2.localName), 2), p2 = h2[0], f2 = h2[1], d2 = c.create_element(this._doc, f2, t2, p2);
              try {
                for (var m = i(u2.attributes), y = m.next(); !y.done; y = m.next()) {
                  var v = y.value, _ = v.prefix ? v.prefix + ":" + v.localName : v.localName, g = n(c.namespace_extractQName(_), 1)[0], b = v.namespaceURI;
                  null === b && null !== g && (b = u2.lookupNamespaceURI(g)), null === b ? d2.setAttribute(_, v.value) : d2.setAttributeNS(b, _, v.value);
                }
              } catch (e3) {
                r2 = { error: e3 };
              } finally {
                try {
                  y && !y.done && (o2 = m.return) && o2.call(m);
                } finally {
                  if (r2)
                    throw r2.error;
                }
              }
              var x = u2.parentNode;
              if (null === x)
                throw new Error("Parent node is null." + this._debugInfo());
              x.replaceChild(d2, u2), this._domNode = d2;
              try {
                for (var w = i(u2.childNodes), E = w.next(); !E.done; E = w.next()) {
                  var D = E.value.cloneNode(true);
                  if (d2.appendChild(D), l.Guard.isElementNode(D)) {
                    var S = n(c.namespace_extractQName(D.prefix ? D.prefix + ":" + D.localName : D.localName), 1)[0], C = d2.lookupNamespaceURI(S);
                    new e2(D)._updateNamespace(C);
                  }
                }
              } catch (e3) {
                a2 = { error: e3 };
              } finally {
                try {
                  E && !E.done && (s2 = w.return) && s2.call(w);
                } finally {
                  if (a2)
                    throw a2.error;
                }
              }
            }
          }, Object.defineProperty(e2.prototype, "_doc", { get: function() {
            var e3 = this.node;
            if (l.Guard.isDocumentNode(e3))
              return e3;
            var t2 = e3.ownerDocument;
            if (!t2)
              throw new Error("Owner document is null. " + this._debugInfo());
            return t2;
          }, enumerable: true, configurable: true }), e2.prototype._debugInfo = function(e3) {
            var t2 = this.node, r2 = t2.parentNode;
            e3 = e3 || t2.nodeName;
            var n2 = r2 ? r2.nodeName : "";
            return n2 ? "node: <" + e3 + ">, parent: <" + n2 + ">" : "node: <" + e3 + ">";
          }, Object.defineProperty(e2.prototype, "_options", { get: function() {
            var e3 = this._doc;
            if (void 0 === e3._xmlBuilderOptions)
              throw new Error("Builder options is not set.");
            return e3._xmlBuilderOptions;
          }, set: function(e3) {
            this._doc._xmlBuilderOptions = e3;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.XMLBuilderImpl = d;
      }, function(e, t, r) {
        var n = r(11), i = r(117), o = n.WeakMap;
        e.exports = "function" == typeof o && /native code/.test(i(o));
      }, function(e, t, r) {
        var n = r(46), i = r(82), o = r(85), a = r(18);
        e.exports = n("Reflect", "ownKeys") || function(e2) {
          var t2 = i.f(a(e2)), r2 = o.f;
          return r2 ? t2.concat(r2(e2)) : t2;
        };
      }, function(e, t, r) {
        var n = r(16), i = r(15), o = r(18), a = r(61);
        e.exports = n ? Object.defineProperties : function(e2, t2) {
          o(e2);
          for (var r2, n2 = a(t2), s = n2.length, u = 0; s > u; )
            i.f(e2, r2 = n2[u++], t2[r2]);
          return e2;
        };
      }, function(e, t, r) {
        var n = r(46);
        e.exports = n("document", "documentElement");
      }, function(e, t, r) {
        var n = r(24), i = r(82).f, o = {}.toString, a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        e.exports.f = function(e2) {
          return a && "[object Window]" == o.call(e2) ? function(e3) {
            try {
              return i(e3);
            } catch (e4) {
              return a.slice();
            }
          }(e2) : i(n(e2));
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).every, o = r(48), a = r(28), s = o("every"), u = a("every");
        n({ target: "Array", proto: true, forced: !s || !u }, { every: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).filter, o = r(63), a = r(28), s = o("filter"), u = a("filter");
        n({ target: "Array", proto: true, forced: !s || !u }, { filter: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        var n = r(46);
        e.exports = n("navigator", "userAgent") || "";
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).find, o = r(130), a = r(28), s = true, u = a("find");
        "find" in [] && Array(1).find(function() {
          s = false;
        }), n({ target: "Array", proto: true, forced: s || !u }, { find: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } }), o("find");
      }, function(e, t, r) {
        "use strict";
        var n = r(131).IteratorPrototype, i = r(60), o = r(40), a = r(62), s = r(49), u = function() {
          return this;
        };
        e.exports = function(e2, t2, r2) {
          var l = t2 + " Iterator";
          return e2.prototype = i(n, { next: o(1, r2) }), a(e2, l, false, true), s[l] = u, e2;
        };
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !n(function() {
          function e2() {
          }
          return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
        });
      }, function(e, t, r) {
        var n = r(13);
        e.exports = function(e2) {
          if (!n(e2) && null !== e2)
            throw TypeError("Can't set " + String(e2) + " as a prototype");
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).map, o = r(63), a = r(28), s = o("map"), u = a("map");
        n({ target: "Array", proto: true, forced: !s || !u }, { map: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(200).left, o = r(48), a = r(28), s = o("reduce"), u = a("reduce", { 1: 0 });
        n({ target: "Array", proto: true, forced: !s || !u }, { reduce: function(e2) {
          return i(this, e2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        var n = r(127), i = r(27), o = r(41), a = r(26), s = function(e2) {
          return function(t2, r2, s2, u) {
            n(r2);
            var l = i(t2), c = o(l), h = a(l.length), p = e2 ? h - 1 : 0, f = e2 ? -1 : 1;
            if (s2 < 2)
              for (; ; ) {
                if (p in c) {
                  u = c[p], p += f;
                  break;
                }
                if (p += f, e2 ? p < 0 : h <= p)
                  throw TypeError("Reduce of empty array with no initial value");
              }
            for (; e2 ? p >= 0 : h > p; p += f)
              p in c && (u = r2(u, c[p], p, l));
            return u;
          };
        };
        e.exports = { left: s(false), right: s(true) };
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(36).some, o = r(48), a = r(28), s = o("some"), u = a("some");
        n({ target: "Array", proto: true, forced: !s || !u }, { some: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(90), i = r(135);
        e.exports = n ? {}.toString : function() {
          return "[object " + i(this) + "]";
        };
      }, function(e, t) {
        e.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
      }, function(e, t, r) {
        var n = r(8);
        e.exports = !n(function() {
          return Object.isExtensible(Object.preventExtensions({}));
        });
      }, function(e, t, r) {
        var n = r(5), i = r(49), o = n("iterator"), a = Array.prototype;
        e.exports = function(e2) {
          return void 0 !== e2 && (i.Array === e2 || a[o] === e2);
        };
      }, function(e, t, r) {
        var n = r(135), i = r(49), o = r(5)("iterator");
        e.exports = function(e2) {
          if (null != e2)
            return e2[o] || e2["@@iterator"] || i[n(e2)];
        };
      }, function(e, t, r) {
        var n = r(18);
        e.exports = function(e2, t2, r2, i) {
          try {
            return i ? t2(n(r2)[0], r2[1]) : t2(r2);
          } catch (t3) {
            var o = e2.return;
            throw void 0 !== o && n(o.call(e2)), t3;
          }
        };
      }, function(e, t, r) {
        var n = r(5)("iterator"), i = false;
        try {
          var o = 0, a = { next: function() {
            return { done: !!o++ };
          }, return: function() {
            i = true;
          } };
          a[n] = function() {
            return this;
          }, Array.from(a, function() {
            throw 2;
          });
        } catch (e2) {
        }
        e.exports = function(e2, t2) {
          if (!t2 && !i)
            return false;
          var r2 = false;
          try {
            var o2 = {};
            o2[n] = function() {
              return { next: function() {
                return { done: r2 = true };
              } };
            }, e2(o2);
          } catch (e3) {
          }
          return r2;
        };
      }, function(e, t, r) {
        var n = r(13), i = r(133);
        e.exports = function(e2, t2, r2) {
          var o, a;
          return i && "function" == typeof (o = t2.constructor) && o !== r2 && n(a = o.prototype) && a !== r2.prototype && i(e2, a), e2;
        };
      }, function(e, t, r) {
        var n = r(25);
        e.exports = function(e2, t2, r2) {
          for (var i in t2)
            n(e2, i, t2[i], r2);
          return e2;
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(46), i = r(15), o = r(5), a = r(16), s = o("species");
        e.exports = function(e2) {
          var t2 = n(e2), r2 = i.f;
          a && t2 && !t2[s] && r2(t2, s, { configurable: true, get: function() {
            return this;
          } });
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s(o3) {
            return function(s2) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; a; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return a.label++, { value: o4[1], done: false };
                      case 5:
                        a.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = a.ops.pop(), a.trys.pop();
                        continue;
                      default:
                        if (!(i2 = a.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          a = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          a.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && a.label < i2[1]) {
                          a.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && a.label < i2[2]) {
                          a.label = i2[2], a.ops.push(o4);
                          break;
                        }
                        i2[2] && a.ops.pop(), a.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, a);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s2]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function() {
          function e2(e3) {
            void 0 === e3 && (e3 = 1e3), this._items = /* @__PURE__ */ new Set(), this._limit = e3;
          }
          return e2.prototype.add = function(e3) {
            if (this._items.add(e3), this._items.size > this._limit) {
              var t2 = this._items.values().next();
              t2.done || this._items.delete(t2.value);
            }
            return this;
          }, e2.prototype.delete = function(e3) {
            return this._items.delete(e3);
          }, e2.prototype.has = function(e3) {
            return this._items.has(e3);
          }, e2.prototype.clear = function() {
            this._items.clear();
          }, Object.defineProperty(e2.prototype, "size", { get: function() {
            return this._items.size;
          }, enumerable: true, configurable: true }), e2.prototype.forEach = function(e3, t2) {
            var r2 = this;
            this._items.forEach(function(n2) {
              return e3.call(t2, n2, n2, r2);
            });
          }, e2.prototype.keys = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.keys())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.values = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.values())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.entries = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.entries())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype[Symbol.iterator] = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items)];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, Object.defineProperty(e2.prototype, Symbol.toStringTag, { get: function() {
            return "FixedSizeSet";
          }, enumerable: true, configurable: true }), e2;
        }();
        t.FixedSizeSet = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s(o3) {
            return function(s2) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; a; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return a.label++, { value: o4[1], done: false };
                      case 5:
                        a.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = a.ops.pop(), a.trys.pop();
                        continue;
                      default:
                        if (!(i2 = a.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          a = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          a.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && a.label < i2[1]) {
                          a.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && a.label < i2[2]) {
                          a.label = i2[2], a.ops.push(o4);
                          break;
                        }
                        i2[2] && a.ops.pop(), a.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, a);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s2]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function() {
          function e2(e3) {
            void 0 === e3 && (e3 = 1e3), this._items = /* @__PURE__ */ new Map(), this._limit = e3;
          }
          return e2.prototype.get = function(e3) {
            return this._items.get(e3);
          }, e2.prototype.set = function(e3, t2) {
            if (this._items.set(e3, t2), this._items.size > this._limit) {
              var r2 = this._items.keys().next();
              r2.done || this._items.delete(r2.value);
            }
          }, e2.prototype.delete = function(e3) {
            return this._items.delete(e3);
          }, e2.prototype.has = function(e3) {
            return this._items.has(e3);
          }, e2.prototype.clear = function() {
            this._items.clear();
          }, Object.defineProperty(e2.prototype, "size", { get: function() {
            return this._items.size;
          }, enumerable: true, configurable: true }), e2.prototype.forEach = function(e3, t2) {
            this._items.forEach(function(r2, n2) {
              return e3.call(t2, n2, r2);
            });
          }, e2.prototype.keys = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.keys())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.values = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.values())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype.entries = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items.entries())];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, e2.prototype[Symbol.iterator] = function() {
            return n(this, function(e3) {
              switch (e3.label) {
                case 0:
                  return [5, i(this._items)];
                case 1:
                  return e3.sent(), [2];
              }
            });
          }, Object.defineProperty(e2.prototype, Symbol.toStringTag, { get: function() {
            return "ObjectCache";
          }, enumerable: true, configurable: true }), e2;
        }();
        t.ObjectCache = o;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3) {
            void 0 === e3 && (e3 = 1e3), this._items = /* @__PURE__ */ new Map(), this._limit = e3;
          }
          return e2.prototype.check = function(e3, t2) {
            if (this._items.get(e3) === t2)
              return true;
            if (this._items.get(t2) === e3)
              return false;
            var r2 = Math.random() < 0.5;
            if (r2 ? this._items.set(e3, t2) : this._items.set(t2, e3), this._items.size > this._limit) {
              var n2 = this._items.keys().next();
              n2.done || this._items.delete(n2.value);
            }
            return r2;
          }, e2;
        }();
        t.CompareCache = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3) {
            this._initialized = false, this._value = void 0, this._initFunc = e3;
          }
          return Object.defineProperty(e2.prototype, "value", { get: function() {
            return this._initialized || (this._value = this._initFunc(), this._initialized = true), this._value;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.Lazy = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2(e3) {
            this._pointer = 0, this._chars = Array.from(e3), this._length = this._chars.length;
          }
          return Object.defineProperty(e2.prototype, "eof", { get: function() {
            return this._pointer >= this._length;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "length", { get: function() {
            return this._length;
          }, enumerable: true, configurable: true }), e2.prototype.codePoint = function() {
            if (void 0 === this._codePoint)
              if (this.eof)
                this._codePoint = -1;
              else {
                var e3 = this._chars[this._pointer].codePointAt(0);
                this._codePoint = void 0 !== e3 ? e3 : -1;
              }
            return this._codePoint;
          }, e2.prototype.c = function() {
            return void 0 === this._c && (this._c = this.eof ? "" : this._chars[this._pointer]), this._c;
          }, e2.prototype.remaining = function() {
            return void 0 === this._remaining && (this._remaining = this.eof ? "" : this._chars.slice(this._pointer + 1).join("")), this._remaining;
          }, e2.prototype.substring = function() {
            return void 0 === this._substring && (this._substring = this.eof ? "" : this._chars.slice(this._pointer).join("")), this._substring;
          }, Object.defineProperty(e2.prototype, "pointer", { get: function() {
            return this._pointer;
          }, set: function(e3) {
            e3 !== this._pointer && (this._pointer = e3, this._codePoint = void 0, this._c = void 0, this._remaining = void 0, this._substring = void 0);
          }, enumerable: true, configurable: true }), e2;
        }();
        t.StringWalker = n;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(218);
        t.MapWriter = n.MapWriter;
        var i = r(259);
        t.XMLWriter = i.XMLWriter;
        var o = r(67);
        t.ObjectWriter = o.ObjectWriter;
        var a = r(261);
        t.JSONWriter = a.JSONWriter;
        var s = r(262);
        t.YAMLWriter = s.YAMLWriter;
      }, function(e, t, r) {
        "use strict";
        r(19), r(219), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(67), s = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._writerOptions = o.applyDefaults(r2, { format: "map", wellFormed: false, group: false, verbose: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            var t3 = o.applyDefaults(this._writerOptions, { format: "object", wellFormed: false, verbose: false }), r2 = new a.ObjectWriter(this._builderOptions, t3).serialize(e3);
            return this._convertObject(r2);
          }, t2.prototype._convertObject = function(e3) {
            if (o.isArray(e3)) {
              for (var t3 = 0; t3 < e3.length; t3++)
                e3[t3] = this._convertObject(e3[t3]);
              return e3;
            }
            if (o.isObject(e3)) {
              var r2 = /* @__PURE__ */ new Map();
              for (var n2 in e3)
                r2.set(n2, this._convertObject(e3[n2]));
              return r2;
            }
            return e3;
          }, t2;
        }(r(50).BaseWriter);
        t.MapWriter = s;
      }, function(e, t, r) {
        "use strict";
        var n = r(139), i = r(143);
        e.exports = n("Map", function(e2) {
          return function() {
            return e2(this, arguments.length ? arguments[0] : void 0);
          };
        }, i);
      }, function(e, t, r) {
        "use strict";
        var n = r(4), i = r(8), o = r(59), a = r(13), s = r(27), u = r(26), l = r(134), c = r(128), h = r(63), p = r(5), f = r(129), d = p("isConcatSpreadable"), m = f >= 51 || !i(function() {
          var e2 = [];
          return e2[d] = false, e2.concat()[0] !== e2;
        }), y = h("concat"), v = function(e2) {
          if (!a(e2))
            return false;
          var t2 = e2[d];
          return void 0 !== t2 ? !!t2 : o(e2);
        };
        n({ target: "Array", proto: true, forced: !m || !y }, { concat: function(e2) {
          var t2, r2, n2, i2, o2, a2 = s(this), h2 = c(a2, 0), p2 = 0;
          for (t2 = -1, n2 = arguments.length; t2 < n2; t2++)
            if (v(o2 = -1 === t2 ? a2 : arguments[t2])) {
              if (p2 + (i2 = u(o2.length)) > 9007199254740991)
                throw TypeError("Maximum allowed index exceeded");
              for (r2 = 0; r2 < i2; r2++, p2++)
                r2 in o2 && l(h2, p2, o2[r2]);
            } else {
              if (p2 >= 9007199254740991)
                throw TypeError("Maximum allowed index exceeded");
              l(h2, p2++, o2);
            }
          return h2.length = p2, h2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(8);
        function i(e2, t2) {
          return RegExp(e2, t2);
        }
        t.UNSUPPORTED_Y = n(function() {
          var e2 = i("a", "y");
          return e2.lastIndex = 2, null != e2.exec("abcd");
        }), t.BROKEN_CARET = n(function() {
          var e2 = i("^r", "gy");
          return e2.lastIndex = 2, null != e2.exec("str");
        });
      }, function(e, t, r) {
        var n = r(223);
        e.exports = function(e2) {
          if (n(e2))
            throw TypeError("The method doesn't accept regular expressions");
          return e2;
        };
      }, function(e, t, r) {
        var n = r(13), i = r(42), o = r(5)("match");
        e.exports = function(e2) {
          var t2;
          return n(e2) && (void 0 !== (t2 = e2[o]) ? !!t2 : "RegExp" == i(e2));
        };
      }, function(e, t, r) {
        var n = r(5)("match");
        e.exports = function(e2) {
          var t2 = /./;
          try {
            "/./"[e2](t2);
          } catch (r2) {
            try {
              return t2[n] = false, "/./"[e2](t2);
            } catch (e3) {
            }
          }
          return false;
        };
      }, function(e, t, r) {
        "use strict";
        r(68);
        var n = r(25), i = r(8), o = r(5), a = r(93), s = r(21), u = o("species"), l = !i(function() {
          var e2 = /./;
          return e2.exec = function() {
            var e3 = [];
            return e3.groups = { a: "7" }, e3;
          }, "7" !== "".replace(e2, "$<a>");
        }), c = "$0" === "a".replace(/./, "$0"), h = o("replace"), p = !!/./[h] && "" === /./[h]("a", "$0"), f = !i(function() {
          var e2 = /(?:)/, t2 = e2.exec;
          e2.exec = function() {
            return t2.apply(this, arguments);
          };
          var r2 = "ab".split(e2);
          return 2 !== r2.length || "a" !== r2[0] || "b" !== r2[1];
        });
        e.exports = function(e2, t2, r2, h2) {
          var d = o(e2), m = !i(function() {
            var t3 = {};
            return t3[d] = function() {
              return 7;
            }, 7 != ""[e2](t3);
          }), y = m && !i(function() {
            var t3 = false, r3 = /a/;
            return "split" === e2 && ((r3 = {}).constructor = {}, r3.constructor[u] = function() {
              return r3;
            }, r3.flags = "", r3[d] = /./[d]), r3.exec = function() {
              return t3 = true, null;
            }, r3[d](""), !t3;
          });
          if (!m || !y || "replace" === e2 && (!l || !c || p) || "split" === e2 && !f) {
            var v = /./[d], _ = r2(d, ""[e2], function(e3, t3, r3, n2, i2) {
              return t3.exec === a ? m && !i2 ? { done: true, value: v.call(t3, r3, n2) } : { done: true, value: e3.call(r3, t3, n2) } : { done: false };
            }, { REPLACE_KEEPS_$0: c, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: p }), g = _[0], b = _[1];
            n(String.prototype, e2, g), n(RegExp.prototype, d, 2 == t2 ? function(e3, t3) {
              return b.call(e3, this, t3);
            } : function(e3) {
              return b.call(e3, this);
            });
          }
          h2 && s(RegExp.prototype[d], "sham", true);
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(137).charAt;
        e.exports = function(e2, t2, r2) {
          return t2 + (r2 ? n(e2, t2).length : 1);
        };
      }, function(e, t, r) {
        var n = r(42), i = r(93);
        e.exports = function(e2, t2) {
          var r2 = e2.exec;
          if ("function" == typeof r2) {
            var o = r2.call(e2, t2);
            if ("object" != typeof o)
              throw TypeError("RegExp exec method returned something other than an Object or null");
            return o;
          }
          if ("RegExp" !== n(e2))
            throw TypeError("RegExp#exec called on incompatible receiver");
          return i.call(e2, t2);
        };
      }, function(e, t, r) {
        "use strict";
        (function(e2) {
          Object.defineProperty(t, "__esModule", { value: true });
          var n = r(96);
          t.forgivingBase64Encode = function(t2) {
            return e2.from(t2).toString("base64");
          }, t.forgivingBase64Decode = function(t2) {
            return "" === t2 ? "" : ((t2 = t2.replace(n.ASCIIWhiteSpace, "")).length % 4 == 0 && (t2.endsWith("==") ? t2 = t2.substr(0, t2.length - 2) : t2.endsWith("=") && (t2 = t2.substr(0, t2.length - 1))), t2.length % 4 == 1 ? null : /[0-9A-Za-z+/]/.test(t2) ? e2.from(t2, "base64").toString("utf8") : null);
          };
        }).call(this, r(145).Buffer);
      }, function(e, t, r) {
        "use strict";
        t.byteLength = function(e2) {
          var t2 = l(e2), r2 = t2[0], n2 = t2[1];
          return 3 * (r2 + n2) / 4 - n2;
        }, t.toByteArray = function(e2) {
          var t2, r2, n2 = l(e2), a2 = n2[0], s2 = n2[1], u2 = new o(function(e3, t3, r3) {
            return 3 * (t3 + r3) / 4 - r3;
          }(0, a2, s2)), c2 = 0, h = s2 > 0 ? a2 - 4 : a2;
          for (r2 = 0; r2 < h; r2 += 4)
            t2 = i[e2.charCodeAt(r2)] << 18 | i[e2.charCodeAt(r2 + 1)] << 12 | i[e2.charCodeAt(r2 + 2)] << 6 | i[e2.charCodeAt(r2 + 3)], u2[c2++] = t2 >> 16 & 255, u2[c2++] = t2 >> 8 & 255, u2[c2++] = 255 & t2;
          2 === s2 && (t2 = i[e2.charCodeAt(r2)] << 2 | i[e2.charCodeAt(r2 + 1)] >> 4, u2[c2++] = 255 & t2);
          1 === s2 && (t2 = i[e2.charCodeAt(r2)] << 10 | i[e2.charCodeAt(r2 + 1)] << 4 | i[e2.charCodeAt(r2 + 2)] >> 2, u2[c2++] = t2 >> 8 & 255, u2[c2++] = 255 & t2);
          return u2;
        }, t.fromByteArray = function(e2) {
          for (var t2, r2 = e2.length, i2 = r2 % 3, o2 = [], a2 = 0, s2 = r2 - i2; a2 < s2; a2 += 16383)
            o2.push(c(e2, a2, a2 + 16383 > s2 ? s2 : a2 + 16383));
          1 === i2 ? (t2 = e2[r2 - 1], o2.push(n[t2 >> 2] + n[t2 << 4 & 63] + "==")) : 2 === i2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], o2.push(n[t2 >> 10] + n[t2 >> 4 & 63] + n[t2 << 2 & 63] + "="));
          return o2.join("");
        };
        for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, u = a.length; s < u; ++s)
          n[s] = a[s], i[a.charCodeAt(s)] = s;
        function l(e2) {
          var t2 = e2.length;
          if (t2 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var r2 = e2.indexOf("=");
          return -1 === r2 && (r2 = t2), [r2, r2 === t2 ? 0 : 4 - r2 % 4];
        }
        function c(e2, t2, r2) {
          for (var i2, o2, a2 = [], s2 = t2; s2 < r2; s2 += 3)
            i2 = (e2[s2] << 16 & 16711680) + (e2[s2 + 1] << 8 & 65280) + (255 & e2[s2 + 2]), a2.push(n[(o2 = i2) >> 18 & 63] + n[o2 >> 12 & 63] + n[o2 >> 6 & 63] + n[63 & o2]);
          return a2.join("");
        }
        i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
      }, function(e, t) {
        t.read = function(e2, t2, r, n, i) {
          var o, a, s = 8 * i - n - 1, u = (1 << s) - 1, l = u >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = e2[t2 + h];
          for (h += p, o = f & (1 << -c) - 1, f >>= -c, c += s; c > 0; o = 256 * o + e2[t2 + h], h += p, c -= 8)
            ;
          for (a = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; a = 256 * a + e2[t2 + h], h += p, c -= 8)
            ;
          if (0 === o)
            o = 1 - l;
          else {
            if (o === u)
              return a ? NaN : 1 / 0 * (f ? -1 : 1);
            a += Math.pow(2, n), o -= l;
          }
          return (f ? -1 : 1) * a * Math.pow(2, o - n);
        }, t.write = function(e2, t2, r, n, i, o) {
          var a, s, u, l = 8 * o - i - 1, c = (1 << l) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : o - 1, d = n ? 1 : -1, m = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
          for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s = isNaN(t2) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t2) / Math.LN2), t2 * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), (t2 += a + h >= 1 ? p / u : p * Math.pow(2, 1 - h)) * u >= 2 && (a++, u /= 2), a + h >= c ? (s = 0, a = c) : a + h >= 1 ? (s = (t2 * u - 1) * Math.pow(2, i), a += h) : (s = t2 * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; e2[r + f] = 255 & s, f += d, s /= 256, i -= 8)
            ;
          for (a = a << i | s, l += i; l > 0; e2[r + f] = 255 & a, f += d, a /= 256, l -= 8)
            ;
          e2[r + f - d] |= 128 * m;
        };
      }, function(e, t) {
        var r = {}.toString;
        e.exports = Array.isArray || function(e2) {
          return "[object Array]" == r.call(e2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(2);
        function o(e2) {
          var t2, r2;
          if (null === e2 || i.isString(e2) || i.isNumber(e2))
            return e2;
          if (i.isArray(e2)) {
            var a = new Array();
            try {
              for (var s = n(e2), u = s.next(); !u.done; u = s.next()) {
                var l = u.value;
                a.push(o(l));
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                u && !u.done && (r2 = s.return) && r2.call(s);
              } finally {
                if (t2)
                  throw t2.error;
              }
            }
            return a;
          }
          if (i.isObject(e2)) {
            a = /* @__PURE__ */ new Map();
            for (var c in e2)
              if (e2.hasOwnProperty(c)) {
                var h = e2[c];
                a.set(c, o(h));
              }
            return a;
          }
          return e2;
        }
        t.parseJSONFromBytes = function(e2) {
          var t2 = i.utf8Decode(e2);
          return JSON.parse.call(void 0, t2);
        }, t.serializeJSONToBytes = function(e2) {
          var t2 = JSON.stringify.call(void 0, e2);
          return i.utf8Encode(t2);
        }, t.parseJSONIntoInfraValues = function(e2) {
          return o(JSON.parse.call(void 0, e2));
        }, t.convertAJSONDerivedJavaScriptValueToAnInfraValue = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s2(o3) {
            return function(s3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; a2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return a2.label++, { value: o4[1], done: false };
                      case 5:
                        a2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = a2.ops.pop(), a2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = a2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          a2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          a2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && a2.label < i2[1]) {
                          a2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && a2.label < i2[2]) {
                          a2.label = i2[2], a2.ops.push(o4);
                          break;
                        }
                        i2[2] && a2.ops.pop(), a2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, a2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s3]);
            };
          }
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(i(arguments[t2]));
          return e2;
        }, a = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(2);
        t.append = function(e2, t2) {
          e2.push(t2);
        }, t.extend = function(e2, t2) {
          e2.push.apply(e2, o(t2));
        }, t.prepend = function(e2, t2) {
          e2.unshift(t2);
        }, t.replace = function(e2, t2, r2) {
          var n2, i2, o2 = 0;
          try {
            for (var u = a(e2), l = u.next(); !l.done; l = u.next()) {
              var c = l.value;
              if (s.isFunction(t2))
                t2.call(null, c) && (e2[o2] = r2);
              else if (c === t2)
                return void (e2[o2] = r2);
              o2++;
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (i2 = u.return) && i2.call(u);
            } finally {
              if (n2)
                throw n2.error;
            }
          }
        }, t.insert = function(e2, t2, r2) {
          e2.splice(r2, 0, t2);
        }, t.remove = function(e2, t2) {
          for (var r2 = e2.length; r2--; ) {
            var n2 = e2[r2];
            if (s.isFunction(t2))
              t2.call(null, n2) && e2.splice(r2, 1);
            else if (n2 === t2)
              return void e2.splice(r2, 1);
          }
        }, t.empty = function(e2) {
          e2.length = 0;
        }, t.contains = function(e2, t2) {
          var r2, n2;
          try {
            for (var i2 = a(e2), o2 = i2.next(); !o2.done; o2 = i2.next()) {
              var u = o2.value;
              if (s.isFunction(t2)) {
                if (t2.call(null, u))
                  return true;
              } else if (u === t2)
                return true;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              o2 && !o2.done && (n2 = i2.return) && n2.call(i2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return false;
        }, t.size = function(e2, t2) {
          var r2, n2;
          if (void 0 === t2)
            return e2.length;
          var i2 = 0;
          try {
            for (var o2 = a(e2), s2 = o2.next(); !s2.done; s2 = o2.next()) {
              var u = s2.value;
              t2.call(null, u) && i2++;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return i2;
        }, t.isEmpty = function(e2) {
          return 0 === e2.length;
        }, t.forEach = function(e2, t2) {
          var r2, i2, o2, s2, u, l;
          return n(this, function(n2) {
            switch (n2.label) {
              case 0:
                return void 0 !== t2 ? [3, 2] : [5, a(e2)];
              case 1:
                return n2.sent(), [3, 9];
              case 2:
                n2.trys.push([2, 7, 8, 9]), r2 = a(e2), i2 = r2.next(), n2.label = 3;
              case 3:
                return i2.done ? [3, 6] : (o2 = i2.value, t2.call(null, o2) ? [4, o2] : [3, 5]);
              case 4:
                n2.sent(), n2.label = 5;
              case 5:
                return i2 = r2.next(), [3, 3];
              case 6:
                return [3, 9];
              case 7:
                return s2 = n2.sent(), u = { error: s2 }, [3, 9];
              case 8:
                try {
                  i2 && !i2.done && (l = r2.return) && l.call(r2);
                } finally {
                  if (u)
                    throw u.error;
                }
                return [7];
              case 9:
                return [2];
            }
          });
        }, t.clone = function(e2) {
          return new (Array.bind.apply(Array, o([void 0], e2)))();
        }, t.sortInAscendingOrder = function(e2, t2) {
          return e2.sort(function(e3, r2) {
            return t2.call(null, e3, r2) ? -1 : 1;
          });
        }, t.sortInDescendingOrder = function(e2, t2) {
          return e2.sort(function(e3, r2) {
            return t2.call(null, e3, r2) ? 1 : -1;
          });
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s2(o3) {
            return function(s3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; a2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return a2.label++, { value: o4[1], done: false };
                      case 5:
                        a2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = a2.ops.pop(), a2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = a2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          a2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          a2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && a2.label < i2[1]) {
                          a2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && a2.label < i2[2]) {
                          a2.label = i2[2], a2.ops.push(o4);
                          break;
                        }
                        i2[2] && a2.ops.pop(), a2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, a2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s3]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, o = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, a = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(o(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(2);
        t.get = function(e2, t2) {
          return e2.get(t2);
        }, t.set = function(e2, t2, r2) {
          e2.set(t2, r2);
        }, t.remove = function(e2, t2) {
          var r2, n2, o2, a2;
          if (s.isFunction(t2)) {
            var u = [];
            try {
              for (var l = i(e2), c = l.next(); !c.done; c = l.next()) {
                var h = c.value;
                t2.call(null, h) && u.push(h[0]);
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                c && !c.done && (n2 = l.return) && n2.call(l);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            try {
              for (var p = i(u), f = p.next(); !f.done; f = p.next()) {
                var d = f.value;
                e2.delete(d);
              }
            } catch (e3) {
              o2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (a2 = p.return) && a2.call(p);
              } finally {
                if (o2)
                  throw o2.error;
              }
            }
          } else
            e2.delete(t2);
        }, t.contains = function(e2, t2) {
          var r2, n2;
          if (s.isFunction(t2)) {
            try {
              for (var o2 = i(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var u = a2.value;
                if (t2.call(null, u))
                  return true;
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                a2 && !a2.done && (n2 = o2.return) && n2.call(o2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return false;
          }
          return e2.has(t2);
        }, t.keys = function(e2) {
          return new Set(e2.keys());
        }, t.values = function(e2) {
          return a(e2.values());
        }, t.size = function(e2, t2) {
          var r2, n2;
          if (void 0 === t2)
            return e2.size;
          var o2 = 0;
          try {
            for (var a2 = i(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              var u = s2.value;
              t2.call(null, u) && o2++;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = a2.return) && n2.call(a2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return o2;
        }, t.isEmpty = function(e2) {
          return 0 === e2.size;
        }, t.forEach = function(e2, t2) {
          var r2, o2, a2, s2, u, l;
          return n(this, function(n2) {
            switch (n2.label) {
              case 0:
                return void 0 !== t2 ? [3, 2] : [5, i(e2)];
              case 1:
                return n2.sent(), [3, 9];
              case 2:
                n2.trys.push([2, 7, 8, 9]), r2 = i(e2), o2 = r2.next(), n2.label = 3;
              case 3:
                return o2.done ? [3, 6] : (a2 = o2.value, t2.call(null, a2) ? [4, a2] : [3, 5]);
              case 4:
                n2.sent(), n2.label = 5;
              case 5:
                return o2 = r2.next(), [3, 3];
              case 6:
                return [3, 9];
              case 7:
                return s2 = n2.sent(), u = { error: s2 }, [3, 9];
              case 8:
                try {
                  o2 && !o2.done && (l = r2.return) && l.call(r2);
                } finally {
                  if (u)
                    throw u.error;
                }
                return [7];
              case 9:
                return [2];
            }
          });
        }, t.clone = function(e2) {
          return new Map(e2);
        }, t.sortInAscendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? -1 : 1;
          }), new Map(r2);
        }, t.sortInDescendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? 1 : -1;
          }), new Map(r2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.HTML = "http://www.w3.org/1999/xhtml", t.XML = "http://www.w3.org/XML/1998/namespace", t.XMLNS = "http://www.w3.org/2000/xmlns/", t.MathML = "http://www.w3.org/1998/Math/MathML", t.SVG = "http://www.w3.org/2000/svg", t.XLink = "http://www.w3.org/1999/xlink";
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.enqueue = function(e2, t2) {
          e2.push(t2);
        }, t.dequeue = function(e2) {
          return e2.shift() || null;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__generator || function(e2, t2) {
          var r2, n2, i2, o2, a2 = { label: 0, sent: function() {
            if (1 & i2[0])
              throw i2[1];
            return i2[1];
          }, trys: [], ops: [] };
          return o2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
            return this;
          }), o2;
          function s2(o3) {
            return function(s3) {
              return function(o4) {
                if (r2)
                  throw new TypeError("Generator is already executing.");
                for (; a2; )
                  try {
                    if (r2 = 1, n2 && (i2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((i2 = n2.return) && i2.call(n2), 0) : n2.next) && !(i2 = i2.call(n2, o4[1])).done)
                      return i2;
                    switch (n2 = 0, i2 && (o4 = [2 & o4[0], i2.value]), o4[0]) {
                      case 0:
                      case 1:
                        i2 = o4;
                        break;
                      case 4:
                        return a2.label++, { value: o4[1], done: false };
                      case 5:
                        a2.label++, n2 = o4[1], o4 = [0];
                        continue;
                      case 7:
                        o4 = a2.ops.pop(), a2.trys.pop();
                        continue;
                      default:
                        if (!(i2 = a2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                          a2 = 0;
                          continue;
                        }
                        if (3 === o4[0] && (!i2 || o4[1] > i2[0] && o4[1] < i2[3])) {
                          a2.label = o4[1];
                          break;
                        }
                        if (6 === o4[0] && a2.label < i2[1]) {
                          a2.label = i2[1], i2 = o4;
                          break;
                        }
                        if (i2 && a2.label < i2[2]) {
                          a2.label = i2[2], a2.ops.push(o4);
                          break;
                        }
                        i2[2] && a2.ops.pop(), a2.trys.pop();
                        continue;
                    }
                    o4 = t2.call(e2, a2);
                  } catch (e3) {
                    o4 = [6, e3], n2 = 0;
                  } finally {
                    r2 = i2 = 0;
                  }
                if (5 & o4[0])
                  throw o4[1];
                return { value: o4[0] ? o4[1] : void 0, done: true };
              }([o3, s3]);
            };
          }
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, o = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, a = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(o(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(2);
        function u(e2, t2) {
          var r2, n2;
          try {
            for (var o2 = i(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value;
              if (!t2.has(s2))
                return false;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return true;
        }
        t.append = function(e2, t2) {
          e2.add(t2);
        }, t.extend = function(e2, t2) {
          t2.forEach(e2.add, e2);
        }, t.prepend = function(e2, t2) {
          var r2 = new Set(e2);
          e2.clear(), e2.add(t2), r2.forEach(e2.add, e2);
        }, t.replace = function(e2, t2, r2) {
          var n2, o2, a2 = /* @__PURE__ */ new Set();
          try {
            for (var u2 = i(e2), l = u2.next(); !l.done; l = u2.next()) {
              var c = l.value;
              s.isFunction(t2) ? t2.call(null, c) ? a2.add(r2) : a2.add(c) : c === t2 ? a2.add(r2) : a2.add(c);
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (o2 = u2.return) && o2.call(u2);
            } finally {
              if (n2)
                throw n2.error;
            }
          }
          e2.clear(), a2.forEach(e2.add, e2);
        }, t.insert = function(e2, t2, r2) {
          var n2, o2, a2 = /* @__PURE__ */ new Set(), s2 = 0;
          try {
            for (var u2 = i(e2), l = u2.next(); !l.done; l = u2.next()) {
              var c = l.value;
              s2 === r2 && a2.add(t2), a2.add(c), s2++;
            }
          } catch (e3) {
            n2 = { error: e3 };
          } finally {
            try {
              l && !l.done && (o2 = u2.return) && o2.call(u2);
            } finally {
              if (n2)
                throw n2.error;
            }
          }
          e2.clear(), a2.forEach(e2.add, e2);
        }, t.remove = function(e2, t2) {
          var r2, n2, o2, a2;
          if (s.isFunction(t2)) {
            var u2 = [];
            try {
              for (var l = i(e2), c = l.next(); !c.done; c = l.next()) {
                var h = c.value;
                t2.call(null, h) && u2.push(h);
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                c && !c.done && (n2 = l.return) && n2.call(l);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            try {
              for (var p = i(u2), f = p.next(); !f.done; f = p.next()) {
                var d = f.value;
                e2.delete(d);
              }
            } catch (e3) {
              o2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (a2 = p.return) && a2.call(p);
              } finally {
                if (o2)
                  throw o2.error;
              }
            }
          } else
            e2.delete(t2);
        }, t.empty = function(e2) {
          e2.clear();
        }, t.contains = function(e2, t2) {
          var r2, n2;
          if (!s.isFunction(t2))
            return e2.has(t2);
          try {
            for (var o2 = i(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var u2 = a2.value;
              if (t2.call(null, u2))
                return true;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (n2 = o2.return) && n2.call(o2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return false;
        }, t.size = function(e2, t2) {
          var r2, n2;
          if (void 0 === t2)
            return e2.size;
          var o2 = 0;
          try {
            for (var a2 = i(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              var u2 = s2.value;
              t2.call(null, u2) && o2++;
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = a2.return) && n2.call(a2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return o2;
        }, t.isEmpty = function(e2) {
          return 0 === e2.size;
        }, t.forEach = function(e2, t2) {
          var r2, o2, a2, s2, u2, l;
          return n(this, function(n2) {
            switch (n2.label) {
              case 0:
                return void 0 !== t2 ? [3, 2] : [5, i(e2)];
              case 1:
                return n2.sent(), [3, 9];
              case 2:
                n2.trys.push([2, 7, 8, 9]), r2 = i(e2), o2 = r2.next(), n2.label = 3;
              case 3:
                return o2.done ? [3, 6] : (a2 = o2.value, t2.call(null, a2) ? [4, a2] : [3, 5]);
              case 4:
                n2.sent(), n2.label = 5;
              case 5:
                return o2 = r2.next(), [3, 3];
              case 6:
                return [3, 9];
              case 7:
                return s2 = n2.sent(), u2 = { error: s2 }, [3, 9];
              case 8:
                try {
                  o2 && !o2.done && (l = r2.return) && l.call(r2);
                } finally {
                  if (u2)
                    throw u2.error;
                }
                return [7];
              case 9:
                return [2];
            }
          });
        }, t.clone = function(e2) {
          return new Set(e2);
        }, t.sortInAscendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? -1 : 1;
          }), new Set(r2);
        }, t.sortInDescendingOrder = function(e2, t2) {
          var r2 = new (Array.bind.apply(Array, a([void 0], e2)))();
          return r2.sort(function(e3, r3) {
            return t2.call(null, e3, r3) ? 1 : -1;
          }), new Set(r2);
        }, t.isSubsetOf = u, t.isSupersetOf = function(e2, t2) {
          return u(t2, e2);
        }, t.intersection = function(e2, t2) {
          var r2, n2, o2 = /* @__PURE__ */ new Set();
          try {
            for (var a2 = i(e2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
              var u2 = s2.value;
              t2.has(u2) && o2.add(u2);
            }
          } catch (e3) {
            r2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (n2 = a2.return) && n2.call(a2);
            } finally {
              if (r2)
                throw r2.error;
            }
          }
          return o2;
        }, t.union = function(e2, t2) {
          var r2 = new Set(e2);
          return t2.forEach(r2.add, r2), r2;
        }, t.range = function(e2, t2) {
          for (var r2 = /* @__PURE__ */ new Set(), n2 = e2; n2 <= t2; n2++)
            r2.add(n2);
          return r2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.push = function(e2, t2) {
          e2.push(t2);
        }, t.pop = function(e2) {
          return e2.pop() || null;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(96), o = r(147), a = r(146), s = r(2);
        function u(e2, t2) {
          for (var r2 = 0; ; ) {
            var n2 = r2 < e2.length ? e2.charCodeAt(r2) : null, i2 = r2 < t2.length ? t2.charCodeAt(r2) : null;
            if (null === n2)
              return true;
            if (n2 !== i2)
              return false;
            r2++;
          }
        }
        function l(e2) {
          var t2, r2, i2 = Array.from(e2), o2 = new Uint8Array(i2.length), a2 = 0;
          try {
            for (var s2 = n(e2), u2 = s2.next(); !u2.done; u2 = s2.next()) {
              var l2 = u2.value.codePointAt(0);
              console.assert(void 0 !== l2 && l2 <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF."), void 0 !== l2 && l2 <= 255 && (o2[a2++] = l2);
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              u2 && !u2.done && (r2 = s2.return) && r2.call(s2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          return o2;
        }
        function c(e2) {
          return /^[\u0000-\u007F]*$/.test(e2);
        }
        function h(e2) {
          var t2, r2, i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value, u2 = s2.codePointAt(0);
              i2 += void 0 !== u2 && u2 >= 65 && u2 <= 90 ? String.fromCodePoint(u2 + 32) : s2;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          return i2;
        }
        function p(e2) {
          return e2.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
        }
        function f(e2, t2, r2) {
          if (!s.isArray(t2))
            return f(e2, Array.from(t2), r2);
          for (var n2 = ""; r2.position < t2.length && e2.call(null, t2[r2.position]); )
            n2 += t2[r2.position], r2.position++;
          return n2;
        }
        function d(e2, t2) {
          f(function(e3) {
            return i.ASCIIWhiteSpace.test(e3);
          }, e2, t2);
        }
        t.isCodeUnitPrefix = u, t.isCodeUnitLessThan = function(e2, t2) {
          if (u(t2, e2))
            return false;
          if (u(e2, t2))
            return true;
          for (var r2 = 0; r2 < Math.min(e2.length, t2.length); r2++) {
            var n2 = e2.charCodeAt(r2), i2 = t2.charCodeAt(r2);
            if (n2 !== i2)
              return n2 < i2;
          }
          return false;
        }, t.isomorphicEncode = l, t.isASCIIString = c, t.asciiLowercase = h, t.asciiUppercase = function(e2) {
          var t2, r2, i2 = "";
          try {
            for (var o2 = n(e2), a2 = o2.next(); !a2.done; a2 = o2.next()) {
              var s2 = a2.value, u2 = s2.codePointAt(0);
              i2 += void 0 !== u2 && u2 >= 97 && u2 <= 122 ? String.fromCodePoint(u2 - 32) : s2;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              a2 && !a2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          return i2;
        }, t.asciiCaseInsensitiveMatch = function(e2, t2) {
          return h(e2) === h(t2);
        }, t.asciiEncode = function(e2) {
          return console.assert(c(e2), "asciiEncode requires an ASCII string."), l(e2);
        }, t.asciiDecode = function(e2) {
          var t2, r2;
          try {
            for (var i2 = n(e2), s2 = i2.next(); !s2.done; s2 = i2.next()) {
              var u2 = s2.value;
              console.assert(a.isASCIIByte(u2), "asciiDecode requires an ASCII byte sequence.");
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              s2 && !s2.done && (r2 = i2.return) && r2.call(i2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          return o.isomorphicDecode(e2);
        }, t.stripNewlines = function(e2) {
          return e2.replace(/[\n\r]/g, "");
        }, t.normalizeNewlines = function(e2) {
          return e2.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        }, t.stripLeadingAndTrailingASCIIWhitespace = p, t.stripAndCollapseASCIIWhitespace = function(e2) {
          return p(e2.replace(/[\t\n\f\r ]{2,}/g, " "));
        }, t.collectASequenceOfCodePoints = f, t.skipASCIIWhitespace = d, t.strictlySplit = function e2(t2, r2) {
          if (!s.isArray(t2))
            return e2(Array.from(t2), r2);
          var n2 = { position: 0 }, i2 = [], o2 = f(function(e3) {
            return r2 !== e3;
          }, t2, n2);
          for (i2.push(o2); n2.position < t2.length; )
            console.assert(t2[n2.position] === r2, "strictlySplit found no delimiter in input string."), n2.position++, o2 = f(function(e3) {
              return r2 !== e3;
            }, t2, n2), i2.push(o2);
          return i2;
        }, t.splitAStringOnASCIIWhitespace = function e2(t2) {
          if (!s.isArray(t2))
            return e2(Array.from(t2));
          var r2 = { position: 0 }, n2 = [];
          for (d(t2, r2); r2.position < t2.length; ) {
            var o2 = f(function(e3) {
              return !i.ASCIIWhiteSpace.test(e3);
            }, t2, r2);
            n2.push(o2), d(t2, r2);
          }
          return n2;
        }, t.splitAStringOnCommas = function e2(t2) {
          if (!s.isArray(t2))
            return e2(Array.from(t2));
          for (var r2 = { position: 0 }, n2 = []; r2.position < t2.length; ) {
            var i2 = f(function(e3) {
              return "," !== e3;
            }, t2, r2);
            n2.push(p(i2)), r2.position < t2.length && (console.assert("," === t2[r2.position], "splitAStringOnCommas found no delimiter in input string."), r2.position++);
          }
          return n2;
        }, t.concatenate = function(e2, t2) {
          return void 0 === t2 && (t2 = ""), 0 === e2.length ? "" : e2.join(t2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(97);
        t.abort_add = function(e2, t2) {
          t2._abortedFlag || t2._abortAlgorithms.add(e2);
        }, t.abort_remove = function(e2, t2) {
          t2._abortAlgorithms.delete(e2);
        }, t.abort_signalAbort = function(e2) {
          var t2, r2;
          if (!e2._abortedFlag) {
            e2._abortedFlag = true;
            try {
              for (var o = n(e2._abortAlgorithms), a = o.next(); !a.done; a = o.next()) {
                a.value.call(e2);
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                a && !a.done && (r2 = o.return) && r2.call(o);
              } finally {
                if (t2)
                  throw t2.error;
              }
            }
            e2._abortAlgorithms.clear(), i.event_fireAnEvent("abort", e2);
          }
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(150), i = function() {
          function e2() {
          }
          return e2.asNode = function(e3) {
            if (n.Guard.isNode(e3))
              return e3;
            throw new Error("Invalid object. Node expected.");
          }, e2;
        }();
        t.Cast = i;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "size", { get: function() {
            return 0;
          }, enumerable: true, configurable: true }), e2.prototype.add = function(e3) {
            throw new Error("Cannot add to an empty set.");
          }, e2.prototype.clear = function() {
          }, e2.prototype.delete = function(e3) {
            return false;
          }, e2.prototype.forEach = function(e3, t2) {
          }, e2.prototype.has = function(e3) {
            return false;
          }, e2.prototype[Symbol.iterator] = function() {
            return new i();
          }, e2.prototype.entries = function() {
            return new i();
          }, e2.prototype.keys = function() {
            return new i();
          }, e2.prototype.values = function() {
            return new i();
          }, Object.defineProperty(e2.prototype, Symbol.toStringTag, { get: function() {
            return "EmptySet";
          }, enumerable: true, configurable: true }), e2;
        }();
        t.EmptySet = n;
        var i = function() {
          function e2() {
          }
          return e2.prototype[Symbol.iterator] = function() {
            return this;
          }, e2.prototype.next = function() {
            return { done: true, value: null };
          }, e2;
        }();
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), function(e2) {
          e2[e2.SchemeStart = 0] = "SchemeStart", e2[e2.Scheme = 1] = "Scheme", e2[e2.NoScheme = 2] = "NoScheme", e2[e2.SpecialRelativeOrAuthority = 3] = "SpecialRelativeOrAuthority", e2[e2.PathOrAuthority = 4] = "PathOrAuthority", e2[e2.Relative = 5] = "Relative", e2[e2.RelativeSlash = 6] = "RelativeSlash", e2[e2.SpecialAuthoritySlashes = 7] = "SpecialAuthoritySlashes", e2[e2.SpecialAuthorityIgnoreSlashes = 8] = "SpecialAuthorityIgnoreSlashes", e2[e2.Authority = 9] = "Authority", e2[e2.Host = 10] = "Host", e2[e2.Hostname = 11] = "Hostname", e2[e2.Port = 12] = "Port", e2[e2.File = 13] = "File", e2[e2.FileSlash = 14] = "FileSlash", e2[e2.FileHost = 15] = "FileHost", e2[e2.PathStart = 16] = "PathStart", e2[e2.Path = 17] = "Path", e2[e2.CannotBeABaseURLPath = 18] = "CannotBeABaseURLPath", e2[e2.Query = 19] = "Query", e2[e2.Fragment = 20] = "Fragment";
        }(t.ParserState || (t.ParserState = {})), t.OpaqueOrigin = ["", "", null, null];
      }, function(e, t, r) {
        "use strict";
        var n = r(245), i = r(247);
        function o() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        t.parse = g, t.resolve = function(e2, t2) {
          return g(e2, false, true).resolve(t2);
        }, t.resolveObject = function(e2, t2) {
          return e2 ? g(e2, false, true).resolveObject(t2) : t2;
        }, t.format = function(e2) {
          i.isString(e2) && (e2 = g(e2));
          return e2 instanceof o ? e2.format() : o.prototype.format.call(e2);
        }, t.Url = o;
        var a = /^([a-z0-9.+-]+:)/i, s = /:[0-9]*$/, u = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), c = ["'"].concat(l), h = ["%", "/", "?", ";", "#"].concat(c), p = ["/", "?", "#"], f = /^[+a-z0-9A-Z_-]{0,63}$/, d = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m = { javascript: true, "javascript:": true }, y = { javascript: true, "javascript:": true }, v = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, _ = r(248);
        function g(e2, t2, r2) {
          if (e2 && i.isObject(e2) && e2 instanceof o)
            return e2;
          var n2 = new o();
          return n2.parse(e2, t2, r2), n2;
        }
        o.prototype.parse = function(e2, t2, r2) {
          if (!i.isString(e2))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof e2);
          var o2 = e2.indexOf("?"), s2 = -1 !== o2 && o2 < e2.indexOf("#") ? "?" : "#", l2 = e2.split(s2);
          l2[0] = l2[0].replace(/\\/g, "/");
          var g2 = e2 = l2.join(s2);
          if (g2 = g2.trim(), !r2 && 1 === e2.split("#").length) {
            var b = u.exec(g2);
            if (b)
              return this.path = g2, this.href = g2, this.pathname = b[1], b[2] ? (this.search = b[2], this.query = t2 ? _.parse(this.search.substr(1)) : this.search.substr(1)) : t2 && (this.search = "", this.query = {}), this;
          }
          var x = a.exec(g2);
          if (x) {
            var w = (x = x[0]).toLowerCase();
            this.protocol = w, g2 = g2.substr(x.length);
          }
          if (r2 || x || g2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var E = "//" === g2.substr(0, 2);
            !E || x && y[x] || (g2 = g2.substr(2), this.slashes = true);
          }
          if (!y[x] && (E || x && !v[x])) {
            for (var D, S, C = -1, A = 0; A < p.length; A++) {
              -1 !== (N = g2.indexOf(p[A])) && (-1 === C || N < C) && (C = N);
            }
            -1 !== (S = -1 === C ? g2.lastIndexOf("@") : g2.lastIndexOf("@", C)) && (D = g2.slice(0, S), g2 = g2.slice(S + 1), this.auth = decodeURIComponent(D)), C = -1;
            for (A = 0; A < h.length; A++) {
              var N;
              -1 !== (N = g2.indexOf(h[A])) && (-1 === C || N < C) && (C = N);
            }
            -1 === C && (C = g2.length), this.host = g2.slice(0, C), g2 = g2.slice(C), this.parseHost(), this.hostname = this.hostname || "";
            var T = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!T)
              for (var O = this.hostname.split(/\./), F = (A = 0, O.length); A < F; A++) {
                var k = O[A];
                if (k && !k.match(f)) {
                  for (var P = "", I = 0, L = k.length; I < L; I++)
                    k.charCodeAt(I) > 127 ? P += "x" : P += k[I];
                  if (!P.match(f)) {
                    var M = O.slice(0, A), B = O.slice(A + 1), j = k.match(d);
                    j && (M.push(j[1]), B.unshift(j[2])), B.length && (g2 = "/" + B.join(".") + g2), this.hostname = M.join(".");
                    break;
                  }
                }
              }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), T || (this.hostname = n.toASCII(this.hostname));
            var R = this.port ? ":" + this.port : "", z = this.hostname || "";
            this.host = z + R, this.href += this.host, T && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== g2[0] && (g2 = "/" + g2));
          }
          if (!m[w])
            for (A = 0, F = c.length; A < F; A++) {
              var U = c[A];
              if (-1 !== g2.indexOf(U)) {
                var G = encodeURIComponent(U);
                G === U && (G = escape(U)), g2 = g2.split(U).join(G);
              }
            }
          var X = g2.indexOf("#");
          -1 !== X && (this.hash = g2.substr(X), g2 = g2.slice(0, X));
          var q = g2.indexOf("?");
          if (-1 !== q ? (this.search = g2.substr(q), this.query = g2.substr(q + 1), t2 && (this.query = _.parse(this.query)), g2 = g2.slice(0, q)) : t2 && (this.search = "", this.query = {}), g2 && (this.pathname = g2), v[w] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            R = this.pathname || "";
            var W = this.search || "";
            this.path = R + W;
          }
          return this.href = this.format(), this;
        }, o.prototype.format = function() {
          var e2 = this.auth || "";
          e2 && (e2 = (e2 = encodeURIComponent(e2)).replace(/%3A/i, ":"), e2 += "@");
          var t2 = this.protocol || "", r2 = this.pathname || "", n2 = this.hash || "", o2 = false, a2 = "";
          this.host ? o2 = e2 + this.host : this.hostname && (o2 = e2 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o2 += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (a2 = _.stringify(this.query));
          var s2 = this.search || a2 && "?" + a2 || "";
          return t2 && ":" !== t2.substr(-1) && (t2 += ":"), this.slashes || (!t2 || v[t2]) && false !== o2 ? (o2 = "//" + (o2 || ""), r2 && "/" !== r2.charAt(0) && (r2 = "/" + r2)) : o2 || (o2 = ""), n2 && "#" !== n2.charAt(0) && (n2 = "#" + n2), s2 && "?" !== s2.charAt(0) && (s2 = "?" + s2), t2 + o2 + (r2 = r2.replace(/[?#]/g, function(e3) {
            return encodeURIComponent(e3);
          })) + (s2 = s2.replace("#", "%23")) + n2;
        }, o.prototype.resolve = function(e2) {
          return this.resolveObject(g(e2, false, true)).format();
        }, o.prototype.resolveObject = function(e2) {
          if (i.isString(e2)) {
            var t2 = new o();
            t2.parse(e2, false, true), e2 = t2;
          }
          for (var r2 = new o(), n2 = Object.keys(this), a2 = 0; a2 < n2.length; a2++) {
            var s2 = n2[a2];
            r2[s2] = this[s2];
          }
          if (r2.hash = e2.hash, "" === e2.href)
            return r2.href = r2.format(), r2;
          if (e2.slashes && !e2.protocol) {
            for (var u2 = Object.keys(e2), l2 = 0; l2 < u2.length; l2++) {
              var c2 = u2[l2];
              "protocol" !== c2 && (r2[c2] = e2[c2]);
            }
            return v[r2.protocol] && r2.hostname && !r2.pathname && (r2.path = r2.pathname = "/"), r2.href = r2.format(), r2;
          }
          if (e2.protocol && e2.protocol !== r2.protocol) {
            if (!v[e2.protocol]) {
              for (var h2 = Object.keys(e2), p2 = 0; p2 < h2.length; p2++) {
                var f2 = h2[p2];
                r2[f2] = e2[f2];
              }
              return r2.href = r2.format(), r2;
            }
            if (r2.protocol = e2.protocol, e2.host || y[e2.protocol])
              r2.pathname = e2.pathname;
            else {
              for (var d2 = (e2.pathname || "").split("/"); d2.length && !(e2.host = d2.shift()); )
                ;
              e2.host || (e2.host = ""), e2.hostname || (e2.hostname = ""), "" !== d2[0] && d2.unshift(""), d2.length < 2 && d2.unshift(""), r2.pathname = d2.join("/");
            }
            if (r2.search = e2.search, r2.query = e2.query, r2.host = e2.host || "", r2.auth = e2.auth, r2.hostname = e2.hostname || e2.host, r2.port = e2.port, r2.pathname || r2.search) {
              var m2 = r2.pathname || "", _2 = r2.search || "";
              r2.path = m2 + _2;
            }
            return r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
          }
          var g2 = r2.pathname && "/" === r2.pathname.charAt(0), b = e2.host || e2.pathname && "/" === e2.pathname.charAt(0), x = b || g2 || r2.host && e2.pathname, w = x, E = r2.pathname && r2.pathname.split("/") || [], D = (d2 = e2.pathname && e2.pathname.split("/") || [], r2.protocol && !v[r2.protocol]);
          if (D && (r2.hostname = "", r2.port = null, r2.host && ("" === E[0] ? E[0] = r2.host : E.unshift(r2.host)), r2.host = "", e2.protocol && (e2.hostname = null, e2.port = null, e2.host && ("" === d2[0] ? d2[0] = e2.host : d2.unshift(e2.host)), e2.host = null), x = x && ("" === d2[0] || "" === E[0])), b)
            r2.host = e2.host || "" === e2.host ? e2.host : r2.host, r2.hostname = e2.hostname || "" === e2.hostname ? e2.hostname : r2.hostname, r2.search = e2.search, r2.query = e2.query, E = d2;
          else if (d2.length)
            E || (E = []), E.pop(), E = E.concat(d2), r2.search = e2.search, r2.query = e2.query;
          else if (!i.isNullOrUndefined(e2.search)) {
            if (D)
              r2.hostname = r2.host = E.shift(), (T = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = T.shift(), r2.host = r2.hostname = T.shift());
            return r2.search = e2.search, r2.query = e2.query, i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.href = r2.format(), r2;
          }
          if (!E.length)
            return r2.pathname = null, r2.search ? r2.path = "/" + r2.search : r2.path = null, r2.href = r2.format(), r2;
          for (var S = E.slice(-1)[0], C = (r2.host || e2.host || E.length > 1) && ("." === S || ".." === S) || "" === S, A = 0, N = E.length; N >= 0; N--)
            "." === (S = E[N]) ? E.splice(N, 1) : ".." === S ? (E.splice(N, 1), A++) : A && (E.splice(N, 1), A--);
          if (!x && !w)
            for (; A--; A)
              E.unshift("..");
          !x || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), C && "/" !== E.join("/").substr(-1) && E.push("");
          var T, O = "" === E[0] || E[0] && "/" === E[0].charAt(0);
          D && (r2.hostname = r2.host = O ? "" : E.length ? E.shift() : "", (T = !!(r2.host && r2.host.indexOf("@") > 0) && r2.host.split("@")) && (r2.auth = T.shift(), r2.host = r2.hostname = T.shift()));
          return (x = x || r2.host && E.length) && !O && E.unshift(""), E.length ? r2.pathname = E.join("/") : (r2.pathname = null, r2.path = null), i.isNull(r2.pathname) && i.isNull(r2.search) || (r2.path = (r2.pathname ? r2.pathname : "") + (r2.search ? r2.search : "")), r2.auth = e2.auth || r2.auth, r2.slashes = r2.slashes || e2.slashes, r2.href = r2.format(), r2;
        }, o.prototype.parseHost = function() {
          var e2 = this.host, t2 = s.exec(e2);
          t2 && (":" !== (t2 = t2[0]) && (this.port = t2.substr(1)), e2 = e2.substr(0, e2.length - t2.length)), e2 && (this.hostname = e2);
        };
      }, function(e, t, r) {
        (function(e2, n) {
          var i;
          !function(o) {
            t && t.nodeType, e2 && e2.nodeType;
            var a = "object" == typeof n && n;
            a.global !== a && a.window !== a && a.self;
            var s, u = 2147483647, l = /^xn--/, c = /[^\x20-\x7E]/, h = /[\x2E\u3002\uFF0E\uFF61]/g, p = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, f = Math.floor, d = String.fromCharCode;
            function m(e3) {
              throw new RangeError(p[e3]);
            }
            function y(e3, t2) {
              for (var r2 = e3.length, n2 = []; r2--; )
                n2[r2] = t2(e3[r2]);
              return n2;
            }
            function v(e3, t2) {
              var r2 = e3.split("@"), n2 = "";
              return r2.length > 1 && (n2 = r2[0] + "@", e3 = r2[1]), n2 + y((e3 = e3.replace(h, ".")).split("."), t2).join(".");
            }
            function _(e3) {
              for (var t2, r2, n2 = [], i2 = 0, o2 = e3.length; i2 < o2; )
                (t2 = e3.charCodeAt(i2++)) >= 55296 && t2 <= 56319 && i2 < o2 ? 56320 == (64512 & (r2 = e3.charCodeAt(i2++))) ? n2.push(((1023 & t2) << 10) + (1023 & r2) + 65536) : (n2.push(t2), i2--) : n2.push(t2);
              return n2;
            }
            function g(e3) {
              return y(e3, function(e4) {
                var t2 = "";
                return e4 > 65535 && (t2 += d((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t2 += d(e4);
              }).join("");
            }
            function b(e3, t2) {
              return e3 + 22 + 75 * (e3 < 26) - ((0 != t2) << 5);
            }
            function x(e3, t2, r2) {
              var n2 = 0;
              for (e3 = r2 ? f(e3 / 700) : e3 >> 1, e3 += f(e3 / t2); e3 > 455; n2 += 36)
                e3 = f(e3 / 35);
              return f(n2 + 36 * e3 / (e3 + 38));
            }
            function w(e3) {
              var t2, r2, n2, i2, o2, a2, s2, l2, c2, h2, p2, d2 = [], y2 = e3.length, v2 = 0, _2 = 128, b2 = 72;
              for ((r2 = e3.lastIndexOf("-")) < 0 && (r2 = 0), n2 = 0; n2 < r2; ++n2)
                e3.charCodeAt(n2) >= 128 && m("not-basic"), d2.push(e3.charCodeAt(n2));
              for (i2 = r2 > 0 ? r2 + 1 : 0; i2 < y2; ) {
                for (o2 = v2, a2 = 1, s2 = 36; i2 >= y2 && m("invalid-input"), ((l2 = (p2 = e3.charCodeAt(i2++)) - 48 < 10 ? p2 - 22 : p2 - 65 < 26 ? p2 - 65 : p2 - 97 < 26 ? p2 - 97 : 36) >= 36 || l2 > f((u - v2) / a2)) && m("overflow"), v2 += l2 * a2, !(l2 < (c2 = s2 <= b2 ? 1 : s2 >= b2 + 26 ? 26 : s2 - b2)); s2 += 36)
                  a2 > f(u / (h2 = 36 - c2)) && m("overflow"), a2 *= h2;
                b2 = x(v2 - o2, t2 = d2.length + 1, 0 == o2), f(v2 / t2) > u - _2 && m("overflow"), _2 += f(v2 / t2), v2 %= t2, d2.splice(v2++, 0, _2);
              }
              return g(d2);
            }
            function E(e3) {
              var t2, r2, n2, i2, o2, a2, s2, l2, c2, h2, p2, y2, v2, g2, w2, E2 = [];
              for (y2 = (e3 = _(e3)).length, t2 = 128, r2 = 0, o2 = 72, a2 = 0; a2 < y2; ++a2)
                (p2 = e3[a2]) < 128 && E2.push(d(p2));
              for (n2 = i2 = E2.length, i2 && E2.push("-"); n2 < y2; ) {
                for (s2 = u, a2 = 0; a2 < y2; ++a2)
                  (p2 = e3[a2]) >= t2 && p2 < s2 && (s2 = p2);
                for (s2 - t2 > f((u - r2) / (v2 = n2 + 1)) && m("overflow"), r2 += (s2 - t2) * v2, t2 = s2, a2 = 0; a2 < y2; ++a2)
                  if ((p2 = e3[a2]) < t2 && ++r2 > u && m("overflow"), p2 == t2) {
                    for (l2 = r2, c2 = 36; !(l2 < (h2 = c2 <= o2 ? 1 : c2 >= o2 + 26 ? 26 : c2 - o2)); c2 += 36)
                      w2 = l2 - h2, g2 = 36 - h2, E2.push(d(b(h2 + w2 % g2, 0))), l2 = f(w2 / g2);
                    E2.push(d(b(l2, 0))), o2 = x(r2, v2, n2 == i2), r2 = 0, ++n2;
                  }
                ++r2, ++t2;
              }
              return E2.join("");
            }
            s = { version: "1.4.1", ucs2: { decode: _, encode: g }, decode: w, encode: E, toASCII: function(e3) {
              return v(e3, function(e4) {
                return c.test(e4) ? "xn--" + E(e4) : e4;
              });
            }, toUnicode: function(e3) {
              return v(e3, function(e4) {
                return l.test(e4) ? w(e4.slice(4).toLowerCase()) : e4;
              });
            } }, void 0 === (i = function() {
              return s;
            }.call(t, r, t, e2)) || (e2.exports = i);
          }();
        }).call(this, r(246)(e), r(78));
      }, function(e, t) {
        e.exports = function(e2) {
          return e2.webpackPolyfill || (e2.deprecate = function() {
          }, e2.paths = [], e2.children || (e2.children = []), Object.defineProperty(e2, "loaded", { enumerable: true, get: function() {
            return e2.l;
          } }), Object.defineProperty(e2, "id", { enumerable: true, get: function() {
            return e2.i;
          } }), e2.webpackPolyfill = 1), e2;
        };
      }, function(e, t, r) {
        "use strict";
        e.exports = { isString: function(e2) {
          return "string" == typeof e2;
        }, isObject: function(e2) {
          return "object" == typeof e2 && null !== e2;
        }, isNull: function(e2) {
          return null === e2;
        }, isNullOrUndefined: function(e2) {
          return null == e2;
        } };
      }, function(e, t, r) {
        "use strict";
        t.decode = t.parse = r(249), t.encode = t.stringify = r(250);
      }, function(e, t, r) {
        "use strict";
        function n(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }
        e.exports = function(e2, t2, r2, o) {
          t2 = t2 || "&", r2 = r2 || "=";
          var a = {};
          if ("string" != typeof e2 || 0 === e2.length)
            return a;
          var s = /\+/g;
          e2 = e2.split(t2);
          var u = 1e3;
          o && "number" == typeof o.maxKeys && (u = o.maxKeys);
          var l = e2.length;
          u > 0 && l > u && (l = u);
          for (var c = 0; c < l; ++c) {
            var h, p, f, d, m = e2[c].replace(s, "%20"), y = m.indexOf(r2);
            y >= 0 ? (h = m.substr(0, y), p = m.substr(y + 1)) : (h = m, p = ""), f = decodeURIComponent(h), d = decodeURIComponent(p), n(a, f) ? i(a[f]) ? a[f].push(d) : a[f] = [a[f], d] : a[f] = d;
          }
          return a;
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
      }, function(e, t, r) {
        "use strict";
        var n = function(e2) {
          switch (typeof e2) {
            case "string":
              return e2;
            case "boolean":
              return e2 ? "true" : "false";
            case "number":
              return isFinite(e2) ? e2 : "";
            default:
              return "";
          }
        };
        e.exports = function(e2, t2, r2, s) {
          return t2 = t2 || "&", r2 = r2 || "=", null === e2 && (e2 = void 0), "object" == typeof e2 ? o(a(e2), function(a2) {
            var s2 = encodeURIComponent(n(a2)) + r2;
            return i(e2[a2]) ? o(e2[a2], function(e3) {
              return s2 + encodeURIComponent(n(e3));
            }).join(t2) : s2 + encodeURIComponent(n(e2[a2]));
          }).join(t2) : s ? encodeURIComponent(n(s)) + r2 + encodeURIComponent(n(e2)) : "";
        };
        var i = Array.isArray || function(e2) {
          return "[object Array]" === Object.prototype.toString.call(e2);
        };
        function o(e2, t2) {
          if (e2.map)
            return e2.map(t2);
          for (var r2 = [], n2 = 0; n2 < e2.length; n2++)
            r2.push(t2(e2[n2], n2));
          return r2;
        }
        var a = Object.keys || function(e2) {
          var t2 = [];
          for (var r2 in e2)
            Object.prototype.hasOwnProperty.call(e2, r2) && t2.push(r2);
          return t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(52);
        t.attr_setAnExistingAttributeValue = function(e2, t2) {
          null === e2._element ? e2._value = t2 : n.element_change(e2, e2._element, t2);
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(108), i = r(30), o = r(52);
        t.tokenList_validationSteps = function(e2, t2) {
          if (!i.dom_hasSupportedTokens(e2._attribute._localName))
            throw new TypeError("There are no supported tokens defined for attribute name: '" + e2._attribute._localName + "'.");
          return i.dom_getSupportedTokens(e2._attribute._localName).has(t2.toLowerCase());
        }, t.tokenList_updateSteps = function(e2) {
          (e2._element.hasAttribute(e2._attribute._localName) || 0 !== e2._tokenSet.size) && o.element_setAnAttributeValue(e2._element, e2._attribute._localName, n.orderedSet_serialize(e2._tokenSet));
        }, t.tokenList_serializeSteps = function(e2) {
          return o.element_getAnAttributeValue(e2._element, e2._attribute._localName);
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(2);
        function o(e2) {
          return i.isBoolean(e2) ? e2 : e2.capture || false;
        }
        t.eventTarget_flatten = o, t.eventTarget_flattenMore = function(e2) {
          var t2 = o(e2), r2 = false, n2 = false;
          return i.isBoolean(e2) || (r2 = e2.once || false, n2 = e2.passive || false), [t2, n2, r2];
        }, t.eventTarget_addEventListener = function(e2, t2) {
          if (null !== t2.callback) {
            for (var r2 = 0; r2 < e2._eventListenerList.length; r2++) {
              var n2 = e2._eventListenerList[r2];
              if (n2.type === t2.type && n2.callback.handleEvent === t2.callback.handleEvent && n2.capture === t2.capture)
                return;
            }
            e2._eventListenerList.push(t2);
          }
        }, t.eventTarget_removeEventListener = function(e2, t2, r2) {
          t2.removed = true, e2._eventListenerList.splice(r2, 1);
        }, t.eventTarget_removeAllEventListeners = function(e2) {
          var t2, r2;
          try {
            for (var i2 = n(e2._eventListenerList), o2 = i2.next(); !o2.done; o2 = i2.next()) {
              o2.value.removed = true;
            }
          } catch (e3) {
            t2 = { error: e3 };
          } finally {
            try {
              o2 && !o2.done && (r2 = i2.return) && r2.call(i2);
            } finally {
              if (t2)
                throw t2.error;
            }
          }
          e2._eventListenerList.length = 0;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(2), o = r(29);
        t.parentNode_convertNodesIntoANode = function(e2, t2) {
          for (var r2, a, s = null, u = 0; u < e2.length; u++) {
            var l = e2[u];
            if (i.isString(l)) {
              var c = o.create_text(t2, l);
              e2[u] = c;
            }
          }
          if (1 === e2.length)
            s = e2[0];
          else {
            var h = s = o.create_documentFragment(t2);
            try {
              for (var p = n(e2), f = p.next(); !f.done; f = p.next()) {
                l = f.value;
                h.appendChild(l);
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                f && !f.done && (a = p.return) && a.call(p);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }
          return s;
        };
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, i = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, o = this && this.__spread || function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
            e2 = e2.concat(i(arguments[t2]));
          return e2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(1), s = r(9), u = r(3), l = r(29), c = r(17), h = r(175), p = r(107), f = r(176), d = r(37), m = r(177);
        function y(e2) {
          return e2._startNode === e2._endNode && e2._startOffset === e2._endOffset;
        }
        function v(e2) {
          return c.tree_rootNode(e2._startNode);
        }
        function _(e2, t2) {
          return c.tree_rootNode(e2) === v(t2) && h.boundaryPoint_position([e2, 0], t2._start) === a.BoundaryPosition.After && h.boundaryPoint_position([e2, c.tree_nodeLength(e2)], t2._end) === a.BoundaryPosition.Before;
        }
        function g(e2, t2) {
          var r2 = c.tree_isAncestorOf(t2._startNode, e2, true), n2 = c.tree_isAncestorOf(t2._endNode, e2, true);
          return r2 && !n2 || !r2 && n2;
        }
        function b(e2) {
          var t2, r2, i2, a2, h2, m2, v2 = l.create_documentFragment(e2._startNode._nodeDocument);
          if (y(e2))
            return v2;
          var x = e2._startNode, w = e2._startOffset, E = e2._endNode, D = e2._endOffset;
          if (x === E && u.Guard.isCharacterDataNode(x))
            return (R = f.node_clone(x))._data = p.characterData_substringData(x, w, D - w), d.mutation_append(R, v2), p.characterData_replaceData(x, w, D - w, ""), v2;
          for (var S = x; !c.tree_isAncestorOf(E, S, true); ) {
            if (null === S._parent)
              throw new Error("Parent node  is null.");
            S = S._parent;
          }
          var C = null;
          if (!c.tree_isAncestorOf(E, x, true))
            try {
              for (var A = n(S._children), N = A.next(); !N.done; N = A.next()) {
                if (g(k = N.value, e2)) {
                  C = k;
                  break;
                }
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                N && !N.done && (r2 = A.return) && r2.call(A);
              } finally {
                if (t2)
                  throw t2.error;
              }
            }
          var T = null;
          if (!c.tree_isAncestorOf(x, E, true))
            for (var O = o(S._children), F = O.length - 1; F > 0; F--) {
              var k;
              if (g(k = O[F], e2)) {
                T = k;
                break;
              }
            }
          var P, I, L = [];
          try {
            for (var M = n(S._children), B = M.next(); !B.done; B = M.next()) {
              if (_(X = B.value, e2)) {
                if (u.Guard.isDocumentTypeNode(X))
                  throw new s.HierarchyRequestError();
                L.push(X);
              }
            }
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              B && !B.done && (a2 = M.return) && a2.call(M);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          if (c.tree_isAncestorOf(E, x, true))
            P = x, I = w;
          else {
            for (var j = x; null !== j._parent && !c.tree_isAncestorOf(E, j._parent); )
              j = j._parent;
            if (null === j._parent)
              throw new Error("Parent node is null.");
            P = j._parent, I = 1 + c.tree_index(j);
          }
          if (u.Guard.isCharacterDataNode(C))
            (R = f.node_clone(x))._data = p.characterData_substringData(x, w, c.tree_nodeLength(x) - w), d.mutation_append(R, v2), p.characterData_replaceData(x, w, c.tree_nodeLength(x) - w, "");
          else if (null !== C) {
            var R = f.node_clone(C);
            d.mutation_append(R, v2);
            var z = b(l.create_range([x, w], [C, c.tree_nodeLength(C)]));
            d.mutation_append(z, R);
          }
          try {
            for (var U = n(L), G = U.next(); !G.done; G = U.next()) {
              var X = G.value;
              d.mutation_append(X, v2);
            }
          } catch (e3) {
            h2 = { error: e3 };
          } finally {
            try {
              G && !G.done && (m2 = U.return) && m2.call(U);
            } finally {
              if (h2)
                throw h2.error;
            }
          }
          if (u.Guard.isCharacterDataNode(T))
            (R = f.node_clone(E))._data = p.characterData_substringData(E, 0, D), d.mutation_append(R, v2), p.characterData_replaceData(E, 0, D, "");
          else if (null !== T) {
            R = f.node_clone(T);
            d.mutation_append(R, v2);
            z = b(l.create_range([T, 0], [E, D]));
            d.mutation_append(z, R);
          }
          return e2._start = [P, I], e2._end = [P, I], v2;
        }
        t.range_collapsed = y, t.range_root = v, t.range_isContained = _, t.range_isPartiallyContained = g, t.range_setTheStart = function(e2, t2, r2) {
          if (u.Guard.isDocumentTypeNode(t2))
            throw new s.InvalidNodeTypeError();
          if (r2 > c.tree_nodeLength(t2))
            throw new s.IndexSizeError();
          var n2 = [t2, r2];
          v(e2) === c.tree_rootNode(t2) && h.boundaryPoint_position(n2, e2._end) !== a.BoundaryPosition.After || (e2._end = n2), e2._start = n2;
        }, t.range_setTheEnd = function(e2, t2, r2) {
          if (u.Guard.isDocumentTypeNode(t2))
            throw new s.InvalidNodeTypeError();
          if (r2 > c.tree_nodeLength(t2))
            throw new s.IndexSizeError();
          var n2 = [t2, r2];
          v(e2) === c.tree_rootNode(t2) && h.boundaryPoint_position(n2, e2._start) !== a.BoundaryPosition.Before || (e2._start = n2), e2._end = n2;
        }, t.range_select = function(e2, t2) {
          var r2 = e2._parent;
          if (null === r2)
            throw new s.InvalidNodeTypeError();
          var n2 = c.tree_index(e2);
          t2._start = [r2, n2], t2._end = [r2, n2 + 1];
        }, t.range_extract = b, t.range_cloneTheContents = function e2(t2) {
          var r2, i2, a2, h2, m2, v2, x = l.create_documentFragment(t2._startNode._nodeDocument);
          if (y(t2))
            return x;
          var w = t2._startNode, E = t2._startOffset, D = t2._endNode, S = t2._endOffset;
          w === D && u.Guard.isCharacterDataNode(w) && ((B = f.node_clone(w))._data = p.characterData_substringData(w, E, S - E), d.mutation_append(B, x));
          for (var C = w; !c.tree_isAncestorOf(D, C, true); ) {
            if (null === C._parent)
              throw new Error("Parent node  is null.");
            C = C._parent;
          }
          var A = null;
          if (!c.tree_isAncestorOf(D, w, true))
            try {
              for (var N = n(C._children), T = N.next(); !T.done; T = N.next()) {
                if (g(P = T.value, t2)) {
                  A = P;
                  break;
                }
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                T && !T.done && (i2 = N.return) && i2.call(N);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          var O = null;
          if (!c.tree_isAncestorOf(w, D, true))
            for (var F = o(C._children), k = F.length - 1; k > 0; k--) {
              var P;
              if (g(P = F[k], t2)) {
                O = P;
                break;
              }
            }
          var I = [];
          try {
            for (var L = n(C._children), M = L.next(); !M.done; M = L.next()) {
              if (_(U = M.value, t2)) {
                if (u.Guard.isDocumentTypeNode(U))
                  throw new s.HierarchyRequestError();
                I.push(U);
              }
            }
          } catch (e3) {
            a2 = { error: e3 };
          } finally {
            try {
              M && !M.done && (h2 = L.return) && h2.call(L);
            } finally {
              if (a2)
                throw a2.error;
            }
          }
          if (u.Guard.isCharacterDataNode(A))
            (B = f.node_clone(w))._data = p.characterData_substringData(w, E, c.tree_nodeLength(w) - E), d.mutation_append(B, x);
          else if (null !== A) {
            var B = f.node_clone(A);
            d.mutation_append(B, x);
            var j = e2(l.create_range([w, E], [A, c.tree_nodeLength(A)]));
            d.mutation_append(j, B);
          }
          try {
            for (var R = n(I), z = R.next(); !z.done; z = R.next()) {
              var U = z.value, B = f.node_clone(U);
              d.mutation_append(B, x);
            }
          } catch (e3) {
            m2 = { error: e3 };
          } finally {
            try {
              z && !z.done && (v2 = R.return) && v2.call(R);
            } finally {
              if (m2)
                throw m2.error;
            }
          }
          if (u.Guard.isCharacterDataNode(O))
            (B = f.node_clone(D))._data = p.characterData_substringData(D, 0, S), d.mutation_append(B, x);
          else if (null !== O) {
            B = f.node_clone(O);
            x.append(B);
            j = b(l.create_range([O, 0], [D, S]));
            d.mutation_append(j, B);
          }
          return x;
        }, t.range_insert = function(e2, t2) {
          var r2, i2;
          if (u.Guard.isProcessingInstructionNode(t2._startNode) || u.Guard.isCommentNode(t2._startNode) || u.Guard.isTextNode(t2._startNode) && null === t2._startNode._parent || t2._startNode === e2)
            throw new s.HierarchyRequestError();
          var o2, a2 = null;
          if (u.Guard.isTextNode(t2._startNode))
            a2 = t2._startNode;
          else {
            var l2 = 0;
            try {
              for (var h2 = n(t2._startNode._children), p2 = h2.next(); !p2.done; p2 = h2.next()) {
                var f2 = p2.value;
                if (l2 === t2._startOffset) {
                  a2 = f2;
                  break;
                }
                l2++;
              }
            } catch (e3) {
              r2 = { error: e3 };
            } finally {
              try {
                p2 && !p2.done && (i2 = h2.return) && i2.call(h2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
          }
          if (null === a2)
            o2 = t2._startNode;
          else {
            if (null === a2._parent)
              throw new Error("Parent node is null.");
            o2 = a2._parent;
          }
          d.mutation_ensurePreInsertionValidity(e2, o2, a2), u.Guard.isTextNode(t2._startNode) && (a2 = m.text_split(t2._startNode, t2._startOffset)), e2 === a2 && (a2 = e2._nextSibling), null !== e2._parent && d.mutation_remove(e2, e2._parent);
          var v2 = null === a2 ? c.tree_nodeLength(o2) : c.tree_index(a2);
          u.Guard.isDocumentFragmentNode(e2) ? v2 += c.tree_nodeLength(e2) : v2++, d.mutation_preInsert(e2, o2, a2), y(t2) && (t2._end = [o2, v2]);
        }, t.range_getContainedNodes = function(e2) {
          var t2;
          return (t2 = {})[Symbol.iterator] = function() {
            var t3 = e2.commonAncestorContainer, r2 = c.tree_getFirstDescendantNode(t3);
            return { next: function() {
              for (; r2 && !_(r2, e2); )
                r2 = c.tree_getNextDescendantNode(t3, r2);
              if (null === r2)
                return { done: true, value: null };
              var n2 = { done: false, value: r2 };
              return r2 = c.tree_getNextDescendantNode(t3, r2), n2;
            } };
          }, t2;
        }, t.range_getPartiallyContainedNodes = function(e2) {
          var t2;
          return (t2 = {})[Symbol.iterator] = function() {
            var t3 = e2.commonAncestorContainer, r2 = c.tree_getFirstDescendantNode(t3);
            return { next: function() {
              for (; r2 && !g(r2, e2); )
                r2 = c.tree_getNextDescendantNode(t3, r2);
              if (null === r2)
                return { done: true, value: null };
              var n2 = { done: false, value: r2 };
              return r2 = c.tree_getNextDescendantNode(t3, r2), n2;
            } };
          }, t2;
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(9);
        t.selectors_scopeMatchASelectorsString = function(e2, t2) {
          throw new n.NotSupportedError();
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(1), i = r(105);
        t.treeWalker_traverseChildren = function(e2, t2) {
          for (var r2 = t2 ? e2._current._firstChild : e2._current._lastChild; null !== r2; ) {
            var o = i.traversal_filter(e2, r2);
            if (o === n.FilterResult.Accept)
              return e2._current = r2, r2;
            if (o === n.FilterResult.Skip) {
              var a = t2 ? r2._firstChild : r2._lastChild;
              if (null !== a) {
                r2 = a;
                continue;
              }
            }
            for (; null !== r2; ) {
              var s = t2 ? r2._nextSibling : r2._previousSibling;
              if (null !== s) {
                r2 = s;
                break;
              }
              var u = r2._parent;
              if (null === u || u === e2._root || u === e2._current)
                return null;
              r2 = u;
            }
          }
          return null;
        }, t.treeWalker_traverseSiblings = function(e2, t2) {
          var r2 = e2._current;
          if (r2 === e2._root)
            return null;
          for (; ; ) {
            for (var o = t2 ? r2._nextSibling : r2._previousSibling; null !== o; ) {
              r2 = o;
              var a = i.traversal_filter(e2, r2);
              if (a === n.FilterResult.Accept)
                return e2._current = r2, r2;
              o = t2 ? r2._firstChild : r2._lastChild, a !== n.FilterResult.Reject && null !== o || (o = t2 ? r2._nextSibling : r2._previousSibling);
            }
            if (null === (r2 = r2._parent) || r2 === e2._root)
              return null;
            if (i.traversal_filter(e2, r2) === n.FilterResult.Accept)
              return null;
          }
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.nonEntityAmpersandRegex = /&(?![A-Za-z]+;|#\d+;)/g;
      }, function(e, t, r) {
        "use strict";
        r(89), r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(2), a = r(1), s = r(50), u = r(3), l = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._indentation = {}, n2._lengthToLastNewline = 0, n2._writerOptions = o.applyDefaults(r2, { wellFormed: false, headless: false, prettyPrint: false, indent: "  ", newline: "\n", offset: 0, width: 0, allowEmptyTags: false, indentTextOnlyNodes: false, spaceBeforeSlash: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            return this._refs = { suppressPretty: false, emptyNode: false, markup: "" }, e3.nodeType !== a.NodeType.Document || this._writerOptions.headless || this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone), this.serializeNode(e3, this._writerOptions.wellFormed), this._writerOptions.prettyPrint && this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline && (this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length)), this._refs.markup;
          }, t2.prototype.declaration = function(e3, t3, r2) {
            this._beginLine(), this._refs.markup += '<?xml version="' + e3 + '"', void 0 !== t3 && (this._refs.markup += ' encoding="' + t3 + '"'), void 0 !== r2 && (this._refs.markup += ' standalone="' + (r2 ? "yes" : "no") + '"'), this._refs.markup += "?>", this._endLine();
          }, t2.prototype.docType = function(e3, t3, r2) {
            this._beginLine(), this._refs.markup += t3 && r2 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '" "' + r2 + '">' : t3 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '">' : r2 ? "<!DOCTYPE " + e3 + ' SYSTEM "' + r2 + '">' : "<!DOCTYPE " + e3 + ">", this._endLine();
          }, t2.prototype.openTagBegin = function(e3) {
            this._beginLine(), this._refs.markup += "<" + e3;
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            if (this._refs.suppressPretty = false, this._refs.emptyNode = false, this._writerOptions.prettyPrint && !t3 && !r2) {
              for (var n2 = true, i2 = true, o2 = this.currentNode.firstChild, a2 = 0, s2 = 0; o2; ) {
                if (u.Guard.isExclusiveTextNode(o2))
                  s2++;
                else {
                  if (!u.Guard.isCDATASectionNode(o2)) {
                    n2 = false, i2 = false;
                    break;
                  }
                  a2++;
                }
                "" !== o2.data && (i2 = false), o2 = o2.nextSibling;
              }
              this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && n2 && (a2 <= 1 && 0 === s2 || 0 === a2), this._refs.emptyNode = i2;
            }
            (r2 || t3 || this._refs.emptyNode) && this._writerOptions.allowEmptyTags ? this._refs.markup += "></" + e3 + ">" : this._refs.markup += r2 ? " />" : t3 || this._refs.emptyNode ? this._writerOptions.spaceBeforeSlash ? " />" : "/>" : ">", this._endLine();
          }, t2.prototype.closeTag = function(e3) {
            this._refs.emptyNode || (this._beginLine(), this._refs.markup += "</" + e3 + ">"), this._refs.suppressPretty = false, this._refs.emptyNode = false, this._endLine();
          }, t2.prototype.attribute = function(e3, t3) {
            var r2 = e3 + '="' + t3 + '"';
            this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._refs.markup.length - this._lengthToLastNewline + 1 + r2.length > this._writerOptions.width ? (this._endLine(), this._beginLine(), this._refs.markup += this._indent(1) + r2) : this._refs.markup += " " + r2;
          }, t2.prototype.text = function(e3) {
            "" !== e3 && (this._beginLine(), this._refs.markup += e3, this._endLine());
          }, t2.prototype.cdata = function(e3) {
            "" !== e3 && (this._beginLine(), this._refs.markup += "<![CDATA[" + e3 + "]]>", this._endLine());
          }, t2.prototype.comment = function(e3) {
            this._beginLine(), this._refs.markup += "<!--" + e3 + "-->", this._endLine();
          }, t2.prototype.instruction = function(e3, t3) {
            this._beginLine(), this._refs.markup += "<?" + ("" === t3 ? e3 : e3 + " " + t3) + "?>", this._endLine();
          }, t2.prototype._beginLine = function() {
            this._writerOptions.prettyPrint && !this._refs.suppressPretty && (this._refs.markup += this._indent(this._writerOptions.offset + this.level));
          }, t2.prototype._endLine = function() {
            this._writerOptions.prettyPrint && !this._refs.suppressPretty && (this._refs.markup += this._writerOptions.newline, this._lengthToLastNewline = this._refs.markup.length);
          }, t2.prototype._indent = function(e3) {
            if (e3 <= 0)
              return "";
            if (void 0 !== this._indentation[e3])
              return this._indentation[e3];
            var t3 = this._writerOptions.indent.repeat(e3);
            return this._indentation[e3] = t3, t3;
          }, t2;
        }(s.BaseWriter);
        t.XMLWriter = l;
      }, function(e, t, r) {
        "use strict";
        var n = r(47), i = r(35);
        e.exports = "".repeat || function(e2) {
          var t2 = String(i(this)), r2 = "", o = n(e2);
          if (o < 0 || o == 1 / 0)
            throw RangeError("Wrong number of repetitions");
          for (; o > 0; (o >>>= 1) && (t2 += t2))
            1 & o && (r2 += t2);
          return r2;
        };
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(178), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(67), s = r(2), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            return n2._writerOptions = s.applyDefaults(r2, { wellFormed: false, prettyPrint: false, indent: "  ", newline: "\n", offset: 0, group: false, verbose: false }), n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            var t3 = s.applyDefaults(this._writerOptions, { format: "object", wellFormed: false }), r2 = new a.ObjectWriter(this._builderOptions, t3).serialize(e3);
            return this._beginLine(this._writerOptions, 0) + this._convertObject(r2, this._writerOptions);
          }, t2.prototype._convertObject = function(e3, t3, r2) {
            var n2, i2, a2 = this;
            void 0 === r2 && (r2 = 0);
            var u2 = "", l = this._isLeafNode(e3);
            if (s.isArray(e3)) {
              u2 += "[";
              var c = e3.length, h = 0;
              try {
                for (var p = o(e3), f = p.next(); !f.done; f = p.next()) {
                  var d = f.value;
                  u2 += this._endLine(t3, r2 + 1) + this._beginLine(t3, r2 + 1) + this._convertObject(d, t3, r2 + 1), h < c - 1 && (u2 += ","), h++;
                }
              } catch (e4) {
                n2 = { error: e4 };
              } finally {
                try {
                  f && !f.done && (i2 = p.return) && i2.call(p);
                } finally {
                  if (n2)
                    throw n2.error;
                }
              }
              u2 += this._endLine(t3, r2) + this._beginLine(t3, r2), u2 += "]";
            } else if (s.isObject(e3)) {
              u2 += "{";
              var m = s.objectLength(e3), y = 0;
              s.forEachObject(e3, function(e4, n3) {
                l && t3.prettyPrint ? u2 += " " : u2 += a2._endLine(t3, r2 + 1) + a2._beginLine(t3, r2 + 1), u2 += a2._key(e4), t3.prettyPrint && (u2 += " "), u2 += a2._convertObject(n3, t3, r2 + 1), y < m - 1 && (u2 += ","), y++;
              }, this), l && t3.prettyPrint ? u2 += " " : u2 += this._endLine(t3, r2) + this._beginLine(t3, r2), u2 += "}";
            } else
              u2 += this._val(e3);
            return u2;
          }, t2.prototype._beginLine = function(e3, t3) {
            if (!e3.prettyPrint)
              return "";
            var r2 = e3.offset + t3 + 1;
            return r2 > 0 ? new Array(r2).join(e3.indent) : "";
          }, t2.prototype._endLine = function(e3, t3) {
            return e3.prettyPrint ? e3.newline : "";
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2.prototype._isLeafNode = function(e3) {
            return this._descendantCount(e3) <= 1;
          }, t2.prototype._descendantCount = function(e3, t3) {
            var r2 = this;
            return void 0 === t3 && (t3 = 0), s.isArray(e3) ? s.forEachArray(e3, function(e4) {
              return t3 += r2._descendantCount(e4, t3);
            }, this) : s.isObject(e3) ? s.forEachObject(e3, function(e4, n2) {
              return t3 += r2._descendantCount(n2, t3);
            }, this) : t3++, t3;
          }, t2;
        }(r(50).BaseWriter);
        t.JSONWriter = u;
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(178), r(89), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var a = r(67), s = r(2), u = function(e2) {
          function t2(t3, r2) {
            var n2 = e2.call(this, t3) || this;
            if (n2._writerOptions = s.applyDefaults(r2, { wellFormed: false, indent: "  ", newline: "\n", offset: 0, group: false, verbose: false }), n2._writerOptions.indent.length < 2)
              throw new Error("YAML indententation string must be at least two characters long.");
            if (n2._writerOptions.offset < 0)
              throw new Error("YAML offset should be zero or a positive number.");
            return n2;
          }
          return i(t2, e2), t2.prototype.serialize = function(e3) {
            var t3 = s.applyDefaults(this._writerOptions, { format: "object", wellFormed: false }), r2 = new a.ObjectWriter(this._builderOptions, t3).serialize(e3), n2 = this._beginLine(this._writerOptions, 0) + "---" + this._endLine(this._writerOptions) + this._convertObject(r2, this._writerOptions, 0);
            return n2.slice(-this._writerOptions.newline.length) === this._writerOptions.newline && (n2 = n2.slice(0, -this._writerOptions.newline.length)), n2;
          }, t2.prototype._convertObject = function(e3, t3, r2, n2) {
            var i2, a2, u2 = this;
            void 0 === n2 && (n2 = false);
            var l = "";
            if (s.isArray(e3))
              try {
                for (var c = o(e3), h = c.next(); !h.done; h = c.next()) {
                  var p = h.value;
                  l += this._beginLine(t3, r2, true), s.isObject(p) ? s.isEmpty(p) ? l += '""' + this._endLine(t3) : l += this._convertObject(p, t3, r2, true) : l += this._val(p) + this._endLine(t3);
                }
              } catch (e4) {
                i2 = { error: e4 };
              } finally {
                try {
                  h && !h.done && (a2 = c.return) && a2.call(c);
                } finally {
                  if (i2)
                    throw i2.error;
                }
              }
            else
              s.forEachObject(e3, function(e4, i3) {
                n2 ? (l += u2._key(e4), n2 = false) : l += u2._beginLine(t3, r2) + u2._key(e4), s.isObject(i3) ? s.isEmpty(i3) ? l += ' ""' + u2._endLine(t3) : l += u2._endLine(t3) + u2._convertObject(i3, t3, r2 + 1) : l += " " + u2._val(i3) + u2._endLine(t3);
              }, this);
            return l;
          }, t2.prototype._beginLine = function(e3, t3, r2) {
            void 0 === r2 && (r2 = false);
            var n2 = e3.offset + t3 + 1, i2 = new Array(n2).join(e3.indent);
            return r2 ? i2.substr(0, i2.length - 2) + "-" + i2.substr(-1, 1) : i2;
          }, t2.prototype._endLine = function(e3) {
            return e3.newline;
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2;
        }(r(50).BaseWriter);
        t.YAMLWriter = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), r(110).dom.setFeatures(true);
        var n = r(110);
        t.DOMImplementation = n.DOMImplementation;
        var i = r(272);
        t.DOMParser = i.DOMParser;
        var o = r(275);
        t.XMLSerializer = o.XMLSerializer;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(3), i = r(0), o = function() {
          function e2() {
          }
          return e2.prototype.before = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++)
              e3[t2] = arguments[t2];
            var r2 = n.Cast.asNode(this), o2 = r2._parent;
            if (null !== o2) {
              for (var a = r2._previousSibling, s = true; s && a; ) {
                s = false;
                for (var u = 0; u < e3.length; u++) {
                  var l = e3[u];
                  if (l === a) {
                    a = a._previousSibling, s = true;
                    break;
                  }
                }
              }
              var c = i.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
              a = null === a ? o2._firstChild : a._nextSibling, i.mutation_preInsert(c, o2, a);
            }
          }, e2.prototype.after = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++)
              e3[t2] = arguments[t2];
            var r2 = n.Cast.asNode(this), o2 = r2._parent;
            if (o2) {
              for (var a = r2._nextSibling, s = true; s && a; ) {
                s = false;
                for (var u = 0; u < e3.length; u++) {
                  var l = e3[u];
                  if (l === a) {
                    a = a._nextSibling, s = true;
                    break;
                  }
                }
              }
              var c = i.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
              i.mutation_preInsert(c, o2, a);
            }
          }, e2.prototype.replaceWith = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++)
              e3[t2] = arguments[t2];
            var r2 = n.Cast.asNode(this), o2 = r2._parent;
            if (o2) {
              for (var a = r2._nextSibling, s = true; s && a; ) {
                s = false;
                for (var u = 0; u < e3.length; u++) {
                  var l = e3[u];
                  if (l === a) {
                    a = a._nextSibling, s = true;
                    break;
                  }
                }
              }
              var c = i.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
              r2._parent === o2 ? i.mutation_replace(r2, c, o2) : i.mutation_preInsert(c, o2, a);
            }
          }, e2.prototype.remove = function() {
            var e3 = n.Cast.asNode(this), t2 = e3._parent;
            t2 && i.mutation_remove(e3, t2);
          }, e2;
        }();
        t.ChildNodeImpl = o;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = function() {
        };
        t.DocumentOrShadowRootImpl = n;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(6), o = r(3), a = r(7), s = function() {
          function e2(e3) {
            this._nodeList = [], this._recordQueue = [], this._callback = e3;
            var t2 = i.dom.window;
            a.set.append(t2._mutationObservers, this);
          }
          return e2.prototype.observe = function(e3, t2) {
            var r2, i2;
            if (void 0 === (t2 = t2 || { childList: false, subtree: false }).attributeOldValue && void 0 === t2.attributeFilter || void 0 !== t2.attributes || (t2.attributes = true), void 0 !== t2.characterDataOldValue && void 0 === t2.characterData && (t2.characterData = true), !t2.childList && !t2.attributes && !t2.characterData)
              throw new TypeError();
            if (t2.attributeOldValue && !t2.attributes)
              throw new TypeError();
            if (void 0 !== t2.attributeFilter && !t2.attributes)
              throw new TypeError();
            if (t2.characterDataOldValue && !t2.characterData)
              throw new TypeError();
            var s2 = false, u = t2, l = function(e4) {
              var t3, r3;
              if (e4.observer === c) {
                s2 = true;
                try {
                  for (var i3 = (t3 = void 0, n(c._nodeList)), l2 = i3.next(); !l2.done; l2 = i3.next()) {
                    var h2 = l2.value;
                    a.list.remove(h2._registeredObserverList, function(t4) {
                      return o.Guard.isTransientRegisteredObserver(t4) && t4.source === e4;
                    });
                  }
                } catch (e5) {
                  t3 = { error: e5 };
                } finally {
                  try {
                    l2 && !l2.done && (r3 = i3.return) && r3.call(i3);
                  } finally {
                    if (t3)
                      throw t3.error;
                  }
                }
                e4.options = u;
              }
            }, c = this;
            try {
              for (var h = n(e3._registeredObserverList), p = h.next(); !p.done; p = h.next()) {
                l(p.value);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                p && !p.done && (i2 = h.return) && i2.call(h);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            s2 || (e3._registeredObserverList.push({ observer: this, options: t2 }), this._nodeList.push(e3));
          }, e2.prototype.disconnect = function() {
            var e3, t2, r2 = this;
            try {
              for (var i2 = n(this._nodeList), o2 = i2.next(); !o2.done; o2 = i2.next()) {
                var s2 = o2.value;
                a.list.remove(s2._registeredObserverList, function(e4) {
                  return e4.observer === r2;
                });
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                o2 && !o2.done && (t2 = i2.return) && t2.call(i2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            this._recordQueue = [];
          }, e2.prototype.takeRecords = function() {
            var e3 = this._recordQueue;
            return this._recordQueue = [], e3;
          }, e2;
        }();
        t.MutationObserverImpl = s;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(3), i = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "previousElementSibling", { get: function() {
            for (var e3 = n.Cast.asNode(this)._previousSibling; e3; ) {
              if (n.Guard.isElementNode(e3))
                return e3;
              e3 = e3._previousSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "nextElementSibling", { get: function() {
            for (var e3 = n.Cast.asNode(this)._nextSibling; e3; ) {
              if (n.Guard.isElementNode(e3))
                return e3;
              e3 = e3._nextSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), e2;
        }();
        t.NonDocumentTypeChildNodeImpl = i;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(3), i = r(0), o = function() {
          function e2() {
          }
          return e2.prototype.getElementById = function(e3) {
            for (var t2 = i.tree_getFirstDescendantNode(n.Cast.asNode(this), false, false, function(e4) {
              return n.Guard.isElementNode(e4);
            }); null !== t2; ) {
              if (t2._uniqueIdentifier === e3)
                return t2;
              t2 = i.tree_getNextDescendantNode(n.Cast.asNode(this), t2, false, false, function(e4) {
                return n.Guard.isElementNode(e4);
              });
            }
            return null;
          }, e2;
        }();
        t.NonElementParentNodeImpl = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(3), o = r(0), a = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "children", { get: function() {
            return o.create_htmlCollection(i.Cast.asNode(this));
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "firstElementChild", { get: function() {
            for (var e3 = i.Cast.asNode(this)._firstChild; e3; ) {
              if (i.Guard.isElementNode(e3))
                return e3;
              e3 = e3._nextSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "lastElementChild", { get: function() {
            for (var e3 = i.Cast.asNode(this)._lastChild; e3; ) {
              if (i.Guard.isElementNode(e3))
                return e3;
              e3 = e3._previousSibling;
            }
            return null;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "childElementCount", { get: function() {
            var e3, t2, r2 = 0;
            try {
              for (var o2 = n(i.Cast.asNode(this)._children), a2 = o2.next(); !a2.done; a2 = o2.next()) {
                var s = a2.value;
                i.Guard.isElementNode(s) && r2++;
              }
            } catch (t3) {
              e3 = { error: t3 };
            } finally {
              try {
                a2 && !a2.done && (t2 = o2.return) && t2.call(o2);
              } finally {
                if (e3)
                  throw e3.error;
              }
            }
            return r2;
          }, enumerable: true, configurable: true }), e2.prototype.prepend = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++)
              e3[t2] = arguments[t2];
            var r2 = i.Cast.asNode(this), n2 = o.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
            o.mutation_preInsert(n2, r2, r2._firstChild);
          }, e2.prototype.append = function() {
            for (var e3 = [], t2 = 0; t2 < arguments.length; t2++)
              e3[t2] = arguments[t2];
            var r2 = i.Cast.asNode(this), n2 = o.parentNode_convertNodesIntoANode(e3, r2._nodeDocument);
            o.mutation_append(n2, r2);
          }, e2.prototype.querySelector = function(e3) {
            var t2 = i.Cast.asNode(this), r2 = o.selectors_scopeMatchASelectorsString(e3, t2);
            return 0 === r2.length ? null : r2[0];
          }, e2.prototype.querySelectorAll = function(e3) {
            var t2 = i.Cast.asNode(this), r2 = o.selectors_scopeMatchASelectorsString(e3, t2);
            return o.create_nodeListStatic(t2, r2);
          }, e2;
        }();
        t.ParentNodeImpl = a;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(0), i = function() {
          function e2() {
          }
          return Object.defineProperty(e2.prototype, "_name", { get: function() {
            return this.__name || "";
          }, set: function(e3) {
            this.__name = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "_assignedSlot", { get: function() {
            return this.__assignedSlot || null;
          }, set: function(e3) {
            this.__assignedSlot = e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(e2.prototype, "assignedSlot", { get: function() {
            return n.shadowTree_findASlot(this, true);
          }, enumerable: true, configurable: true }), e2;
        }();
        t.SlotableImpl = i;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(102), a = r(9), s = r(3), u = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this) || this;
            if (s.Guard.isDocumentTypeNode(t3.startContainer) || s.Guard.isAttrNode(t3.startContainer) || s.Guard.isDocumentTypeNode(t3.endContainer) || s.Guard.isAttrNode(t3.endContainer))
              throw new a.InvalidNodeTypeError();
            return r2._start = [t3.startContainer, t3.startOffset], r2._end = [t3.endContainer, t3.endOffset], r2;
          }
          return i(t2, e2), t2;
        }(o.AbstractRangeImpl);
        t.StaticRangeImpl = u;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(273);
        t.DOMParser = n.DOMParserImpl;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(0), i = r(274), o = function() {
          function e2() {
          }
          return e2.prototype.parseFromString = function(e3, t2) {
            if ("text/html" === t2)
              throw new Error("HTML parser not implemented.");
            try {
              return (r2 = new i.XMLParserImpl().parse(e3))._contentType = t2, r2;
            } catch (e4) {
              var r2, o2 = "http://www.mozilla.org/newlayout/xml/parsererror.xml", a = (r2 = n.create_xmlDocument()).createElementNS(o2, "parsererror"), s = r2.createElementNS(o2, "error");
              return s.setAttribute("message", e4.message), a.appendChild(s), r2.appendChild(a), r2;
            }
          }, e2;
        }();
        t.DOMParserImpl = o;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, i = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(180), a = r(111), s = r(7), u = r(0), l = r(69), c = function() {
          function e2() {
          }
          return e2.prototype.parse = function(e3) {
            for (var t2, r2, c2, h, p = new o.XMLStringLexer(e3, { skipWhitespaceOnlyText: true }), f = u.create_document(), d = f, m = p.nextToken(); m.type !== a.TokenType.EOF; ) {
              switch (m.type) {
                case a.TokenType.Declaration:
                  var y = m;
                  if ("1.0" !== y.version)
                    throw new Error("Invalid xml version: " + y.version);
                  break;
                case a.TokenType.DocType:
                  var v = m;
                  if (!u.xml_isPubidChar(v.pubId))
                    throw new Error("DocType public identifier does not match PubidChar construct.");
                  if (!u.xml_isLegalChar(v.sysId) || -1 !== v.sysId.indexOf('"') && -1 !== v.sysId.indexOf("'"))
                    throw new Error("DocType system identifier contains invalid characters.");
                  d.appendChild(f.implementation.createDocumentType(v.name, v.pubId, v.sysId));
                  break;
                case a.TokenType.CDATA:
                  var _ = m;
                  if (!u.xml_isLegalChar(_.data) || -1 !== _.data.indexOf("]]>"))
                    throw new Error("CDATA contains invalid characters.");
                  d.appendChild(f.createCDATASection(_.data));
                  break;
                case a.TokenType.Comment:
                  var g = m;
                  if (!u.xml_isLegalChar(g.data) || -1 !== g.data.indexOf("--") || g.data.endsWith("-"))
                    throw new Error("Comment data contains invalid characters.");
                  d.appendChild(f.createComment(g.data));
                  break;
                case a.TokenType.PI:
                  var b = m;
                  if (-1 !== b.target.indexOf(":") || /^xml$/i.test(b.target))
                    throw new Error("Processing instruction target contains invalid characters.");
                  if (!u.xml_isLegalChar(b.data) || -1 !== b.data.indexOf("?>"))
                    throw new Error("Processing instruction data contains invalid characters.");
                  d.appendChild(f.createProcessingInstruction(b.target, b.data));
                  break;
                case a.TokenType.Text:
                  var x = m;
                  if (!u.xml_isLegalChar(x.data))
                    throw new Error("Text data contains invalid characters.");
                  d.appendChild(f.createTextNode(this._decodeText(x.data)));
                  break;
                case a.TokenType.Element:
                  var w = m, E = n(u.namespace_extractQName(w.name), 2), D = E[0], S = E[1];
                  if (-1 !== S.indexOf(":") || !u.xml_isName(S))
                    throw new Error("Node local name contains invalid characters.");
                  if ("xmlns" === D)
                    throw new Error("An element cannot have the 'xmlns' prefix.");
                  var C = d.lookupNamespaceURI(D), A = {};
                  try {
                    for (var N = (t2 = void 0, i(w.attributes)), T = N.next(); !T.done; T = N.next()) {
                      var O = n(T.value, 2), F = O[0], k = O[1];
                      if ("xmlns" === F)
                        C = k;
                      else {
                        var P = n(u.namespace_extractQName(F), 2), I = P[0], L = P[1];
                        "xmlns" === I && (L === D && (C = k), A[L] = k);
                      }
                    }
                  } catch (e4) {
                    t2 = { error: e4 };
                  } finally {
                    try {
                      T && !T.done && (r2 = N.return) && r2.call(N);
                    } finally {
                      if (t2)
                        throw t2.error;
                    }
                  }
                  var M = null !== C ? f.createElementNS(C, w.name) : f.createElement(w.name);
                  d.appendChild(M);
                  var B = new l.LocalNameSet();
                  try {
                    for (var j = (c2 = void 0, i(w.attributes)), R = j.next(); !R.done; R = j.next()) {
                      var z = n(R.value, 2), U = (F = z[0], k = z[1], n(u.namespace_extractQName(F), 2)), G = (I = U[0], L = U[1], null);
                      if ("xmlns" === I || null === I && "xmlns" === L ? G = s.namespace.XMLNS : null !== (G = M.lookupNamespaceURI(I)) && M.isDefaultNamespace(G) ? G = null : null === G && null !== I && (G = A[I] || null), B.has(G, L))
                        throw new Error("Element contains duplicate attributes.");
                      if (B.set(G, L), G === s.namespace.XMLNS && k === s.namespace.XMLNS)
                        throw new Error("XMLNS namespace is reserved.");
                      if (-1 !== L.indexOf(":") || !u.xml_isName(L))
                        throw new Error("Attribute local name contains invalid characters.");
                      if ("xmlns" === I && "" === k)
                        throw new Error("Empty XML namespace is not allowed.");
                      null !== G ? M.setAttributeNS(G, F, this._decodeAttributeValue(k)) : M.setAttribute(F, this._decodeAttributeValue(k));
                    }
                  } catch (e4) {
                    c2 = { error: e4 };
                  } finally {
                    try {
                      R && !R.done && (h = j.return) && h.call(j);
                    } finally {
                      if (c2)
                        throw c2.error;
                    }
                  }
                  w.selfClosing || (d = M);
                  break;
                case a.TokenType.ClosingTag:
                  if (m.name !== d.nodeName)
                    throw new Error("Closing tag name does not match opening tag name.");
                  d._parent && (d = d._parent);
              }
              m = p.nextToken();
            }
            return f;
          }, e2.prototype._decodeText = function(e3) {
            return null == e3 ? e3 : e3.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
          }, e2.prototype._decodeAttributeValue = function(e3) {
            return null == e3 ? e3 : e3.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
          }, e2;
        }();
        t.XMLParserImpl = c;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(276);
        t.XMLSerializer = n.XMLSerializerImpl;
      }, function(e, t, r) {
        "use strict";
        var n = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var i = r(1), o = r(69), a = r(95), s = r(9), u = r(7), l = r(0), c = function() {
          function e2() {
          }
          return e2.prototype.serializeToString = function(e3) {
            return this._xmlSerialization(e3, false);
          }, e2.prototype._xmlSerialization = function(e3, t2) {
            if (void 0 === e3._nodeDocument || e3._nodeDocument._hasNamespaces) {
              var r2 = new a.NamespacePrefixMap();
              r2.set("xml", u.namespace.XML);
              try {
                return this._serializeNodeNS(e3, null, r2, { value: 1 }, t2);
              } catch (e4) {
                throw new s.InvalidStateError();
              }
            } else
              try {
                return this._serializeNode(e3, t2);
              } catch (e4) {
                throw new s.InvalidStateError();
              }
          }, e2.prototype._serializeNodeNS = function(e3, t2, r2, n2, o2) {
            switch (e3.nodeType) {
              case i.NodeType.Element:
                return this._serializeElementNS(e3, t2, r2, n2, o2);
              case i.NodeType.Document:
                return this._serializeDocumentNS(e3, t2, r2, n2, o2);
              case i.NodeType.Comment:
                return this._serializeComment(e3, o2);
              case i.NodeType.Text:
                return this._serializeText(e3, o2);
              case i.NodeType.DocumentFragment:
                return this._serializeDocumentFragmentNS(e3, t2, r2, n2, o2);
              case i.NodeType.DocumentType:
                return this._serializeDocumentType(e3, o2);
              case i.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(e3, o2);
              case i.NodeType.CData:
                return this._serializeCData(e3, o2);
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeNode = function(e3, t2) {
            switch (e3.nodeType) {
              case i.NodeType.Element:
                return this._serializeElement(e3, t2);
              case i.NodeType.Document:
                return this._serializeDocument(e3, t2);
              case i.NodeType.Comment:
                return this._serializeComment(e3, t2);
              case i.NodeType.Text:
                return this._serializeText(e3, t2);
              case i.NodeType.DocumentFragment:
                return this._serializeDocumentFragment(e3, t2);
              case i.NodeType.DocumentType:
                return this._serializeDocumentType(e3, t2);
              case i.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(e3, t2);
              case i.NodeType.CData:
                return this._serializeCData(e3, t2);
              default:
                throw new Error("Unknown node type: " + e3.nodeType);
            }
          }, e2.prototype._serializeElementNS = function(t2, r2, i2, o2, a2) {
            var s2, c2;
            if (a2 && (-1 !== t2.localName.indexOf(":") || !l.xml_isName(t2.localName)))
              throw new Error("Node local name contains invalid characters (well-formed required).");
            var h = "<", p = "", f = false, d = false, m = i2.copy(), y = {}, v = this._recordNamespaceInformation(t2, m, y), _ = r2, g = t2.namespaceURI;
            if (_ === g)
              null !== v && (d = true), h += p = g === u.namespace.XML ? "xml:" + t2.localName : t2.localName;
            else {
              var b = t2.prefix, x = null;
              if (null === b && g === v || (x = m.get(b, g)), "xmlns" === b) {
                if (a2)
                  throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                x = b;
              }
              null !== x ? (p = x + ":" + t2.localName, null !== v && v !== u.namespace.XML && (_ = v || null), h += p) : null !== b ? (b in y && (b = this._generatePrefix(g, m, o2)), m.set(b, g), h += p += b + ":" + t2.localName, h += " xmlns:" + b + '="' + this._serializeAttributeValue(g, a2) + '"', null !== v && (_ = v || null)) : null === v || null !== v && v !== g ? (d = true, _ = g, h += p += t2.localName, h += ' xmlns="' + this._serializeAttributeValue(g, a2) + '"') : (_ = g, h += p += t2.localName);
            }
            h += this._serializeAttributesNS(t2, m, o2, y, d, a2);
            var w = g === u.namespace.HTML;
            if (w && 0 === t2.childNodes.length && e2._VoidElementNames.has(t2.localName) ? (h += " /", f = true) : w || 0 !== t2.childNodes.length || (h += "/", f = true), h += ">", f)
              return h;
            if (w && "template" === t2.localName)
              ;
            else
              try {
                for (var E = n(t2._children || t2.childNodes), D = E.next(); !D.done; D = E.next()) {
                  var S = D.value;
                  h += this._serializeNodeNS(S, _, m, o2, a2);
                }
              } catch (e3) {
                s2 = { error: e3 };
              } finally {
                try {
                  D && !D.done && (c2 = E.return) && c2.call(E);
                } finally {
                  if (s2)
                    throw s2.error;
                }
              }
            return h += "</" + p + ">";
          }, e2.prototype._serializeDocumentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2;
            if (o2 && null === e3.documentElement)
              throw new Error("Missing document element (well-formed required).");
            var u2 = "";
            try {
              for (var l2 = n(e3._children || e3.childNodes), c2 = l2.next(); !c2.done; c2 = l2.next()) {
                var h = c2.value;
                u2 += this._serializeNodeNS(h, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                c2 && !c2.done && (s2 = l2.return) && s2.call(l2);
              } finally {
                if (a2)
                  throw a2.error;
              }
            }
            return u2;
          }, e2.prototype._serializeComment = function(e3, t2) {
            if (t2 && (!l.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("--") || e3.data.endsWith("-")))
              throw new Error("Comment data contains invalid characters (well-formed required).");
            return "<!--" + e3.data + "-->";
          }, e2.prototype._serializeText = function(e3, t2) {
            if (t2 && !l.xml_isLegalChar(e3.data))
              throw new Error("Text data contains invalid characters (well-formed required).");
            for (var r2 = "", n2 = 0; n2 < e3.data.length; n2++) {
              var i2 = e3.data[n2];
              r2 += "&" === i2 ? "&amp;" : "<" === i2 ? "&lt;" : ">" === i2 ? "&gt;" : i2;
            }
            return r2;
          }, e2.prototype._serializeDocumentFragmentNS = function(e3, t2, r2, i2, o2) {
            var a2, s2, u2 = "";
            try {
              for (var l2 = n(e3._children || e3.childNodes), c2 = l2.next(); !c2.done; c2 = l2.next()) {
                var h = c2.value;
                u2 += this._serializeNodeNS(h, t2, r2, i2, o2);
              }
            } catch (e4) {
              a2 = { error: e4 };
            } finally {
              try {
                c2 && !c2.done && (s2 = l2.return) && s2.call(l2);
              } finally {
                if (a2)
                  throw a2.error;
              }
            }
            return u2;
          }, e2.prototype._serializeDocumentType = function(e3, t2) {
            if (t2 && !l.xml_isPubidChar(e3.publicId))
              throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
            if (t2 && (!l.xml_isLegalChar(e3.systemId) || -1 !== e3.systemId.indexOf('"') && -1 !== e3.systemId.indexOf("'")))
              throw new Error("DocType system identifier contains invalid characters (well-formed required).");
            return e3.publicId && e3.systemId ? "<!DOCTYPE " + e3.name + ' PUBLIC "' + e3.publicId + '" "' + e3.systemId + '">' : e3.publicId ? "<!DOCTYPE " + e3.name + ' PUBLIC "' + e3.publicId + '">' : e3.systemId ? "<!DOCTYPE " + e3.name + ' SYSTEM "' + e3.systemId + '">' : "<!DOCTYPE " + e3.name + ">";
          }, e2.prototype._serializeProcessingInstruction = function(e3, t2) {
            if (t2 && (-1 !== e3.target.indexOf(":") || /^xml$/i.test(e3.target)))
              throw new Error("Processing instruction target contains invalid characters (well-formed required).");
            if (t2 && (!l.xml_isLegalChar(e3.data) || -1 !== e3.data.indexOf("?>")))
              throw new Error("Processing instruction data contains invalid characters (well-formed required).");
            return "<?" + ("" === e3.data ? e3.target : e3.target + " " + e3.data) + "?>";
          }, e2.prototype._serializeCData = function(e3, t2) {
            if (t2 && -1 !== e3.data.indexOf("]]>"))
              throw new Error("CDATA contains invalid characters (well-formed required).");
            return "<![CDATA[" + e3.data + "]]>";
          }, e2.prototype._serializeAttributesNS = function(e3, t2, r2, i2, a2, s2) {
            var c2, h, p = "", f = s2 ? new o.LocalNameSet() : void 0;
            try {
              for (var d = n(e3.attributes), m = d.next(); !m.done; m = d.next()) {
                var y = m.value;
                if (a2 || s2 || null !== y.namespaceURI) {
                  if (s2 && f && f.has(y.namespaceURI, y.localName))
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                  s2 && f && f.set(y.namespaceURI, y.localName);
                  var v = y.namespaceURI, _ = null;
                  if (null !== v)
                    if (_ = t2.get(y.prefix, v), v === u.namespace.XMLNS) {
                      if (y.value === u.namespace.XML || null === y.prefix && a2 || null !== y.prefix && (!(y.localName in i2) || i2[y.localName] !== y.value) && t2.has(y.localName, y.value))
                        continue;
                      if (s2 && y.value === u.namespace.XMLNS)
                        throw new Error("XMLNS namespace is reserved (well-formed required).");
                      if (s2 && "" === y.value)
                        throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                      "xmlns" === y.prefix && (_ = "xmlns");
                    } else
                      null === _ && (p += " xmlns:" + (_ = null === y.prefix || t2.hasPrefix(y.prefix) && !t2.has(y.prefix, v) ? this._generatePrefix(v, t2, r2) : y.prefix) + '="' + this._serializeAttributeValue(v, s2) + '"');
                  if (p += " ", null !== _ && (p += _ + ":"), s2 && (-1 !== y.localName.indexOf(":") || !l.xml_isName(y.localName) || "xmlns" === y.localName && null === v))
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                  p += y.localName + '="' + this._serializeAttributeValue(y.value, s2) + '"';
                } else
                  p += " " + y.localName + '="' + this._serializeAttributeValue(y.value, s2) + '"';
              }
            } catch (e4) {
              c2 = { error: e4 };
            } finally {
              try {
                m && !m.done && (h = d.return) && h.call(d);
              } finally {
                if (c2)
                  throw c2.error;
              }
            }
            return p;
          }, e2.prototype._recordNamespaceInformation = function(e3, t2, r2) {
            var i2, o2, a2 = null;
            try {
              for (var s2 = n(e3.attributes), l2 = s2.next(); !l2.done; l2 = s2.next()) {
                var c2 = l2.value, h = c2.namespaceURI, p = c2.prefix;
                if (h === u.namespace.XMLNS) {
                  if (null === p) {
                    a2 = c2.value;
                    continue;
                  }
                  var f = c2.localName, d = c2.value;
                  if (d === u.namespace.XML)
                    continue;
                  if ("" === d && (d = null), t2.has(f, d))
                    continue;
                  t2.set(f, d), r2[f] = d || "";
                }
              }
            } catch (e4) {
              i2 = { error: e4 };
            } finally {
              try {
                l2 && !l2.done && (o2 = s2.return) && o2.call(s2);
              } finally {
                if (i2)
                  throw i2.error;
              }
            }
            return a2;
          }, e2.prototype._generatePrefix = function(e3, t2, r2) {
            var n2 = "ns" + r2.value;
            return r2.value++, t2.set(n2, e3), n2;
          }, e2.prototype._serializeAttributeValue = function(e3, t2) {
            if (t2 && null !== e3 && !l.xml_isLegalChar(e3))
              throw new Error("Invalid characters in attribute value.");
            if (null === e3)
              return "";
            for (var r2 = "", n2 = 0; n2 < e3.length; n2++) {
              var i2 = e3[n2];
              r2 += '"' === i2 ? "&quot;" : "&" === i2 ? "&amp;" : "<" === i2 ? "&lt;" : ">" === i2 ? "&gt;" : i2;
            }
            return r2;
          }, e2.prototype._serializeElement = function(e3, t2) {
            var r2, i2;
            if (t2 && (-1 !== e3.localName.indexOf(":") || !l.xml_isName(e3.localName)))
              throw new Error("Node local name contains invalid characters (well-formed required).");
            var o2 = false, a2 = e3.localName, s2 = "<" + a2;
            if (s2 += this._serializeAttributes(e3, t2), 0 === e3._children.size && (s2 += "/", o2 = true), s2 += ">", o2)
              return s2;
            try {
              for (var u2 = n(e3._children), c2 = u2.next(); !c2.done; c2 = u2.next()) {
                var h = c2.value;
                s2 += this._serializeNode(h, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                c2 && !c2.done && (i2 = u2.return) && i2.call(u2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return s2 += "</" + a2 + ">";
          }, e2.prototype._serializeDocument = function(e3, t2) {
            var r2, i2;
            if (t2 && null === e3.documentElement)
              throw new Error("Missing document element (well-formed required).");
            var o2 = "";
            try {
              for (var a2 = n(e3._children), s2 = a2.next(); !s2.done; s2 = a2.next()) {
                var u2 = s2.value;
                o2 += this._serializeNode(u2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return o2;
          }, e2.prototype._serializeDocumentFragment = function(e3, t2) {
            var r2, i2, o2 = "";
            try {
              for (var a2 = n(e3._children), s2 = a2.next(); !s2.done; s2 = a2.next()) {
                var u2 = s2.value;
                o2 += this._serializeNode(u2, t2);
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                s2 && !s2.done && (i2 = a2.return) && i2.call(a2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return o2;
          }, e2.prototype._serializeAttributes = function(e3, t2) {
            var r2, i2, o2 = "", a2 = t2 ? {} : void 0;
            try {
              for (var s2 = n(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var c2 = u2.value;
                if (t2 && a2 && c2.localName in a2)
                  throw new Error("Element contains duplicate attributes (well-formed required).");
                if (t2 && a2 && (a2[c2.localName] = true), t2 && (-1 !== c2.localName.indexOf(":") || !l.xml_isName(c2.localName)))
                  throw new Error("Attribute local name contains invalid characters (well-formed required).");
                o2 += " " + c2.localName + '="' + this._serializeAttributeValue(c2.value, t2) + '"';
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
              } finally {
                if (r2)
                  throw r2.error;
              }
            }
            return o2;
          }, e2._VoidElementNames = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), e2;
        }();
        t.XMLSerializerImpl = c;
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(278);
        t.XMLReader = n.XMLReader;
        var i = r(112);
        t.ObjectReader = i.ObjectReader;
        var o = r(281);
        t.JSONReader = o.JSONReader;
        var a = r(282);
        t.YAMLReader = a.YAMLReader;
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(19), r(65), r(20), r(22), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        }, a = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(180), u = r(111), l = r(1), c = r(7), h = r(0), p = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            for (var r2, n2, i2, p2, f = new s.XMLStringLexer(t3, { skipWhitespaceOnlyText: this._builderOptions.skipWhitespaceOnlyText }), d = e3, m = e3, y = f.nextToken(); y.type !== u.TokenType.EOF; ) {
              switch (y.type) {
                case u.TokenType.Declaration:
                  var v = y, _ = this.sanitize(v.version);
                  if ("1.0" !== _)
                    throw new Error("Invalid xml version: " + _);
                  var g = { version: _ };
                  v.encoding && (g.encoding = this.sanitize(v.encoding)), v.standalone && (g.standalone = "yes" === this.sanitize(v.standalone)), m.set(g);
                  break;
                case u.TokenType.DocType:
                  var b = y;
                  m = this.docType(m, this.sanitize(b.name), this.sanitize(b.pubId), this.sanitize(b.sysId)) || m;
                  break;
                case u.TokenType.CDATA:
                  var x = y;
                  m = this.cdata(m, this.sanitize(x.data)) || m;
                  break;
                case u.TokenType.Comment:
                  var w = y;
                  m = this.comment(m, this.sanitize(w.data)) || m;
                  break;
                case u.TokenType.PI:
                  var E = y;
                  m = this.instruction(m, this.sanitize(E.target), this.sanitize(E.data)) || m;
                  break;
                case u.TokenType.Text:
                  if (m.node.nodeType === l.NodeType.Document)
                    break;
                  var D = y;
                  m = this.text(m, this._decodeText(this.sanitize(D.data))) || m;
                  break;
                case u.TokenType.Element:
                  var S = y, C = this.sanitize(S.name), A = o(h.namespace_extractQName(C), 1)[0], N = m.node.lookupNamespaceURI(A), T = {};
                  try {
                    for (var O = (r2 = void 0, a(S.attributes)), F = O.next(); !F.done; F = O.next()) {
                      var k = o(F.value, 2), P = k[0], I = k[1];
                      if (P = this.sanitize(P), I = this.sanitize(I), "xmlns" === P)
                        N = I;
                      else {
                        var L = o(h.namespace_extractQName(P), 2), M = L[0], B = L[1];
                        "xmlns" === M && (B === A && (N = I), T[B] = I);
                      }
                    }
                  } catch (e4) {
                    r2 = { error: e4 };
                  } finally {
                    try {
                      F && !F.done && (n2 = O.return) && n2.call(O);
                    } finally {
                      if (r2)
                        throw r2.error;
                    }
                  }
                  var j = null !== N ? this.element(m, N, C) : this.element(m, void 0, C);
                  if (void 0 === j)
                    break;
                  m.node === e3.node && (d = j);
                  try {
                    for (var R = (i2 = void 0, a(S.attributes)), z = R.next(); !z.done; z = R.next()) {
                      var U = o(z.value, 2);
                      P = U[0], I = U[1];
                      P = this.sanitize(P), I = this.sanitize(I);
                      var G = o(h.namespace_extractQName(P), 2), X = (M = G[0], B = G[1], null);
                      "xmlns" === M || null === M && "xmlns" === B ? X = c.namespace.XMLNS : null !== (X = j.node.lookupNamespaceURI(M)) && j.node.isDefaultNamespace(X) ? X = null : null === X && null !== M && (X = T[M] || null), null !== X ? this.attribute(j, X, P, this._decodeAttributeValue(I)) : this.attribute(j, void 0, P, this._decodeAttributeValue(I));
                    }
                  } catch (e4) {
                    i2 = { error: e4 };
                  } finally {
                    try {
                      z && !z.done && (p2 = R.return) && p2.call(R);
                    } finally {
                      if (i2)
                        throw i2.error;
                    }
                  }
                  S.selfClosing || (m = j);
                  break;
                case u.TokenType.ClosingTag:
                  m.node.parentNode && (m = m.up());
              }
              y = f.nextToken();
            }
            return d;
          }, t2;
        }(r(75).BaseReader);
        t.XMLReader = p;
      }, function(e, t, r) {
        var n = r(4), i = r(280);
        n({ target: "Object", stat: true, forced: Object.assign !== i }, { assign: i });
      }, function(e, t, r) {
        "use strict";
        var n = r(16), i = r(8), o = r(61), a = r(85), s = r(79), u = r(27), l = r(41), c = Object.assign, h = Object.defineProperty;
        e.exports = !c || i(function() {
          if (n && 1 !== c({ b: 1 }, c(h({}, "a", { enumerable: true, get: function() {
            h(this, "b", { value: 3, enumerable: false });
          } }), { b: 2 })).b)
            return true;
          var e2 = {}, t2 = {}, r2 = Symbol();
          return e2[r2] = 7, "abcdefghijklmnopqrst".split("").forEach(function(e3) {
            t2[e3] = e3;
          }), 7 != c({}, e2)[r2] || "abcdefghijklmnopqrst" != o(c({}, t2)).join("");
        }) ? function(e2, t2) {
          for (var r2 = u(e2), i2 = arguments.length, c2 = 1, h2 = a.f, p = s.f; i2 > c2; )
            for (var f, d = l(arguments[c2++]), m = h2 ? o(d).concat(h2(d)) : o(d), y = m.length, v = 0; y > v; )
              f = m[v++], n && !p.call(d, f) || (r2[f] = d[f]);
          return r2;
        } : c;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(112), a = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            return new o.ObjectReader(this._builderOptions).parse(e3, JSON.parse(t3));
          }, t2;
        }(r(75).BaseReader);
        t.JSONReader = a;
      }, function(e, t, r) {
        "use strict";
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = r(112), a = r(75), s = r(283), u = function(e2) {
          function t2() {
            return null !== e2 && e2.apply(this, arguments) || this;
          }
          return i(t2, e2), t2.prototype._parse = function(e3, t3) {
            var r2 = s.safeLoad(t3);
            if (void 0 === r2)
              throw new Error("Unable to parse YAML document.");
            return new o.ObjectReader(this._builderOptions).parse(e3, r2);
          }, t2;
        }(a.BaseReader);
        t.YAMLReader = u;
      }, function(e, t, r) {
        "use strict";
        var n = r(284);
        e.exports = n;
      }, function(e, t, r) {
        "use strict";
        var n = r(285), i = r(304);
        function o(e2) {
          return function() {
            throw new Error("Function " + e2 + " is deprecated and cannot be used.");
          };
        }
        e.exports.Type = r(10), e.exports.Schema = r(39), e.exports.FAILSAFE_SCHEMA = r(113), e.exports.JSON_SCHEMA = r(182), e.exports.CORE_SCHEMA = r(181), e.exports.DEFAULT_SAFE_SCHEMA = r(54), e.exports.DEFAULT_FULL_SCHEMA = r(76), e.exports.load = n.load, e.exports.loadAll = n.loadAll, e.exports.safeLoad = n.safeLoad, e.exports.safeLoadAll = n.safeLoadAll, e.exports.dump = i.dump, e.exports.safeDump = i.safeDump, e.exports.YAMLException = r(53), e.exports.MINIMAL_SCHEMA = r(113), e.exports.SAFE_SCHEMA = r(54), e.exports.DEFAULT_SCHEMA = r(76), e.exports.scan = o("scan"), e.exports.parse = o("parse"), e.exports.compose = o("compose"), e.exports.addConstructor = o("addConstructor");
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(53), o = r(286), a = r(54), s = r(76), u = Object.prototype.hasOwnProperty, l = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, c = /[\x85\u2028\u2029]/, h = /[,\[\]\{\}]/, p = /^(?:!|!!|![a-z\-]+!)$/i, f = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function d(e2) {
          return Object.prototype.toString.call(e2);
        }
        function m(e2) {
          return 10 === e2 || 13 === e2;
        }
        function y(e2) {
          return 9 === e2 || 32 === e2;
        }
        function v(e2) {
          return 9 === e2 || 32 === e2 || 10 === e2 || 13 === e2;
        }
        function _(e2) {
          return 44 === e2 || 91 === e2 || 93 === e2 || 123 === e2 || 125 === e2;
        }
        function g(e2) {
          var t2;
          return 48 <= e2 && e2 <= 57 ? e2 - 48 : 97 <= (t2 = 32 | e2) && t2 <= 102 ? t2 - 97 + 10 : -1;
        }
        function b(e2) {
          return 48 === e2 ? "\0" : 97 === e2 ? "\x07" : 98 === e2 ? "\b" : 116 === e2 || 9 === e2 ? "	" : 110 === e2 ? "\n" : 118 === e2 ? "\v" : 102 === e2 ? "\f" : 114 === e2 ? "\r" : 101 === e2 ? "\x1B" : 32 === e2 ? " " : 34 === e2 ? '"' : 47 === e2 ? "/" : 92 === e2 ? "\\" : 78 === e2 ? "\x85" : 95 === e2 ? "\xA0" : 76 === e2 ? "\u2028" : 80 === e2 ? "\u2029" : "";
        }
        function x(e2) {
          return e2 <= 65535 ? String.fromCharCode(e2) : String.fromCharCode(55296 + (e2 - 65536 >> 10), 56320 + (e2 - 65536 & 1023));
        }
        for (var w = new Array(256), E = new Array(256), D = 0; D < 256; D++)
          w[D] = b(D) ? 1 : 0, E[D] = b(D);
        function S(e2, t2) {
          this.input = e2, this.filename = t2.filename || null, this.schema = t2.schema || s, this.onWarning = t2.onWarning || null, this.legacy = t2.legacy || false, this.json = t2.json || false, this.listener = t2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e2.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
        }
        function C(e2, t2) {
          return new i(t2, new o(e2.filename, e2.input, e2.position, e2.line, e2.position - e2.lineStart));
        }
        function A(e2, t2) {
          throw C(e2, t2);
        }
        function N(e2, t2) {
          e2.onWarning && e2.onWarning.call(null, C(e2, t2));
        }
        var T = { YAML: function(e2, t2, r2) {
          var n2, i2, o2;
          null !== e2.version && A(e2, "duplication of %YAML directive"), 1 !== r2.length && A(e2, "YAML directive accepts exactly one argument"), null === (n2 = /^([0-9]+)\.([0-9]+)$/.exec(r2[0])) && A(e2, "ill-formed argument of the YAML directive"), i2 = parseInt(n2[1], 10), o2 = parseInt(n2[2], 10), 1 !== i2 && A(e2, "unacceptable YAML version of the document"), e2.version = r2[0], e2.checkLineBreaks = o2 < 2, 1 !== o2 && 2 !== o2 && N(e2, "unsupported YAML version of the document");
        }, TAG: function(e2, t2, r2) {
          var n2, i2;
          2 !== r2.length && A(e2, "TAG directive accepts exactly two arguments"), n2 = r2[0], i2 = r2[1], p.test(n2) || A(e2, "ill-formed tag handle (first argument) of the TAG directive"), u.call(e2.tagMap, n2) && A(e2, 'there is a previously declared suffix for "' + n2 + '" tag handle'), f.test(i2) || A(e2, "ill-formed tag prefix (second argument) of the TAG directive"), e2.tagMap[n2] = i2;
        } };
        function O(e2, t2, r2, n2) {
          var i2, o2, a2, s2;
          if (t2 < r2) {
            if (s2 = e2.input.slice(t2, r2), n2)
              for (i2 = 0, o2 = s2.length; i2 < o2; i2 += 1)
                9 === (a2 = s2.charCodeAt(i2)) || 32 <= a2 && a2 <= 1114111 || A(e2, "expected valid JSON character");
            else
              l.test(s2) && A(e2, "the stream contains non-printable characters");
            e2.result += s2;
          }
        }
        function F(e2, t2, r2, i2) {
          var o2, a2, s2, l2;
          for (n.isObject(r2) || A(e2, "cannot merge mappings; the provided source object is unacceptable"), s2 = 0, l2 = (o2 = Object.keys(r2)).length; s2 < l2; s2 += 1)
            a2 = o2[s2], u.call(t2, a2) || (t2[a2] = r2[a2], i2[a2] = true);
        }
        function k(e2, t2, r2, n2, i2, o2, a2, s2) {
          var l2, c2;
          if (Array.isArray(i2))
            for (l2 = 0, c2 = (i2 = Array.prototype.slice.call(i2)).length; l2 < c2; l2 += 1)
              Array.isArray(i2[l2]) && A(e2, "nested arrays are not supported inside keys"), "object" == typeof i2 && "[object Object]" === d(i2[l2]) && (i2[l2] = "[object Object]");
          if ("object" == typeof i2 && "[object Object]" === d(i2) && (i2 = "[object Object]"), i2 = String(i2), null === t2 && (t2 = {}), "tag:yaml.org,2002:merge" === n2)
            if (Array.isArray(o2))
              for (l2 = 0, c2 = o2.length; l2 < c2; l2 += 1)
                F(e2, t2, o2[l2], r2);
            else
              F(e2, t2, o2, r2);
          else
            e2.json || u.call(r2, i2) || !u.call(t2, i2) || (e2.line = a2 || e2.line, e2.position = s2 || e2.position, A(e2, "duplicated mapping key")), t2[i2] = o2, delete r2[i2];
          return t2;
        }
        function P(e2) {
          var t2;
          10 === (t2 = e2.input.charCodeAt(e2.position)) ? e2.position++ : 13 === t2 ? (e2.position++, 10 === e2.input.charCodeAt(e2.position) && e2.position++) : A(e2, "a line break is expected"), e2.line += 1, e2.lineStart = e2.position;
        }
        function I(e2, t2, r2) {
          for (var n2 = 0, i2 = e2.input.charCodeAt(e2.position); 0 !== i2; ) {
            for (; y(i2); )
              i2 = e2.input.charCodeAt(++e2.position);
            if (t2 && 35 === i2)
              do {
                i2 = e2.input.charCodeAt(++e2.position);
              } while (10 !== i2 && 13 !== i2 && 0 !== i2);
            if (!m(i2))
              break;
            for (P(e2), i2 = e2.input.charCodeAt(e2.position), n2++, e2.lineIndent = 0; 32 === i2; )
              e2.lineIndent++, i2 = e2.input.charCodeAt(++e2.position);
          }
          return -1 !== r2 && 0 !== n2 && e2.lineIndent < r2 && N(e2, "deficient indentation"), n2;
        }
        function L(e2) {
          var t2, r2 = e2.position;
          return !(45 !== (t2 = e2.input.charCodeAt(r2)) && 46 !== t2 || t2 !== e2.input.charCodeAt(r2 + 1) || t2 !== e2.input.charCodeAt(r2 + 2) || (r2 += 3, 0 !== (t2 = e2.input.charCodeAt(r2)) && !v(t2)));
        }
        function M(e2, t2) {
          1 === t2 ? e2.result += " " : t2 > 1 && (e2.result += n.repeat("\n", t2 - 1));
        }
        function B(e2, t2) {
          var r2, n2, i2 = e2.tag, o2 = e2.anchor, a2 = [], s2 = false;
          for (null !== e2.anchor && (e2.anchorMap[e2.anchor] = a2), n2 = e2.input.charCodeAt(e2.position); 0 !== n2 && 45 === n2 && v(e2.input.charCodeAt(e2.position + 1)); )
            if (s2 = true, e2.position++, I(e2, true, -1) && e2.lineIndent <= t2)
              a2.push(null), n2 = e2.input.charCodeAt(e2.position);
            else if (r2 = e2.line, z(e2, t2, 3, false, true), a2.push(e2.result), I(e2, true, -1), n2 = e2.input.charCodeAt(e2.position), (e2.line === r2 || e2.lineIndent > t2) && 0 !== n2)
              A(e2, "bad indentation of a sequence entry");
            else if (e2.lineIndent < t2)
              break;
          return !!s2 && (e2.tag = i2, e2.anchor = o2, e2.kind = "sequence", e2.result = a2, true);
        }
        function j(e2) {
          var t2, r2, n2, i2, o2 = false, a2 = false;
          if (33 !== (i2 = e2.input.charCodeAt(e2.position)))
            return false;
          if (null !== e2.tag && A(e2, "duplication of a tag property"), 60 === (i2 = e2.input.charCodeAt(++e2.position)) ? (o2 = true, i2 = e2.input.charCodeAt(++e2.position)) : 33 === i2 ? (a2 = true, r2 = "!!", i2 = e2.input.charCodeAt(++e2.position)) : r2 = "!", t2 = e2.position, o2) {
            do {
              i2 = e2.input.charCodeAt(++e2.position);
            } while (0 !== i2 && 62 !== i2);
            e2.position < e2.length ? (n2 = e2.input.slice(t2, e2.position), i2 = e2.input.charCodeAt(++e2.position)) : A(e2, "unexpected end of the stream within a verbatim tag");
          } else {
            for (; 0 !== i2 && !v(i2); )
              33 === i2 && (a2 ? A(e2, "tag suffix cannot contain exclamation marks") : (r2 = e2.input.slice(t2 - 1, e2.position + 1), p.test(r2) || A(e2, "named tag handle cannot contain such characters"), a2 = true, t2 = e2.position + 1)), i2 = e2.input.charCodeAt(++e2.position);
            n2 = e2.input.slice(t2, e2.position), h.test(n2) && A(e2, "tag suffix cannot contain flow indicator characters");
          }
          return n2 && !f.test(n2) && A(e2, "tag name cannot contain such characters: " + n2), o2 ? e2.tag = n2 : u.call(e2.tagMap, r2) ? e2.tag = e2.tagMap[r2] + n2 : "!" === r2 ? e2.tag = "!" + n2 : "!!" === r2 ? e2.tag = "tag:yaml.org,2002:" + n2 : A(e2, 'undeclared tag handle "' + r2 + '"'), true;
        }
        function R(e2) {
          var t2, r2;
          if (38 !== (r2 = e2.input.charCodeAt(e2.position)))
            return false;
          for (null !== e2.anchor && A(e2, "duplication of an anchor property"), r2 = e2.input.charCodeAt(++e2.position), t2 = e2.position; 0 !== r2 && !v(r2) && !_(r2); )
            r2 = e2.input.charCodeAt(++e2.position);
          return e2.position === t2 && A(e2, "name of an anchor node must contain at least one character"), e2.anchor = e2.input.slice(t2, e2.position), true;
        }
        function z(e2, t2, r2, i2, o2) {
          var a2, s2, l2, c2, h2, p2, f2, d2, b2 = 1, D2 = false, S2 = false;
          if (null !== e2.listener && e2.listener("open", e2), e2.tag = null, e2.anchor = null, e2.kind = null, e2.result = null, a2 = s2 = l2 = 4 === r2 || 3 === r2, i2 && I(e2, true, -1) && (D2 = true, e2.lineIndent > t2 ? b2 = 1 : e2.lineIndent === t2 ? b2 = 0 : e2.lineIndent < t2 && (b2 = -1)), 1 === b2)
            for (; j(e2) || R(e2); )
              I(e2, true, -1) ? (D2 = true, l2 = a2, e2.lineIndent > t2 ? b2 = 1 : e2.lineIndent === t2 ? b2 = 0 : e2.lineIndent < t2 && (b2 = -1)) : l2 = false;
          if (l2 && (l2 = D2 || o2), 1 !== b2 && 4 !== r2 || (f2 = 1 === r2 || 2 === r2 ? t2 : t2 + 1, d2 = e2.position - e2.lineStart, 1 === b2 ? l2 && (B(e2, d2) || function(e3, t3, r3) {
            var n2, i3, o3, a3, s3, u2 = e3.tag, l3 = e3.anchor, c3 = {}, h3 = {}, p3 = null, f3 = null, d3 = null, m2 = false, _2 = false;
            for (null !== e3.anchor && (e3.anchorMap[e3.anchor] = c3), s3 = e3.input.charCodeAt(e3.position); 0 !== s3; ) {
              if (n2 = e3.input.charCodeAt(e3.position + 1), o3 = e3.line, a3 = e3.position, 63 !== s3 && 58 !== s3 || !v(n2)) {
                if (!z(e3, r3, 2, false, true))
                  break;
                if (e3.line === o3) {
                  for (s3 = e3.input.charCodeAt(e3.position); y(s3); )
                    s3 = e3.input.charCodeAt(++e3.position);
                  if (58 === s3)
                    v(s3 = e3.input.charCodeAt(++e3.position)) || A(e3, "a whitespace character is expected after the key-value separator within a block mapping"), m2 && (k(e3, c3, h3, p3, f3, null), p3 = f3 = d3 = null), _2 = true, m2 = false, i3 = false, p3 = e3.tag, f3 = e3.result;
                  else {
                    if (!_2)
                      return e3.tag = u2, e3.anchor = l3, true;
                    A(e3, "can not read an implicit mapping pair; a colon is missed");
                  }
                } else {
                  if (!_2)
                    return e3.tag = u2, e3.anchor = l3, true;
                  A(e3, "can not read a block mapping entry; a multiline key may not be an implicit key");
                }
              } else
                63 === s3 ? (m2 && (k(e3, c3, h3, p3, f3, null), p3 = f3 = d3 = null), _2 = true, m2 = true, i3 = true) : m2 ? (m2 = false, i3 = true) : A(e3, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e3.position += 1, s3 = n2;
              if ((e3.line === o3 || e3.lineIndent > t3) && (z(e3, t3, 4, true, i3) && (m2 ? f3 = e3.result : d3 = e3.result), m2 || (k(e3, c3, h3, p3, f3, d3, o3, a3), p3 = f3 = d3 = null), I(e3, true, -1), s3 = e3.input.charCodeAt(e3.position)), e3.lineIndent > t3 && 0 !== s3)
                A(e3, "bad indentation of a mapping entry");
              else if (e3.lineIndent < t3)
                break;
            }
            return m2 && k(e3, c3, h3, p3, f3, null), _2 && (e3.tag = u2, e3.anchor = l3, e3.kind = "mapping", e3.result = c3), _2;
          }(e2, d2, f2)) || function(e3, t3) {
            var r3, n2, i3, o3, a3, s3, u2, l3, c3, h3, p3 = true, f3 = e3.tag, d3 = e3.anchor, m2 = {};
            if (91 === (h3 = e3.input.charCodeAt(e3.position)))
              i3 = 93, s3 = false, n2 = [];
            else {
              if (123 !== h3)
                return false;
              i3 = 125, s3 = true, n2 = {};
            }
            for (null !== e3.anchor && (e3.anchorMap[e3.anchor] = n2), h3 = e3.input.charCodeAt(++e3.position); 0 !== h3; ) {
              if (I(e3, true, t3), (h3 = e3.input.charCodeAt(e3.position)) === i3)
                return e3.position++, e3.tag = f3, e3.anchor = d3, e3.kind = s3 ? "mapping" : "sequence", e3.result = n2, true;
              p3 || A(e3, "missed comma between flow collection entries"), c3 = null, o3 = a3 = false, 63 === h3 && v(e3.input.charCodeAt(e3.position + 1)) && (o3 = a3 = true, e3.position++, I(e3, true, t3)), r3 = e3.line, z(e3, t3, 1, false, true), l3 = e3.tag, u2 = e3.result, I(e3, true, t3), h3 = e3.input.charCodeAt(e3.position), !a3 && e3.line !== r3 || 58 !== h3 || (o3 = true, h3 = e3.input.charCodeAt(++e3.position), I(e3, true, t3), z(e3, t3, 1, false, true), c3 = e3.result), s3 ? k(e3, n2, m2, l3, u2, c3) : o3 ? n2.push(k(e3, null, m2, l3, u2, c3)) : n2.push(u2), I(e3, true, t3), 44 === (h3 = e3.input.charCodeAt(e3.position)) ? (p3 = true, h3 = e3.input.charCodeAt(++e3.position)) : p3 = false;
            }
            A(e3, "unexpected end of the stream within a flow collection");
          }(e2, f2) ? S2 = true : (s2 && function(e3, t3) {
            var r3, i3, o3, a3, s3, u2 = 1, l3 = false, c3 = false, h3 = t3, p3 = 0, f3 = false;
            if (124 === (a3 = e3.input.charCodeAt(e3.position)))
              i3 = false;
            else {
              if (62 !== a3)
                return false;
              i3 = true;
            }
            for (e3.kind = "scalar", e3.result = ""; 0 !== a3; )
              if (43 === (a3 = e3.input.charCodeAt(++e3.position)) || 45 === a3)
                1 === u2 ? u2 = 43 === a3 ? 3 : 2 : A(e3, "repeat of a chomping mode identifier");
              else {
                if (!((o3 = 48 <= (s3 = a3) && s3 <= 57 ? s3 - 48 : -1) >= 0))
                  break;
                0 === o3 ? A(e3, "bad explicit indentation width of a block scalar; it cannot be less than one") : c3 ? A(e3, "repeat of an indentation width identifier") : (h3 = t3 + o3 - 1, c3 = true);
              }
            if (y(a3)) {
              do {
                a3 = e3.input.charCodeAt(++e3.position);
              } while (y(a3));
              if (35 === a3)
                do {
                  a3 = e3.input.charCodeAt(++e3.position);
                } while (!m(a3) && 0 !== a3);
            }
            for (; 0 !== a3; ) {
              for (P(e3), e3.lineIndent = 0, a3 = e3.input.charCodeAt(e3.position); (!c3 || e3.lineIndent < h3) && 32 === a3; )
                e3.lineIndent++, a3 = e3.input.charCodeAt(++e3.position);
              if (!c3 && e3.lineIndent > h3 && (h3 = e3.lineIndent), m(a3))
                p3++;
              else {
                if (e3.lineIndent < h3) {
                  3 === u2 ? e3.result += n.repeat("\n", l3 ? 1 + p3 : p3) : 1 === u2 && l3 && (e3.result += "\n");
                  break;
                }
                for (i3 ? y(a3) ? (f3 = true, e3.result += n.repeat("\n", l3 ? 1 + p3 : p3)) : f3 ? (f3 = false, e3.result += n.repeat("\n", p3 + 1)) : 0 === p3 ? l3 && (e3.result += " ") : e3.result += n.repeat("\n", p3) : e3.result += n.repeat("\n", l3 ? 1 + p3 : p3), l3 = true, c3 = true, p3 = 0, r3 = e3.position; !m(a3) && 0 !== a3; )
                  a3 = e3.input.charCodeAt(++e3.position);
                O(e3, r3, e3.position, false);
              }
            }
            return true;
          }(e2, f2) || function(e3, t3) {
            var r3, n2, i3;
            if (39 !== (r3 = e3.input.charCodeAt(e3.position)))
              return false;
            for (e3.kind = "scalar", e3.result = "", e3.position++, n2 = i3 = e3.position; 0 !== (r3 = e3.input.charCodeAt(e3.position)); )
              if (39 === r3) {
                if (O(e3, n2, e3.position, true), 39 !== (r3 = e3.input.charCodeAt(++e3.position)))
                  return true;
                n2 = e3.position, e3.position++, i3 = e3.position;
              } else
                m(r3) ? (O(e3, n2, i3, true), M(e3, I(e3, false, t3)), n2 = i3 = e3.position) : e3.position === e3.lineStart && L(e3) ? A(e3, "unexpected end of the document within a single quoted scalar") : (e3.position++, i3 = e3.position);
            A(e3, "unexpected end of the stream within a single quoted scalar");
          }(e2, f2) || function(e3, t3) {
            var r3, n2, i3, o3, a3, s3, u2;
            if (34 !== (s3 = e3.input.charCodeAt(e3.position)))
              return false;
            for (e3.kind = "scalar", e3.result = "", e3.position++, r3 = n2 = e3.position; 0 !== (s3 = e3.input.charCodeAt(e3.position)); ) {
              if (34 === s3)
                return O(e3, r3, e3.position, true), e3.position++, true;
              if (92 === s3) {
                if (O(e3, r3, e3.position, true), m(s3 = e3.input.charCodeAt(++e3.position)))
                  I(e3, false, t3);
                else if (s3 < 256 && w[s3])
                  e3.result += E[s3], e3.position++;
                else if ((a3 = 120 === (u2 = s3) ? 2 : 117 === u2 ? 4 : 85 === u2 ? 8 : 0) > 0) {
                  for (i3 = a3, o3 = 0; i3 > 0; i3--)
                    (a3 = g(s3 = e3.input.charCodeAt(++e3.position))) >= 0 ? o3 = (o3 << 4) + a3 : A(e3, "expected hexadecimal character");
                  e3.result += x(o3), e3.position++;
                } else
                  A(e3, "unknown escape sequence");
                r3 = n2 = e3.position;
              } else
                m(s3) ? (O(e3, r3, n2, true), M(e3, I(e3, false, t3)), r3 = n2 = e3.position) : e3.position === e3.lineStart && L(e3) ? A(e3, "unexpected end of the document within a double quoted scalar") : (e3.position++, n2 = e3.position);
            }
            A(e3, "unexpected end of the stream within a double quoted scalar");
          }(e2, f2) ? S2 = true : !function(e3) {
            var t3, r3, n2;
            if (42 !== (n2 = e3.input.charCodeAt(e3.position)))
              return false;
            for (n2 = e3.input.charCodeAt(++e3.position), t3 = e3.position; 0 !== n2 && !v(n2) && !_(n2); )
              n2 = e3.input.charCodeAt(++e3.position);
            return e3.position === t3 && A(e3, "name of an alias node must contain at least one character"), r3 = e3.input.slice(t3, e3.position), u.call(e3.anchorMap, r3) || A(e3, 'unidentified alias "' + r3 + '"'), e3.result = e3.anchorMap[r3], I(e3, true, -1), true;
          }(e2) ? function(e3, t3, r3) {
            var n2, i3, o3, a3, s3, u2, l3, c3, h3 = e3.kind, p3 = e3.result;
            if (v(c3 = e3.input.charCodeAt(e3.position)) || _(c3) || 35 === c3 || 38 === c3 || 42 === c3 || 33 === c3 || 124 === c3 || 62 === c3 || 39 === c3 || 34 === c3 || 37 === c3 || 64 === c3 || 96 === c3)
              return false;
            if ((63 === c3 || 45 === c3) && (v(n2 = e3.input.charCodeAt(e3.position + 1)) || r3 && _(n2)))
              return false;
            for (e3.kind = "scalar", e3.result = "", i3 = o3 = e3.position, a3 = false; 0 !== c3; ) {
              if (58 === c3) {
                if (v(n2 = e3.input.charCodeAt(e3.position + 1)) || r3 && _(n2))
                  break;
              } else if (35 === c3) {
                if (v(e3.input.charCodeAt(e3.position - 1)))
                  break;
              } else {
                if (e3.position === e3.lineStart && L(e3) || r3 && _(c3))
                  break;
                if (m(c3)) {
                  if (s3 = e3.line, u2 = e3.lineStart, l3 = e3.lineIndent, I(e3, false, -1), e3.lineIndent >= t3) {
                    a3 = true, c3 = e3.input.charCodeAt(e3.position);
                    continue;
                  }
                  e3.position = o3, e3.line = s3, e3.lineStart = u2, e3.lineIndent = l3;
                  break;
                }
              }
              a3 && (O(e3, i3, o3, false), M(e3, e3.line - s3), i3 = o3 = e3.position, a3 = false), y(c3) || (o3 = e3.position + 1), c3 = e3.input.charCodeAt(++e3.position);
            }
            return O(e3, i3, o3, false), !!e3.result || (e3.kind = h3, e3.result = p3, false);
          }(e2, f2, 1 === r2) && (S2 = true, null === e2.tag && (e2.tag = "?")) : (S2 = true, null === e2.tag && null === e2.anchor || A(e2, "alias node should not have any properties")), null !== e2.anchor && (e2.anchorMap[e2.anchor] = e2.result)) : 0 === b2 && (S2 = l2 && B(e2, d2))), null !== e2.tag && "!" !== e2.tag)
            if ("?" === e2.tag) {
              for (null !== e2.result && "scalar" !== e2.kind && A(e2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e2.kind + '"'), c2 = 0, h2 = e2.implicitTypes.length; c2 < h2; c2 += 1)
                if ((p2 = e2.implicitTypes[c2]).resolve(e2.result)) {
                  e2.result = p2.construct(e2.result), e2.tag = p2.tag, null !== e2.anchor && (e2.anchorMap[e2.anchor] = e2.result);
                  break;
                }
            } else
              u.call(e2.typeMap[e2.kind || "fallback"], e2.tag) ? (p2 = e2.typeMap[e2.kind || "fallback"][e2.tag], null !== e2.result && p2.kind !== e2.kind && A(e2, "unacceptable node kind for !<" + e2.tag + '> tag; it should be "' + p2.kind + '", not "' + e2.kind + '"'), p2.resolve(e2.result) ? (e2.result = p2.construct(e2.result), null !== e2.anchor && (e2.anchorMap[e2.anchor] = e2.result)) : A(e2, "cannot resolve a node with !<" + e2.tag + "> explicit tag")) : A(e2, "unknown tag !<" + e2.tag + ">");
          return null !== e2.listener && e2.listener("close", e2), null !== e2.tag || null !== e2.anchor || S2;
        }
        function U(e2) {
          var t2, r2, n2, i2, o2 = e2.position, a2 = false;
          for (e2.version = null, e2.checkLineBreaks = e2.legacy, e2.tagMap = {}, e2.anchorMap = {}; 0 !== (i2 = e2.input.charCodeAt(e2.position)) && (I(e2, true, -1), i2 = e2.input.charCodeAt(e2.position), !(e2.lineIndent > 0 || 37 !== i2)); ) {
            for (a2 = true, i2 = e2.input.charCodeAt(++e2.position), t2 = e2.position; 0 !== i2 && !v(i2); )
              i2 = e2.input.charCodeAt(++e2.position);
            for (n2 = [], (r2 = e2.input.slice(t2, e2.position)).length < 1 && A(e2, "directive name must not be less than one character in length"); 0 !== i2; ) {
              for (; y(i2); )
                i2 = e2.input.charCodeAt(++e2.position);
              if (35 === i2) {
                do {
                  i2 = e2.input.charCodeAt(++e2.position);
                } while (0 !== i2 && !m(i2));
                break;
              }
              if (m(i2))
                break;
              for (t2 = e2.position; 0 !== i2 && !v(i2); )
                i2 = e2.input.charCodeAt(++e2.position);
              n2.push(e2.input.slice(t2, e2.position));
            }
            0 !== i2 && P(e2), u.call(T, r2) ? T[r2](e2, r2, n2) : N(e2, 'unknown document directive "' + r2 + '"');
          }
          I(e2, true, -1), 0 === e2.lineIndent && 45 === e2.input.charCodeAt(e2.position) && 45 === e2.input.charCodeAt(e2.position + 1) && 45 === e2.input.charCodeAt(e2.position + 2) ? (e2.position += 3, I(e2, true, -1)) : a2 && A(e2, "directives end mark is expected"), z(e2, e2.lineIndent - 1, 4, false, true), I(e2, true, -1), e2.checkLineBreaks && c.test(e2.input.slice(o2, e2.position)) && N(e2, "non-ASCII line breaks are interpreted as content"), e2.documents.push(e2.result), e2.position === e2.lineStart && L(e2) ? 46 === e2.input.charCodeAt(e2.position) && (e2.position += 3, I(e2, true, -1)) : e2.position < e2.length - 1 && A(e2, "end of the stream or a document separator is expected");
        }
        function G(e2, t2) {
          t2 = t2 || {}, 0 !== (e2 = String(e2)).length && (10 !== e2.charCodeAt(e2.length - 1) && 13 !== e2.charCodeAt(e2.length - 1) && (e2 += "\n"), 65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)));
          var r2 = new S(e2, t2), n2 = e2.indexOf("\0");
          for (-1 !== n2 && (r2.position = n2, A(r2, "null byte is not allowed in input")), r2.input += "\0"; 32 === r2.input.charCodeAt(r2.position); )
            r2.lineIndent += 1, r2.position += 1;
          for (; r2.position < r2.length - 1; )
            U(r2);
          return r2.documents;
        }
        function X(e2, t2, r2) {
          null !== t2 && "object" == typeof t2 && void 0 === r2 && (r2 = t2, t2 = null);
          var n2 = G(e2, r2);
          if ("function" != typeof t2)
            return n2;
          for (var i2 = 0, o2 = n2.length; i2 < o2; i2 += 1)
            t2(n2[i2]);
        }
        function q(e2, t2) {
          var r2 = G(e2, t2);
          if (0 !== r2.length) {
            if (1 === r2.length)
              return r2[0];
            throw new i("expected a single document in the stream, but found more");
          }
        }
        e.exports.loadAll = X, e.exports.load = q, e.exports.safeLoadAll = function(e2, t2, r2) {
          return "object" == typeof t2 && null !== t2 && void 0 === r2 && (r2 = t2, t2 = null), X(e2, t2, n.extend({ schema: a }, r2));
        }, e.exports.safeLoad = function(e2, t2) {
          return q(e2, n.extend({ schema: a }, t2));
        };
      }, function(e, t, r) {
        "use strict";
        var n = r(38);
        function i(e2, t2, r2, n2, i2) {
          this.name = e2, this.buffer = t2, this.position = r2, this.line = n2, this.column = i2;
        }
        i.prototype.getSnippet = function(e2, t2) {
          var r2, i2, o, a, s;
          if (!this.buffer)
            return null;
          for (e2 = e2 || 4, t2 = t2 || 75, r2 = "", i2 = this.position; i2 > 0 && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(i2 - 1)); )
            if (i2 -= 1, this.position - i2 > t2 / 2 - 1) {
              r2 = " ... ", i2 += 5;
              break;
            }
          for (o = "", a = this.position; a < this.buffer.length && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(a)); )
            if ((a += 1) - this.position > t2 / 2 - 1) {
              o = " ... ", a -= 5;
              break;
            }
          return s = this.buffer.slice(i2, a), n.repeat(" ", e2) + r2 + s + o + "\n" + n.repeat(" ", e2 + this.position - i2 + r2.length) + "^";
        }, i.prototype.toString = function(e2) {
          var t2, r2 = "";
          return this.name && (r2 += 'in "' + this.name + '" '), r2 += "at line " + (this.line + 1) + ", column " + (this.column + 1), e2 || (t2 = this.getSnippet()) && (r2 += ":\n" + t2), r2;
        }, e.exports = i;
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:str", { kind: "scalar", construct: function(e2) {
          return null !== e2 ? e2 : "";
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:seq", { kind: "sequence", construct: function(e2) {
          return null !== e2 ? e2 : [];
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:map", { kind: "mapping", construct: function(e2) {
          return null !== e2 ? e2 : {};
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:null", { kind: "scalar", resolve: function(e2) {
          if (null === e2)
            return true;
          var t2 = e2.length;
          return 1 === t2 && "~" === e2 || 4 === t2 && ("null" === e2 || "Null" === e2 || "NULL" === e2);
        }, construct: function() {
          return null;
        }, predicate: function(e2) {
          return null === e2;
        }, represent: { canonical: function() {
          return "~";
        }, lowercase: function() {
          return "null";
        }, uppercase: function() {
          return "NULL";
        }, camelcase: function() {
          return "Null";
        } }, defaultStyle: "lowercase" });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:bool", { kind: "scalar", resolve: function(e2) {
          if (null === e2)
            return false;
          var t2 = e2.length;
          return 4 === t2 && ("true" === e2 || "True" === e2 || "TRUE" === e2) || 5 === t2 && ("false" === e2 || "False" === e2 || "FALSE" === e2);
        }, construct: function(e2) {
          return "true" === e2 || "True" === e2 || "TRUE" === e2;
        }, predicate: function(e2) {
          return "[object Boolean]" === Object.prototype.toString.call(e2);
        }, represent: { lowercase: function(e2) {
          return e2 ? "true" : "false";
        }, uppercase: function(e2) {
          return e2 ? "TRUE" : "FALSE";
        }, camelcase: function(e2) {
          return e2 ? "True" : "False";
        } }, defaultStyle: "lowercase" });
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(10);
        function o(e2) {
          return 48 <= e2 && e2 <= 55;
        }
        function a(e2) {
          return 48 <= e2 && e2 <= 57;
        }
        e.exports = new i("tag:yaml.org,2002:int", { kind: "scalar", resolve: function(e2) {
          if (null === e2)
            return false;
          var t2, r2, n2 = e2.length, i2 = 0, s = false;
          if (!n2)
            return false;
          if ("-" !== (t2 = e2[i2]) && "+" !== t2 || (t2 = e2[++i2]), "0" === t2) {
            if (i2 + 1 === n2)
              return true;
            if ("b" === (t2 = e2[++i2])) {
              for (i2++; i2 < n2; i2++)
                if ("_" !== (t2 = e2[i2])) {
                  if ("0" !== t2 && "1" !== t2)
                    return false;
                  s = true;
                }
              return s && "_" !== t2;
            }
            if ("x" === t2) {
              for (i2++; i2 < n2; i2++)
                if ("_" !== (t2 = e2[i2])) {
                  if (!(48 <= (r2 = e2.charCodeAt(i2)) && r2 <= 57 || 65 <= r2 && r2 <= 70 || 97 <= r2 && r2 <= 102))
                    return false;
                  s = true;
                }
              return s && "_" !== t2;
            }
            for (; i2 < n2; i2++)
              if ("_" !== (t2 = e2[i2])) {
                if (!o(e2.charCodeAt(i2)))
                  return false;
                s = true;
              }
            return s && "_" !== t2;
          }
          if ("_" === t2)
            return false;
          for (; i2 < n2; i2++)
            if ("_" !== (t2 = e2[i2])) {
              if (":" === t2)
                break;
              if (!a(e2.charCodeAt(i2)))
                return false;
              s = true;
            }
          return !(!s || "_" === t2) && (":" !== t2 || /^(:[0-5]?[0-9])+$/.test(e2.slice(i2)));
        }, construct: function(e2) {
          var t2, r2, n2 = e2, i2 = 1, o2 = [];
          return -1 !== n2.indexOf("_") && (n2 = n2.replace(/_/g, "")), "-" !== (t2 = n2[0]) && "+" !== t2 || ("-" === t2 && (i2 = -1), t2 = (n2 = n2.slice(1))[0]), "0" === n2 ? 0 : "0" === t2 ? "b" === n2[1] ? i2 * parseInt(n2.slice(2), 2) : "x" === n2[1] ? i2 * parseInt(n2, 16) : i2 * parseInt(n2, 8) : -1 !== n2.indexOf(":") ? (n2.split(":").forEach(function(e3) {
            o2.unshift(parseInt(e3, 10));
          }), n2 = 0, r2 = 1, o2.forEach(function(e3) {
            n2 += e3 * r2, r2 *= 60;
          }), i2 * n2) : i2 * parseInt(n2, 10);
        }, predicate: function(e2) {
          return "[object Number]" === Object.prototype.toString.call(e2) && e2 % 1 == 0 && !n.isNegativeZero(e2);
        }, represent: { binary: function(e2) {
          return e2 >= 0 ? "0b" + e2.toString(2) : "-0b" + e2.toString(2).slice(1);
        }, octal: function(e2) {
          return e2 >= 0 ? "0" + e2.toString(8) : "-0" + e2.toString(8).slice(1);
        }, decimal: function(e2) {
          return e2.toString(10);
        }, hexadecimal: function(e2) {
          return e2 >= 0 ? "0x" + e2.toString(16).toUpperCase() : "-0x" + e2.toString(16).toUpperCase().slice(1);
        } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } });
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(10), o = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
        var a = /^[-+]?[0-9]+e/;
        e.exports = new i("tag:yaml.org,2002:float", { kind: "scalar", resolve: function(e2) {
          return null !== e2 && !(!o.test(e2) || "_" === e2[e2.length - 1]);
        }, construct: function(e2) {
          var t2, r2, n2, i2;
          return r2 = "-" === (t2 = e2.replace(/_/g, "").toLowerCase())[0] ? -1 : 1, i2 = [], "+-".indexOf(t2[0]) >= 0 && (t2 = t2.slice(1)), ".inf" === t2 ? 1 === r2 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : ".nan" === t2 ? NaN : t2.indexOf(":") >= 0 ? (t2.split(":").forEach(function(e3) {
            i2.unshift(parseFloat(e3, 10));
          }), t2 = 0, n2 = 1, i2.forEach(function(e3) {
            t2 += e3 * n2, n2 *= 60;
          }), r2 * t2) : r2 * parseFloat(t2, 10);
        }, predicate: function(e2) {
          return "[object Number]" === Object.prototype.toString.call(e2) && (e2 % 1 != 0 || n.isNegativeZero(e2));
        }, represent: function(e2, t2) {
          var r2;
          if (isNaN(e2))
            switch (t2) {
              case "lowercase":
                return ".nan";
              case "uppercase":
                return ".NAN";
              case "camelcase":
                return ".NaN";
            }
          else if (Number.POSITIVE_INFINITY === e2)
            switch (t2) {
              case "lowercase":
                return ".inf";
              case "uppercase":
                return ".INF";
              case "camelcase":
                return ".Inf";
            }
          else if (Number.NEGATIVE_INFINITY === e2)
            switch (t2) {
              case "lowercase":
                return "-.inf";
              case "uppercase":
                return "-.INF";
              case "camelcase":
                return "-.Inf";
            }
          else if (n.isNegativeZero(e2))
            return "-0.0";
          return r2 = e2.toString(10), a.test(r2) ? r2.replace("e", ".e") : r2;
        }, defaultStyle: "lowercase" });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), o = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
        e.exports = new n("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: function(e2) {
          return null !== e2 && (null !== i.exec(e2) || null !== o.exec(e2));
        }, construct: function(e2) {
          var t2, r2, n2, a, s, u, l, c, h = 0, p = null;
          if (null === (t2 = i.exec(e2)) && (t2 = o.exec(e2)), null === t2)
            throw new Error("Date resolve error");
          if (r2 = +t2[1], n2 = +t2[2] - 1, a = +t2[3], !t2[4])
            return new Date(Date.UTC(r2, n2, a));
          if (s = +t2[4], u = +t2[5], l = +t2[6], t2[7]) {
            for (h = t2[7].slice(0, 3); h.length < 3; )
              h += "0";
            h = +h;
          }
          return t2[9] && (p = 6e4 * (60 * +t2[10] + +(t2[11] || 0)), "-" === t2[9] && (p = -p)), c = new Date(Date.UTC(r2, n2, a, s, u, l, h)), p && c.setTime(c.getTime() - p), c;
        }, instanceOf: Date, represent: function(e2) {
          return e2.toISOString();
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:merge", { kind: "scalar", resolve: function(e2) {
          return "<<" === e2 || null === e2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n;
        try {
          n = r(145).Buffer;
        } catch (e2) {
        }
        var i = r(10), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
        e.exports = new i("tag:yaml.org,2002:binary", { kind: "scalar", resolve: function(e2) {
          if (null === e2)
            return false;
          var t2, r2, n2 = 0, i2 = e2.length, a = o;
          for (r2 = 0; r2 < i2; r2++)
            if (!((t2 = a.indexOf(e2.charAt(r2))) > 64)) {
              if (t2 < 0)
                return false;
              n2 += 6;
            }
          return n2 % 8 == 0;
        }, construct: function(e2) {
          var t2, r2, i2 = e2.replace(/[\r\n=]/g, ""), a = i2.length, s = o, u = 0, l = [];
          for (t2 = 0; t2 < a; t2++)
            t2 % 4 == 0 && t2 && (l.push(u >> 16 & 255), l.push(u >> 8 & 255), l.push(255 & u)), u = u << 6 | s.indexOf(i2.charAt(t2));
          return 0 === (r2 = a % 4 * 6) ? (l.push(u >> 16 & 255), l.push(u >> 8 & 255), l.push(255 & u)) : 18 === r2 ? (l.push(u >> 10 & 255), l.push(u >> 2 & 255)) : 12 === r2 && l.push(u >> 4 & 255), n ? n.from ? n.from(l) : new n(l) : l;
        }, predicate: function(e2) {
          return n && n.isBuffer(e2);
        }, represent: function(e2) {
          var t2, r2, n2 = "", i2 = 0, a = e2.length, s = o;
          for (t2 = 0; t2 < a; t2++)
            t2 % 3 == 0 && t2 && (n2 += s[i2 >> 18 & 63], n2 += s[i2 >> 12 & 63], n2 += s[i2 >> 6 & 63], n2 += s[63 & i2]), i2 = (i2 << 8) + e2[t2];
          return 0 === (r2 = a % 3) ? (n2 += s[i2 >> 18 & 63], n2 += s[i2 >> 12 & 63], n2 += s[i2 >> 6 & 63], n2 += s[63 & i2]) : 2 === r2 ? (n2 += s[i2 >> 10 & 63], n2 += s[i2 >> 4 & 63], n2 += s[i2 << 2 & 63], n2 += s[64]) : 1 === r2 && (n2 += s[i2 >> 2 & 63], n2 += s[i2 << 4 & 63], n2 += s[64], n2 += s[64]), n2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = Object.prototype.hasOwnProperty, o = Object.prototype.toString;
        e.exports = new n("tag:yaml.org,2002:omap", { kind: "sequence", resolve: function(e2) {
          if (null === e2)
            return true;
          var t2, r2, n2, a, s, u = [], l = e2;
          for (t2 = 0, r2 = l.length; t2 < r2; t2 += 1) {
            if (n2 = l[t2], s = false, "[object Object]" !== o.call(n2))
              return false;
            for (a in n2)
              if (i.call(n2, a)) {
                if (s)
                  return false;
                s = true;
              }
            if (!s)
              return false;
            if (-1 !== u.indexOf(a))
              return false;
            u.push(a);
          }
          return true;
        }, construct: function(e2) {
          return null !== e2 ? e2 : [];
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = Object.prototype.toString;
        e.exports = new n("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: function(e2) {
          if (null === e2)
            return true;
          var t2, r2, n2, o, a, s = e2;
          for (a = new Array(s.length), t2 = 0, r2 = s.length; t2 < r2; t2 += 1) {
            if (n2 = s[t2], "[object Object]" !== i.call(n2))
              return false;
            if (1 !== (o = Object.keys(n2)).length)
              return false;
            a[t2] = [o[0], n2[o[0]]];
          }
          return true;
        }, construct: function(e2) {
          if (null === e2)
            return [];
          var t2, r2, n2, i2, o, a = e2;
          for (o = new Array(a.length), t2 = 0, r2 = a.length; t2 < r2; t2 += 1)
            n2 = a[t2], i2 = Object.keys(n2), o[t2] = [i2[0], n2[i2[0]]];
          return o;
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10), i = Object.prototype.hasOwnProperty;
        e.exports = new n("tag:yaml.org,2002:set", { kind: "mapping", resolve: function(e2) {
          if (null === e2)
            return true;
          var t2, r2 = e2;
          for (t2 in r2)
            if (i.call(r2, t2) && null !== r2[t2])
              return false;
          return true;
        }, construct: function(e2) {
          return null !== e2 ? e2 : {};
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:js/undefined", { kind: "scalar", resolve: function() {
          return true;
        }, construct: function() {
        }, predicate: function(e2) {
          return void 0 === e2;
        }, represent: function() {
          return "";
        } });
      }, function(e, t, r) {
        "use strict";
        var n = r(10);
        e.exports = new n("tag:yaml.org,2002:js/regexp", { kind: "scalar", resolve: function(e2) {
          if (null === e2)
            return false;
          if (0 === e2.length)
            return false;
          var t2 = e2, r2 = /\/([gim]*)$/.exec(e2), n2 = "";
          if ("/" === t2[0]) {
            if (r2 && (n2 = r2[1]), n2.length > 3)
              return false;
            if ("/" !== t2[t2.length - n2.length - 1])
              return false;
          }
          return true;
        }, construct: function(e2) {
          var t2 = e2, r2 = /\/([gim]*)$/.exec(e2), n2 = "";
          return "/" === t2[0] && (r2 && (n2 = r2[1]), t2 = t2.slice(1, t2.length - n2.length - 1)), new RegExp(t2, n2);
        }, predicate: function(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }, represent: function(e2) {
          var t2 = "/" + e2.source + "/";
          return e2.global && (t2 += "g"), e2.multiline && (t2 += "m"), e2.ignoreCase && (t2 += "i"), t2;
        } });
      }, function(e, t, r) {
        "use strict";
        var n;
        try {
          n = r(303);
        } catch (e2) {
          "undefined" != typeof window && (n = window.esprima);
        }
        var i = r(10);
        e.exports = new i("tag:yaml.org,2002:js/function", { kind: "scalar", resolve: function(e2) {
          if (null === e2)
            return false;
          try {
            var t2 = "(" + e2 + ")", r2 = n.parse(t2, { range: true });
            return "Program" === r2.type && 1 === r2.body.length && "ExpressionStatement" === r2.body[0].type && ("ArrowFunctionExpression" === r2.body[0].expression.type || "FunctionExpression" === r2.body[0].expression.type);
          } catch (e3) {
            return false;
          }
        }, construct: function(e2) {
          var t2, r2 = "(" + e2 + ")", i2 = n.parse(r2, { range: true }), o = [];
          if ("Program" !== i2.type || 1 !== i2.body.length || "ExpressionStatement" !== i2.body[0].type || "ArrowFunctionExpression" !== i2.body[0].expression.type && "FunctionExpression" !== i2.body[0].expression.type)
            throw new Error("Failed to resolve function");
          return i2.body[0].expression.params.forEach(function(e3) {
            o.push(e3.name);
          }), t2 = i2.body[0].expression.body.range, "BlockStatement" === i2.body[0].expression.body.type ? new Function(o, r2.slice(t2[0] + 1, t2[1] - 1)) : new Function(o, "return " + r2.slice(t2[0], t2[1]));
        }, predicate: function(e2) {
          return "[object Function]" === Object.prototype.toString.call(e2);
        }, represent: function(e2) {
          return e2.toString();
        } });
      }, function(e, t, r) {
        var n;
        n = function() {
          return function(e2) {
            var t2 = {};
            function r2(n2) {
              if (t2[n2])
                return t2[n2].exports;
              var i = t2[n2] = { exports: {}, id: n2, loaded: false };
              return e2[n2].call(i.exports, i, i.exports, r2), i.loaded = true, i.exports;
            }
            return r2.m = e2, r2.c = t2, r2.p = "", r2(0);
          }([function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(1), i = r2(3), o = r2(8), a = r2(15);
            function s(e3, t3, r3) {
              var a2 = null, s2 = function(e4, t4) {
                r3 && r3(e4, t4), a2 && a2.visit(e4, t4);
              }, u2 = "function" == typeof r3 ? s2 : null, l = false;
              if (t3) {
                l = "boolean" == typeof t3.comment && t3.comment;
                var c = "boolean" == typeof t3.attachComment && t3.attachComment;
                (l || c) && ((a2 = new n2.CommentHandler()).attach = c, t3.comment = true, u2 = s2);
              }
              var h, p = false;
              t3 && "string" == typeof t3.sourceType && (p = "module" === t3.sourceType), h = t3 && "boolean" == typeof t3.jsx && t3.jsx ? new i.JSXParser(e3, t3, u2) : new o.Parser(e3, t3, u2);
              var f = p ? h.parseModule() : h.parseScript();
              return l && a2 && (f.comments = a2.comments), h.config.tokens && (f.tokens = h.tokens), h.config.tolerant && (f.errors = h.errorHandler.errors), f;
            }
            t2.parse = s, t2.parseModule = function(e3, t3, r3) {
              var n3 = t3 || {};
              return n3.sourceType = "module", s(e3, n3, r3);
            }, t2.parseScript = function(e3, t3, r3) {
              var n3 = t3 || {};
              return n3.sourceType = "script", s(e3, n3, r3);
            }, t2.tokenize = function(e3, t3, r3) {
              var n3, i2 = new a.Tokenizer(e3, t3);
              n3 = [];
              try {
                for (; ; ) {
                  var o2 = i2.getNextToken();
                  if (!o2)
                    break;
                  r3 && (o2 = r3(o2)), n3.push(o2);
                }
              } catch (e4) {
                i2.errorHandler.tolerate(e4);
              }
              return i2.errorHandler.tolerant && (n3.errors = i2.errors()), n3;
            };
            var u = r2(2);
            t2.Syntax = u.Syntax, t2.version = "4.0.1";
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(2), i = function() {
              function e3() {
                this.attach = false, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
              }
              return e3.prototype.insertInnerComments = function(e4, t3) {
                if (e4.type === n2.Syntax.BlockStatement && 0 === e4.body.length) {
                  for (var r3 = [], i2 = this.leading.length - 1; i2 >= 0; --i2) {
                    var o = this.leading[i2];
                    t3.end.offset >= o.start && (r3.unshift(o.comment), this.leading.splice(i2, 1), this.trailing.splice(i2, 1));
                  }
                  r3.length && (e4.innerComments = r3);
                }
              }, e3.prototype.findTrailingComments = function(e4) {
                var t3 = [];
                if (this.trailing.length > 0) {
                  for (var r3 = this.trailing.length - 1; r3 >= 0; --r3) {
                    var n3 = this.trailing[r3];
                    n3.start >= e4.end.offset && t3.unshift(n3.comment);
                  }
                  return this.trailing.length = 0, t3;
                }
                var i2 = this.stack[this.stack.length - 1];
                if (i2 && i2.node.trailingComments) {
                  var o = i2.node.trailingComments[0];
                  o && o.range[0] >= e4.end.offset && (t3 = i2.node.trailingComments, delete i2.node.trailingComments);
                }
                return t3;
              }, e3.prototype.findLeadingComments = function(e4) {
                for (var t3, r3 = []; this.stack.length > 0 && ((o = this.stack[this.stack.length - 1]) && o.start >= e4.start.offset); )
                  t3 = o.node, this.stack.pop();
                if (t3) {
                  for (var n3 = (t3.leadingComments ? t3.leadingComments.length : 0) - 1; n3 >= 0; --n3) {
                    var i2 = t3.leadingComments[n3];
                    i2.range[1] <= e4.start.offset && (r3.unshift(i2), t3.leadingComments.splice(n3, 1));
                  }
                  return t3.leadingComments && 0 === t3.leadingComments.length && delete t3.leadingComments, r3;
                }
                for (n3 = this.leading.length - 1; n3 >= 0; --n3) {
                  var o;
                  (o = this.leading[n3]).start <= e4.start.offset && (r3.unshift(o.comment), this.leading.splice(n3, 1));
                }
                return r3;
              }, e3.prototype.visitNode = function(e4, t3) {
                if (!(e4.type === n2.Syntax.Program && e4.body.length > 0)) {
                  this.insertInnerComments(e4, t3);
                  var r3 = this.findTrailingComments(t3), i2 = this.findLeadingComments(t3);
                  i2.length > 0 && (e4.leadingComments = i2), r3.length > 0 && (e4.trailingComments = r3), this.stack.push({ node: e4, start: t3.start.offset });
                }
              }, e3.prototype.visitComment = function(e4, t3) {
                var r3 = "L" === e4.type[0] ? "Line" : "Block", n3 = { type: r3, value: e4.value };
                if (e4.range && (n3.range = e4.range), e4.loc && (n3.loc = e4.loc), this.comments.push(n3), this.attach) {
                  var i2 = { comment: { type: r3, value: e4.value, range: [t3.start.offset, t3.end.offset] }, start: t3.start.offset };
                  e4.loc && (i2.comment.loc = e4.loc), e4.type = r3, this.leading.push(i2), this.trailing.push(i2);
                }
              }, e3.prototype.visit = function(e4, t3) {
                "LineComment" === e4.type || "BlockComment" === e4.type ? this.visitComment(e4, t3) : this.attach && this.visitNode(e4, t3);
              }, e3;
            }();
            t2.CommentHandler = i;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.Syntax = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DoWhileStatement: "DoWhileStatement", DebuggerStatement: "DebuggerStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForOfStatement: "ForOfStatement", ForInStatement: "ForInStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchCase: "SwitchCase", SwitchStatement: "SwitchStatement", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" };
          }, function(e2, t2, r2) {
            "use strict";
            var n2, i = this && this.__extends || (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
              e3.__proto__ = t3;
            } || function(e3, t3) {
              for (var r3 in t3)
                t3.hasOwnProperty(r3) && (e3[r3] = t3[r3]);
            }, function(e3, t3) {
              function r3() {
                this.constructor = e3;
              }
              n2(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (r3.prototype = t3.prototype, new r3());
            });
            Object.defineProperty(t2, "__esModule", { value: true });
            var o = r2(4), a = r2(5), s = r2(6), u = r2(7), l = r2(8), c = r2(13), h = r2(14);
            function p(e3) {
              var t3;
              switch (e3.type) {
                case s.JSXSyntax.JSXIdentifier:
                  t3 = e3.name;
                  break;
                case s.JSXSyntax.JSXNamespacedName:
                  var r3 = e3;
                  t3 = p(r3.namespace) + ":" + p(r3.name);
                  break;
                case s.JSXSyntax.JSXMemberExpression:
                  var n3 = e3;
                  t3 = p(n3.object) + "." + p(n3.property);
              }
              return t3;
            }
            c.TokenName[100] = "JSXIdentifier", c.TokenName[101] = "JSXText";
            var f = function(e3) {
              function t3(t4, r3, n3) {
                return e3.call(this, t4, r3, n3) || this;
              }
              return i(t3, e3), t3.prototype.parsePrimaryExpression = function() {
                return this.match("<") ? this.parseJSXRoot() : e3.prototype.parsePrimaryExpression.call(this);
              }, t3.prototype.startJSX = function() {
                this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
              }, t3.prototype.finishJSX = function() {
                this.nextToken();
              }, t3.prototype.reenterJSX = function() {
                this.startJSX(), this.expectJSX("}"), this.config.tokens && this.tokens.pop();
              }, t3.prototype.createJSXNode = function() {
                return this.collectComments(), { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
              }, t3.prototype.createJSXChildNode = function() {
                return { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
              }, t3.prototype.scanXHTMLEntity = function(e4) {
                for (var t4 = "&", r3 = true, n3 = false, i2 = false, a2 = false; !this.scanner.eof() && r3 && !n3; ) {
                  var s2 = this.scanner.source[this.scanner.index];
                  if (s2 === e4)
                    break;
                  if (n3 = ";" === s2, t4 += s2, ++this.scanner.index, !n3)
                    switch (t4.length) {
                      case 2:
                        i2 = "#" === s2;
                        break;
                      case 3:
                        i2 && (r3 = (a2 = "x" === s2) || o.Character.isDecimalDigit(s2.charCodeAt(0)), i2 = i2 && !a2);
                        break;
                      default:
                        r3 = (r3 = r3 && !(i2 && !o.Character.isDecimalDigit(s2.charCodeAt(0)))) && !(a2 && !o.Character.isHexDigit(s2.charCodeAt(0)));
                    }
                }
                if (r3 && n3 && t4.length > 2) {
                  var u2 = t4.substr(1, t4.length - 2);
                  i2 && u2.length > 1 ? t4 = String.fromCharCode(parseInt(u2.substr(1), 10)) : a2 && u2.length > 2 ? t4 = String.fromCharCode(parseInt("0" + u2.substr(1), 16)) : i2 || a2 || !h.XHTMLEntities[u2] || (t4 = h.XHTMLEntities[u2]);
                }
                return t4;
              }, t3.prototype.lexJSX = function() {
                var e4 = this.scanner.source.charCodeAt(this.scanner.index);
                if (60 === e4 || 62 === e4 || 47 === e4 || 58 === e4 || 61 === e4 || 123 === e4 || 125 === e4)
                  return { type: 7, value: s2 = this.scanner.source[this.scanner.index++], lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index - 1, end: this.scanner.index };
                if (34 === e4 || 39 === e4) {
                  for (var t4 = this.scanner.index, r3 = this.scanner.source[this.scanner.index++], n3 = ""; !this.scanner.eof() && (u2 = this.scanner.source[this.scanner.index++]) !== r3; )
                    n3 += "&" === u2 ? this.scanXHTMLEntity(r3) : u2;
                  return { type: 8, value: n3, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t4, end: this.scanner.index };
                }
                if (46 === e4) {
                  var i2 = this.scanner.source.charCodeAt(this.scanner.index + 1), a2 = this.scanner.source.charCodeAt(this.scanner.index + 2), s2 = 46 === i2 && 46 === a2 ? "..." : ".";
                  return t4 = this.scanner.index, this.scanner.index += s2.length, { type: 7, value: s2, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t4, end: this.scanner.index };
                }
                if (96 === e4)
                  return { type: 10, value: "", lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index, end: this.scanner.index };
                if (o.Character.isIdentifierStart(e4) && 92 !== e4) {
                  for (t4 = this.scanner.index, ++this.scanner.index; !this.scanner.eof(); ) {
                    var u2 = this.scanner.source.charCodeAt(this.scanner.index);
                    if (o.Character.isIdentifierPart(u2) && 92 !== u2)
                      ++this.scanner.index;
                    else {
                      if (45 !== u2)
                        break;
                      ++this.scanner.index;
                    }
                  }
                  return { type: 100, value: this.scanner.source.slice(t4, this.scanner.index), lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: t4, end: this.scanner.index };
                }
                return this.scanner.lex();
              }, t3.prototype.nextJSXToken = function() {
                this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                var e4 = this.lexJSX();
                return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(e4)), e4;
              }, t3.prototype.nextJSXText = function() {
                this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                for (var e4 = this.scanner.index, t4 = ""; !this.scanner.eof(); ) {
                  var r3 = this.scanner.source[this.scanner.index];
                  if ("{" === r3 || "<" === r3)
                    break;
                  ++this.scanner.index, t4 += r3, o.Character.isLineTerminator(r3.charCodeAt(0)) && (++this.scanner.lineNumber, "\r" === r3 && "\n" === this.scanner.source[this.scanner.index] && ++this.scanner.index, this.scanner.lineStart = this.scanner.index);
                }
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                var n3 = { type: 101, value: t4, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: e4, end: this.scanner.index };
                return t4.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(n3)), n3;
              }, t3.prototype.peekJSXToken = function() {
                var e4 = this.scanner.saveState();
                this.scanner.scanComments();
                var t4 = this.lexJSX();
                return this.scanner.restoreState(e4), t4;
              }, t3.prototype.expectJSX = function(e4) {
                var t4 = this.nextJSXToken();
                7 === t4.type && t4.value === e4 || this.throwUnexpectedToken(t4);
              }, t3.prototype.matchJSX = function(e4) {
                var t4 = this.peekJSXToken();
                return 7 === t4.type && t4.value === e4;
              }, t3.prototype.parseJSXIdentifier = function() {
                var e4 = this.createJSXNode(), t4 = this.nextJSXToken();
                return 100 !== t4.type && this.throwUnexpectedToken(t4), this.finalize(e4, new a.JSXIdentifier(t4.value));
              }, t3.prototype.parseJSXElementName = function() {
                var e4 = this.createJSXNode(), t4 = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var r3 = t4;
                  this.expectJSX(":");
                  var n3 = this.parseJSXIdentifier();
                  t4 = this.finalize(e4, new a.JSXNamespacedName(r3, n3));
                } else if (this.matchJSX("."))
                  for (; this.matchJSX("."); ) {
                    var i2 = t4;
                    this.expectJSX(".");
                    var o2 = this.parseJSXIdentifier();
                    t4 = this.finalize(e4, new a.JSXMemberExpression(i2, o2));
                  }
                return t4;
              }, t3.prototype.parseJSXAttributeName = function() {
                var e4, t4 = this.createJSXNode(), r3 = this.parseJSXIdentifier();
                if (this.matchJSX(":")) {
                  var n3 = r3;
                  this.expectJSX(":");
                  var i2 = this.parseJSXIdentifier();
                  e4 = this.finalize(t4, new a.JSXNamespacedName(n3, i2));
                } else
                  e4 = r3;
                return e4;
              }, t3.prototype.parseJSXStringLiteralAttribute = function() {
                var e4 = this.createJSXNode(), t4 = this.nextJSXToken();
                8 !== t4.type && this.throwUnexpectedToken(t4);
                var r3 = this.getTokenRaw(t4);
                return this.finalize(e4, new u.Literal(t4.value, r3));
              }, t3.prototype.parseJSXExpressionAttribute = function() {
                var e4 = this.createJSXNode();
                this.expectJSX("{"), this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                var t4 = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(e4, new a.JSXExpressionContainer(t4));
              }, t3.prototype.parseJSXAttributeValue = function() {
                return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
              }, t3.prototype.parseJSXNameValueAttribute = function() {
                var e4 = this.createJSXNode(), t4 = this.parseJSXAttributeName(), r3 = null;
                return this.matchJSX("=") && (this.expectJSX("="), r3 = this.parseJSXAttributeValue()), this.finalize(e4, new a.JSXAttribute(t4, r3));
              }, t3.prototype.parseJSXSpreadAttribute = function() {
                var e4 = this.createJSXNode();
                this.expectJSX("{"), this.expectJSX("..."), this.finishJSX();
                var t4 = this.parseAssignmentExpression();
                return this.reenterJSX(), this.finalize(e4, new a.JSXSpreadAttribute(t4));
              }, t3.prototype.parseJSXAttributes = function() {
                for (var e4 = []; !this.matchJSX("/") && !this.matchJSX(">"); ) {
                  var t4 = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                  e4.push(t4);
                }
                return e4;
              }, t3.prototype.parseJSXOpeningElement = function() {
                var e4 = this.createJSXNode();
                this.expectJSX("<");
                var t4 = this.parseJSXElementName(), r3 = this.parseJSXAttributes(), n3 = this.matchJSX("/");
                return n3 && this.expectJSX("/"), this.expectJSX(">"), this.finalize(e4, new a.JSXOpeningElement(t4, n3, r3));
              }, t3.prototype.parseJSXBoundaryElement = function() {
                var e4 = this.createJSXNode();
                if (this.expectJSX("<"), this.matchJSX("/")) {
                  this.expectJSX("/");
                  var t4 = this.parseJSXElementName();
                  return this.expectJSX(">"), this.finalize(e4, new a.JSXClosingElement(t4));
                }
                var r3 = this.parseJSXElementName(), n3 = this.parseJSXAttributes(), i2 = this.matchJSX("/");
                return i2 && this.expectJSX("/"), this.expectJSX(">"), this.finalize(e4, new a.JSXOpeningElement(r3, i2, n3));
              }, t3.prototype.parseJSXEmptyExpression = function() {
                var e4 = this.createJSXChildNode();
                return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(e4, new a.JSXEmptyExpression());
              }, t3.prototype.parseJSXExpressionContainer = function() {
                var e4, t4 = this.createJSXNode();
                return this.expectJSX("{"), this.matchJSX("}") ? (e4 = this.parseJSXEmptyExpression(), this.expectJSX("}")) : (this.finishJSX(), e4 = this.parseAssignmentExpression(), this.reenterJSX()), this.finalize(t4, new a.JSXExpressionContainer(e4));
              }, t3.prototype.parseJSXChildren = function() {
                for (var e4 = []; !this.scanner.eof(); ) {
                  var t4 = this.createJSXChildNode(), r3 = this.nextJSXText();
                  if (r3.start < r3.end) {
                    var n3 = this.getTokenRaw(r3), i2 = this.finalize(t4, new a.JSXText(r3.value, n3));
                    e4.push(i2);
                  }
                  if ("{" !== this.scanner.source[this.scanner.index])
                    break;
                  var o2 = this.parseJSXExpressionContainer();
                  e4.push(o2);
                }
                return e4;
              }, t3.prototype.parseComplexJSXElement = function(e4) {
                for (var t4 = []; !this.scanner.eof(); ) {
                  e4.children = e4.children.concat(this.parseJSXChildren());
                  var r3 = this.createJSXChildNode(), n3 = this.parseJSXBoundaryElement();
                  if (n3.type === s.JSXSyntax.JSXOpeningElement) {
                    var i2 = n3;
                    if (i2.selfClosing) {
                      var o2 = this.finalize(r3, new a.JSXElement(i2, [], null));
                      e4.children.push(o2);
                    } else
                      t4.push(e4), e4 = { node: r3, opening: i2, closing: null, children: [] };
                  }
                  if (n3.type === s.JSXSyntax.JSXClosingElement) {
                    e4.closing = n3;
                    var u2 = p(e4.opening.name);
                    if (u2 !== p(e4.closing.name) && this.tolerateError("Expected corresponding JSX closing tag for %0", u2), !(t4.length > 0))
                      break;
                    o2 = this.finalize(e4.node, new a.JSXElement(e4.opening, e4.children, e4.closing)), (e4 = t4[t4.length - 1]).children.push(o2), t4.pop();
                  }
                }
                return e4;
              }, t3.prototype.parseJSXElement = function() {
                var e4 = this.createJSXNode(), t4 = this.parseJSXOpeningElement(), r3 = [], n3 = null;
                if (!t4.selfClosing) {
                  var i2 = this.parseComplexJSXElement({ node: e4, opening: t4, closing: n3, children: r3 });
                  r3 = i2.children, n3 = i2.closing;
                }
                return this.finalize(e4, new a.JSXElement(t4, r3, n3));
              }, t3.prototype.parseJSXRoot = function() {
                this.config.tokens && this.tokens.pop(), this.startJSX();
                var e4 = this.parseJSXElement();
                return this.finishJSX(), e4;
              }, t3.prototype.isStartOfExpression = function() {
                return e3.prototype.isStartOfExpression.call(this) || this.match("<");
              }, t3;
            }(l.Parser);
            t2.JSXParser = f;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var r2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            t2.Character = { fromCodePoint: function(e3) {
              return e3 < 65536 ? String.fromCharCode(e3) : String.fromCharCode(55296 + (e3 - 65536 >> 10)) + String.fromCharCode(56320 + (e3 - 65536 & 1023));
            }, isWhiteSpace: function(e3) {
              return 32 === e3 || 9 === e3 || 11 === e3 || 12 === e3 || 160 === e3 || e3 >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e3) >= 0;
            }, isLineTerminator: function(e3) {
              return 10 === e3 || 13 === e3 || 8232 === e3 || 8233 === e3;
            }, isIdentifierStart: function(e3) {
              return 36 === e3 || 95 === e3 || e3 >= 65 && e3 <= 90 || e3 >= 97 && e3 <= 122 || 92 === e3 || e3 >= 128 && r2.NonAsciiIdentifierStart.test(t2.Character.fromCodePoint(e3));
            }, isIdentifierPart: function(e3) {
              return 36 === e3 || 95 === e3 || e3 >= 65 && e3 <= 90 || e3 >= 97 && e3 <= 122 || e3 >= 48 && e3 <= 57 || 92 === e3 || e3 >= 128 && r2.NonAsciiIdentifierPart.test(t2.Character.fromCodePoint(e3));
            }, isDecimalDigit: function(e3) {
              return e3 >= 48 && e3 <= 57;
            }, isHexDigit: function(e3) {
              return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
            }, isOctalDigit: function(e3) {
              return e3 >= 48 && e3 <= 55;
            } };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(6), i = function(e3) {
              this.type = n2.JSXSyntax.JSXClosingElement, this.name = e3;
            };
            t2.JSXClosingElement = i;
            var o = function(e3, t3, r3) {
              this.type = n2.JSXSyntax.JSXElement, this.openingElement = e3, this.children = t3, this.closingElement = r3;
            };
            t2.JSXElement = o;
            var a = function() {
              this.type = n2.JSXSyntax.JSXEmptyExpression;
            };
            t2.JSXEmptyExpression = a;
            var s = function(e3) {
              this.type = n2.JSXSyntax.JSXExpressionContainer, this.expression = e3;
            };
            t2.JSXExpressionContainer = s;
            var u = function(e3) {
              this.type = n2.JSXSyntax.JSXIdentifier, this.name = e3;
            };
            t2.JSXIdentifier = u;
            var l = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXMemberExpression, this.object = e3, this.property = t3;
            };
            t2.JSXMemberExpression = l;
            var c = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXAttribute, this.name = e3, this.value = t3;
            };
            t2.JSXAttribute = c;
            var h = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXNamespacedName, this.namespace = e3, this.name = t3;
            };
            t2.JSXNamespacedName = h;
            var p = function(e3, t3, r3) {
              this.type = n2.JSXSyntax.JSXOpeningElement, this.name = e3, this.selfClosing = t3, this.attributes = r3;
            };
            t2.JSXOpeningElement = p;
            var f = function(e3) {
              this.type = n2.JSXSyntax.JSXSpreadAttribute, this.argument = e3;
            };
            t2.JSXSpreadAttribute = f;
            var d = function(e3, t3) {
              this.type = n2.JSXSyntax.JSXText, this.value = e3, this.raw = t3;
            };
            t2.JSXText = d;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXSyntax = { JSXAttribute: "JSXAttribute", JSXClosingElement: "JSXClosingElement", JSXElement: "JSXElement", JSXEmptyExpression: "JSXEmptyExpression", JSXExpressionContainer: "JSXExpressionContainer", JSXIdentifier: "JSXIdentifier", JSXMemberExpression: "JSXMemberExpression", JSXNamespacedName: "JSXNamespacedName", JSXOpeningElement: "JSXOpeningElement", JSXSpreadAttribute: "JSXSpreadAttribute", JSXText: "JSXText" };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(2), i = function(e3) {
              this.type = n2.Syntax.ArrayExpression, this.elements = e3;
            };
            t2.ArrayExpression = i;
            var o = function(e3) {
              this.type = n2.Syntax.ArrayPattern, this.elements = e3;
            };
            t2.ArrayPattern = o;
            var a = function(e3, t3, r3) {
              this.type = n2.Syntax.ArrowFunctionExpression, this.id = null, this.params = e3, this.body = t3, this.generator = false, this.expression = r3, this.async = false;
            };
            t2.ArrowFunctionExpression = a;
            var s = function(e3, t3, r3) {
              this.type = n2.Syntax.AssignmentExpression, this.operator = e3, this.left = t3, this.right = r3;
            };
            t2.AssignmentExpression = s;
            var u = function(e3, t3) {
              this.type = n2.Syntax.AssignmentPattern, this.left = e3, this.right = t3;
            };
            t2.AssignmentPattern = u;
            var l = function(e3, t3, r3) {
              this.type = n2.Syntax.ArrowFunctionExpression, this.id = null, this.params = e3, this.body = t3, this.generator = false, this.expression = r3, this.async = true;
            };
            t2.AsyncArrowFunctionExpression = l;
            var c = function(e3, t3, r3) {
              this.type = n2.Syntax.FunctionDeclaration, this.id = e3, this.params = t3, this.body = r3, this.generator = false, this.expression = false, this.async = true;
            };
            t2.AsyncFunctionDeclaration = c;
            var h = function(e3, t3, r3) {
              this.type = n2.Syntax.FunctionExpression, this.id = e3, this.params = t3, this.body = r3, this.generator = false, this.expression = false, this.async = true;
            };
            t2.AsyncFunctionExpression = h;
            var p = function(e3) {
              this.type = n2.Syntax.AwaitExpression, this.argument = e3;
            };
            t2.AwaitExpression = p;
            var f = function(e3, t3, r3) {
              var i2 = "||" === e3 || "&&" === e3;
              this.type = i2 ? n2.Syntax.LogicalExpression : n2.Syntax.BinaryExpression, this.operator = e3, this.left = t3, this.right = r3;
            };
            t2.BinaryExpression = f;
            var d = function(e3) {
              this.type = n2.Syntax.BlockStatement, this.body = e3;
            };
            t2.BlockStatement = d;
            var m = function(e3) {
              this.type = n2.Syntax.BreakStatement, this.label = e3;
            };
            t2.BreakStatement = m;
            var y = function(e3, t3) {
              this.type = n2.Syntax.CallExpression, this.callee = e3, this.arguments = t3;
            };
            t2.CallExpression = y;
            var v = function(e3, t3) {
              this.type = n2.Syntax.CatchClause, this.param = e3, this.body = t3;
            };
            t2.CatchClause = v;
            var _ = function(e3) {
              this.type = n2.Syntax.ClassBody, this.body = e3;
            };
            t2.ClassBody = _;
            var g = function(e3, t3, r3) {
              this.type = n2.Syntax.ClassDeclaration, this.id = e3, this.superClass = t3, this.body = r3;
            };
            t2.ClassDeclaration = g;
            var b = function(e3, t3, r3) {
              this.type = n2.Syntax.ClassExpression, this.id = e3, this.superClass = t3, this.body = r3;
            };
            t2.ClassExpression = b;
            var x = function(e3, t3) {
              this.type = n2.Syntax.MemberExpression, this.computed = true, this.object = e3, this.property = t3;
            };
            t2.ComputedMemberExpression = x;
            var w = function(e3, t3, r3) {
              this.type = n2.Syntax.ConditionalExpression, this.test = e3, this.consequent = t3, this.alternate = r3;
            };
            t2.ConditionalExpression = w;
            var E = function(e3) {
              this.type = n2.Syntax.ContinueStatement, this.label = e3;
            };
            t2.ContinueStatement = E;
            var D = function() {
              this.type = n2.Syntax.DebuggerStatement;
            };
            t2.DebuggerStatement = D;
            var S = function(e3, t3) {
              this.type = n2.Syntax.ExpressionStatement, this.expression = e3, this.directive = t3;
            };
            t2.Directive = S;
            var C = function(e3, t3) {
              this.type = n2.Syntax.DoWhileStatement, this.body = e3, this.test = t3;
            };
            t2.DoWhileStatement = C;
            var A = function() {
              this.type = n2.Syntax.EmptyStatement;
            };
            t2.EmptyStatement = A;
            var N = function(e3) {
              this.type = n2.Syntax.ExportAllDeclaration, this.source = e3;
            };
            t2.ExportAllDeclaration = N;
            var T = function(e3) {
              this.type = n2.Syntax.ExportDefaultDeclaration, this.declaration = e3;
            };
            t2.ExportDefaultDeclaration = T;
            var O = function(e3, t3, r3) {
              this.type = n2.Syntax.ExportNamedDeclaration, this.declaration = e3, this.specifiers = t3, this.source = r3;
            };
            t2.ExportNamedDeclaration = O;
            var F = function(e3, t3) {
              this.type = n2.Syntax.ExportSpecifier, this.exported = t3, this.local = e3;
            };
            t2.ExportSpecifier = F;
            var k = function(e3) {
              this.type = n2.Syntax.ExpressionStatement, this.expression = e3;
            };
            t2.ExpressionStatement = k;
            var P = function(e3, t3, r3) {
              this.type = n2.Syntax.ForInStatement, this.left = e3, this.right = t3, this.body = r3, this.each = false;
            };
            t2.ForInStatement = P;
            var I = function(e3, t3, r3) {
              this.type = n2.Syntax.ForOfStatement, this.left = e3, this.right = t3, this.body = r3;
            };
            t2.ForOfStatement = I;
            var L = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.ForStatement, this.init = e3, this.test = t3, this.update = r3, this.body = i2;
            };
            t2.ForStatement = L;
            var M = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.FunctionDeclaration, this.id = e3, this.params = t3, this.body = r3, this.generator = i2, this.expression = false, this.async = false;
            };
            t2.FunctionDeclaration = M;
            var B = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.FunctionExpression, this.id = e3, this.params = t3, this.body = r3, this.generator = i2, this.expression = false, this.async = false;
            };
            t2.FunctionExpression = B;
            var j = function(e3) {
              this.type = n2.Syntax.Identifier, this.name = e3;
            };
            t2.Identifier = j;
            var R = function(e3, t3, r3) {
              this.type = n2.Syntax.IfStatement, this.test = e3, this.consequent = t3, this.alternate = r3;
            };
            t2.IfStatement = R;
            var z = function(e3, t3) {
              this.type = n2.Syntax.ImportDeclaration, this.specifiers = e3, this.source = t3;
            };
            t2.ImportDeclaration = z;
            var U = function(e3) {
              this.type = n2.Syntax.ImportDefaultSpecifier, this.local = e3;
            };
            t2.ImportDefaultSpecifier = U;
            var G = function(e3) {
              this.type = n2.Syntax.ImportNamespaceSpecifier, this.local = e3;
            };
            t2.ImportNamespaceSpecifier = G;
            var X = function(e3, t3) {
              this.type = n2.Syntax.ImportSpecifier, this.local = e3, this.imported = t3;
            };
            t2.ImportSpecifier = X;
            var q = function(e3, t3) {
              this.type = n2.Syntax.LabeledStatement, this.label = e3, this.body = t3;
            };
            t2.LabeledStatement = q;
            var W = function(e3, t3) {
              this.type = n2.Syntax.Literal, this.value = e3, this.raw = t3;
            };
            t2.Literal = W;
            var H = function(e3, t3) {
              this.type = n2.Syntax.MetaProperty, this.meta = e3, this.property = t3;
            };
            t2.MetaProperty = H;
            var J = function(e3, t3, r3, i2, o2) {
              this.type = n2.Syntax.MethodDefinition, this.key = e3, this.computed = t3, this.value = r3, this.kind = i2, this.static = o2;
            };
            t2.MethodDefinition = J;
            var Y = function(e3) {
              this.type = n2.Syntax.Program, this.body = e3, this.sourceType = "module";
            };
            t2.Module = Y;
            var V = function(e3, t3) {
              this.type = n2.Syntax.NewExpression, this.callee = e3, this.arguments = t3;
            };
            t2.NewExpression = V;
            var K = function(e3) {
              this.type = n2.Syntax.ObjectExpression, this.properties = e3;
            };
            t2.ObjectExpression = K;
            var $ = function(e3) {
              this.type = n2.Syntax.ObjectPattern, this.properties = e3;
            };
            t2.ObjectPattern = $;
            var Q = function(e3, t3, r3, i2, o2, a2) {
              this.type = n2.Syntax.Property, this.key = t3, this.computed = r3, this.value = i2, this.kind = e3, this.method = o2, this.shorthand = a2;
            };
            t2.Property = Q;
            var Z = function(e3, t3, r3, i2) {
              this.type = n2.Syntax.Literal, this.value = e3, this.raw = t3, this.regex = { pattern: r3, flags: i2 };
            };
            t2.RegexLiteral = Z;
            var ee = function(e3) {
              this.type = n2.Syntax.RestElement, this.argument = e3;
            };
            t2.RestElement = ee;
            var te = function(e3) {
              this.type = n2.Syntax.ReturnStatement, this.argument = e3;
            };
            t2.ReturnStatement = te;
            var re = function(e3) {
              this.type = n2.Syntax.Program, this.body = e3, this.sourceType = "script";
            };
            t2.Script = re;
            var ne = function(e3) {
              this.type = n2.Syntax.SequenceExpression, this.expressions = e3;
            };
            t2.SequenceExpression = ne;
            var ie = function(e3) {
              this.type = n2.Syntax.SpreadElement, this.argument = e3;
            };
            t2.SpreadElement = ie;
            var oe = function(e3, t3) {
              this.type = n2.Syntax.MemberExpression, this.computed = false, this.object = e3, this.property = t3;
            };
            t2.StaticMemberExpression = oe;
            var ae = function() {
              this.type = n2.Syntax.Super;
            };
            t2.Super = ae;
            var se = function(e3, t3) {
              this.type = n2.Syntax.SwitchCase, this.test = e3, this.consequent = t3;
            };
            t2.SwitchCase = se;
            var ue = function(e3, t3) {
              this.type = n2.Syntax.SwitchStatement, this.discriminant = e3, this.cases = t3;
            };
            t2.SwitchStatement = ue;
            var le = function(e3, t3) {
              this.type = n2.Syntax.TaggedTemplateExpression, this.tag = e3, this.quasi = t3;
            };
            t2.TaggedTemplateExpression = le;
            var ce = function(e3, t3) {
              this.type = n2.Syntax.TemplateElement, this.value = e3, this.tail = t3;
            };
            t2.TemplateElement = ce;
            var he = function(e3, t3) {
              this.type = n2.Syntax.TemplateLiteral, this.quasis = e3, this.expressions = t3;
            };
            t2.TemplateLiteral = he;
            var pe = function() {
              this.type = n2.Syntax.ThisExpression;
            };
            t2.ThisExpression = pe;
            var fe = function(e3) {
              this.type = n2.Syntax.ThrowStatement, this.argument = e3;
            };
            t2.ThrowStatement = fe;
            var de = function(e3, t3, r3) {
              this.type = n2.Syntax.TryStatement, this.block = e3, this.handler = t3, this.finalizer = r3;
            };
            t2.TryStatement = de;
            var me = function(e3, t3) {
              this.type = n2.Syntax.UnaryExpression, this.operator = e3, this.argument = t3, this.prefix = true;
            };
            t2.UnaryExpression = me;
            var ye = function(e3, t3, r3) {
              this.type = n2.Syntax.UpdateExpression, this.operator = e3, this.argument = t3, this.prefix = r3;
            };
            t2.UpdateExpression = ye;
            var ve = function(e3, t3) {
              this.type = n2.Syntax.VariableDeclaration, this.declarations = e3, this.kind = t3;
            };
            t2.VariableDeclaration = ve;
            var _e = function(e3, t3) {
              this.type = n2.Syntax.VariableDeclarator, this.id = e3, this.init = t3;
            };
            t2.VariableDeclarator = _e;
            var ge = function(e3, t3) {
              this.type = n2.Syntax.WhileStatement, this.test = e3, this.body = t3;
            };
            t2.WhileStatement = ge;
            var be = function(e3, t3) {
              this.type = n2.Syntax.WithStatement, this.object = e3, this.body = t3;
            };
            t2.WithStatement = be;
            var xe = function(e3, t3) {
              this.type = n2.Syntax.YieldExpression, this.argument = e3, this.delegate = t3;
            };
            t2.YieldExpression = xe;
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(9), i = r2(10), o = r2(11), a = r2(7), s = r2(12), u = r2(2), l = r2(13), c = function() {
              function e3(e4, t3, r3) {
                void 0 === t3 && (t3 = {}), this.config = { range: "boolean" == typeof t3.range && t3.range, loc: "boolean" == typeof t3.loc && t3.loc, source: null, tokens: "boolean" == typeof t3.tokens && t3.tokens, comment: "boolean" == typeof t3.comment && t3.comment, tolerant: "boolean" == typeof t3.tolerant && t3.tolerant }, this.config.loc && t3.source && null !== t3.source && (this.config.source = String(t3.source)), this.delegate = r3, this.errorHandler = new i.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new s.Scanner(e4, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = { ")": 0, ";": 0, ",": 0, "=": 0, "]": 0, "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 11, "/": 11, "%": 11 }, this.lookahead = { type: 2, value: "", lineNumber: this.scanner.lineNumber, lineStart: 0, start: 0, end: 0 }, this.hasLineTerminator = false, this.context = { isModule: false, await: false, allowIn: true, allowStrictDirective: true, allowYield: true, firstCoverInitializedNameError: null, isAssignmentTarget: false, isBindingElement: false, inFunctionBody: false, inIteration: false, inSwitch: false, labelSet: {}, strict: false }, this.tokens = [], this.startMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.lastMarker = { index: 0, line: this.scanner.lineNumber, column: 0 }, this.nextToken(), this.lastMarker = { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart };
              }
              return e3.prototype.throwError = function(e4) {
                for (var t3 = [], r3 = 1; r3 < arguments.length; r3++)
                  t3[r3 - 1] = arguments[r3];
                var i2 = Array.prototype.slice.call(arguments, 1), o2 = e4.replace(/%(\d)/g, function(e5, t4) {
                  return n2.assert(t4 < i2.length, "Message reference must be in range"), i2[t4];
                }), a2 = this.lastMarker.index, s2 = this.lastMarker.line, u2 = this.lastMarker.column + 1;
                throw this.errorHandler.createError(a2, s2, u2, o2);
              }, e3.prototype.tolerateError = function(e4) {
                for (var t3 = [], r3 = 1; r3 < arguments.length; r3++)
                  t3[r3 - 1] = arguments[r3];
                var i2 = Array.prototype.slice.call(arguments, 1), o2 = e4.replace(/%(\d)/g, function(e5, t4) {
                  return n2.assert(t4 < i2.length, "Message reference must be in range"), i2[t4];
                }), a2 = this.lastMarker.index, s2 = this.scanner.lineNumber, u2 = this.lastMarker.column + 1;
                this.errorHandler.tolerateError(a2, s2, u2, o2);
              }, e3.prototype.unexpectedTokenError = function(e4, t3) {
                var r3, n3 = t3 || o.Messages.UnexpectedToken;
                if (e4 ? (t3 || (n3 = 2 === e4.type ? o.Messages.UnexpectedEOS : 3 === e4.type ? o.Messages.UnexpectedIdentifier : 6 === e4.type ? o.Messages.UnexpectedNumber : 8 === e4.type ? o.Messages.UnexpectedString : 10 === e4.type ? o.Messages.UnexpectedTemplate : o.Messages.UnexpectedToken, 4 === e4.type && (this.scanner.isFutureReservedWord(e4.value) ? n3 = o.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(e4.value) && (n3 = o.Messages.StrictReservedWord))), r3 = e4.value) : r3 = "ILLEGAL", n3 = n3.replace("%0", r3), e4 && "number" == typeof e4.lineNumber) {
                  var i2 = e4.start, a2 = e4.lineNumber, s2 = this.lastMarker.index - this.lastMarker.column, u2 = e4.start - s2 + 1;
                  return this.errorHandler.createError(i2, a2, u2, n3);
                }
                return i2 = this.lastMarker.index, a2 = this.lastMarker.line, u2 = this.lastMarker.column + 1, this.errorHandler.createError(i2, a2, u2, n3);
              }, e3.prototype.throwUnexpectedToken = function(e4, t3) {
                throw this.unexpectedTokenError(e4, t3);
              }, e3.prototype.tolerateUnexpectedToken = function(e4, t3) {
                this.errorHandler.tolerate(this.unexpectedTokenError(e4, t3));
              }, e3.prototype.collectComments = function() {
                if (this.config.comment) {
                  var e4 = this.scanner.scanComments();
                  if (e4.length > 0 && this.delegate)
                    for (var t3 = 0; t3 < e4.length; ++t3) {
                      var r3 = e4[t3], n3 = void 0;
                      n3 = { type: r3.multiLine ? "BlockComment" : "LineComment", value: this.scanner.source.slice(r3.slice[0], r3.slice[1]) }, this.config.range && (n3.range = r3.range), this.config.loc && (n3.loc = r3.loc);
                      var i2 = { start: { line: r3.loc.start.line, column: r3.loc.start.column, offset: r3.range[0] }, end: { line: r3.loc.end.line, column: r3.loc.end.column, offset: r3.range[1] } };
                      this.delegate(n3, i2);
                    }
                } else
                  this.scanner.scanComments();
              }, e3.prototype.getTokenRaw = function(e4) {
                return this.scanner.source.slice(e4.start, e4.end);
              }, e3.prototype.convertToken = function(e4) {
                var t3 = { type: l.TokenName[e4.type], value: this.getTokenRaw(e4) };
                if (this.config.range && (t3.range = [e4.start, e4.end]), this.config.loc && (t3.loc = { start: { line: this.startMarker.line, column: this.startMarker.column }, end: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }), 9 === e4.type) {
                  var r3 = e4.pattern, n3 = e4.flags;
                  t3.regex = { pattern: r3, flags: n3 };
                }
                return t3;
              }, e3.prototype.nextToken = function() {
                var e4 = this.lookahead;
                this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart);
                var t3 = this.scanner.lex();
                return this.hasLineTerminator = e4.lineNumber !== t3.lineNumber, t3 && this.context.strict && 3 === t3.type && this.scanner.isStrictModeReservedWord(t3.value) && (t3.type = 4), this.lookahead = t3, this.config.tokens && 2 !== t3.type && this.tokens.push(this.convertToken(t3)), e4;
              }, e3.prototype.nextRegexToken = function() {
                this.collectComments();
                var e4 = this.scanner.scanRegExp();
                return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(e4))), this.lookahead = e4, this.nextToken(), e4;
              }, e3.prototype.createNode = function() {
                return { index: this.startMarker.index, line: this.startMarker.line, column: this.startMarker.column };
              }, e3.prototype.startNode = function(e4, t3) {
                void 0 === t3 && (t3 = 0);
                var r3 = e4.start - e4.lineStart, n3 = e4.lineNumber;
                return r3 < 0 && (r3 += t3, n3--), { index: e4.start, line: n3, column: r3 };
              }, e3.prototype.finalize = function(e4, t3) {
                if (this.config.range && (t3.range = [e4.index, this.lastMarker.index]), this.config.loc && (t3.loc = { start: { line: e4.line, column: e4.column }, end: { line: this.lastMarker.line, column: this.lastMarker.column } }, this.config.source && (t3.loc.source = this.config.source)), this.delegate) {
                  var r3 = { start: { line: e4.line, column: e4.column, offset: e4.index }, end: { line: this.lastMarker.line, column: this.lastMarker.column, offset: this.lastMarker.index } };
                  this.delegate(t3, r3);
                }
                return t3;
              }, e3.prototype.expect = function(e4) {
                var t3 = this.nextToken();
                7 === t3.type && t3.value === e4 || this.throwUnexpectedToken(t3);
              }, e3.prototype.expectCommaSeparator = function() {
                if (this.config.tolerant) {
                  var e4 = this.lookahead;
                  7 === e4.type && "," === e4.value ? this.nextToken() : 7 === e4.type && ";" === e4.value ? (this.nextToken(), this.tolerateUnexpectedToken(e4)) : this.tolerateUnexpectedToken(e4, o.Messages.UnexpectedToken);
                } else
                  this.expect(",");
              }, e3.prototype.expectKeyword = function(e4) {
                var t3 = this.nextToken();
                4 === t3.type && t3.value === e4 || this.throwUnexpectedToken(t3);
              }, e3.prototype.match = function(e4) {
                return 7 === this.lookahead.type && this.lookahead.value === e4;
              }, e3.prototype.matchKeyword = function(e4) {
                return 4 === this.lookahead.type && this.lookahead.value === e4;
              }, e3.prototype.matchContextualKeyword = function(e4) {
                return 3 === this.lookahead.type && this.lookahead.value === e4;
              }, e3.prototype.matchAssign = function() {
                if (7 !== this.lookahead.type)
                  return false;
                var e4 = this.lookahead.value;
                return "=" === e4 || "*=" === e4 || "**=" === e4 || "/=" === e4 || "%=" === e4 || "+=" === e4 || "-=" === e4 || "<<=" === e4 || ">>=" === e4 || ">>>=" === e4 || "&=" === e4 || "^=" === e4 || "|=" === e4;
              }, e3.prototype.isolateCoverGrammar = function(e4) {
                var t3 = this.context.isBindingElement, r3 = this.context.isAssignmentTarget, n3 = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true, this.context.isAssignmentTarget = true, this.context.firstCoverInitializedNameError = null;
                var i2 = e4.call(this);
                return null !== this.context.firstCoverInitializedNameError && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = t3, this.context.isAssignmentTarget = r3, this.context.firstCoverInitializedNameError = n3, i2;
              }, e3.prototype.inheritCoverGrammar = function(e4) {
                var t3 = this.context.isBindingElement, r3 = this.context.isAssignmentTarget, n3 = this.context.firstCoverInitializedNameError;
                this.context.isBindingElement = true, this.context.isAssignmentTarget = true, this.context.firstCoverInitializedNameError = null;
                var i2 = e4.call(this);
                return this.context.isBindingElement = this.context.isBindingElement && t3, this.context.isAssignmentTarget = this.context.isAssignmentTarget && r3, this.context.firstCoverInitializedNameError = n3 || this.context.firstCoverInitializedNameError, i2;
              }, e3.prototype.consumeSemicolon = function() {
                this.match(";") ? this.nextToken() : this.hasLineTerminator || (2 === this.lookahead.type || this.match("}") || this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.column = this.startMarker.column);
              }, e3.prototype.parsePrimaryExpression = function() {
                var e4, t3, r3, n3 = this.createNode();
                switch (this.lookahead.type) {
                  case 3:
                    (this.context.isModule || this.context.await) && "await" === this.lookahead.value && this.tolerateUnexpectedToken(this.lookahead), e4 = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(n3, new a.Identifier(this.nextToken().value));
                    break;
                  case 6:
                  case 8:
                    this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, o.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = false, this.context.isBindingElement = false, t3 = this.nextToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.Literal(t3.value, r3));
                    break;
                  case 1:
                    this.context.isAssignmentTarget = false, this.context.isBindingElement = false, t3 = this.nextToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.Literal("true" === t3.value, r3));
                    break;
                  case 5:
                    this.context.isAssignmentTarget = false, this.context.isBindingElement = false, t3 = this.nextToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.Literal(null, r3));
                    break;
                  case 10:
                    e4 = this.parseTemplateLiteral();
                    break;
                  case 7:
                    switch (this.lookahead.value) {
                      case "(":
                        this.context.isBindingElement = false, e4 = this.inheritCoverGrammar(this.parseGroupExpression);
                        break;
                      case "[":
                        e4 = this.inheritCoverGrammar(this.parseArrayInitializer);
                        break;
                      case "{":
                        e4 = this.inheritCoverGrammar(this.parseObjectInitializer);
                        break;
                      case "/":
                      case "/=":
                        this.context.isAssignmentTarget = false, this.context.isBindingElement = false, this.scanner.index = this.startMarker.index, t3 = this.nextRegexToken(), r3 = this.getTokenRaw(t3), e4 = this.finalize(n3, new a.RegexLiteral(t3.regex, r3, t3.pattern, t3.flags));
                        break;
                      default:
                        e4 = this.throwUnexpectedToken(this.nextToken());
                    }
                    break;
                  case 4:
                    !this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? e4 = this.parseIdentifierName() : !this.context.strict && this.matchKeyword("let") ? e4 = this.finalize(n3, new a.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = false, this.context.isBindingElement = false, this.matchKeyword("function") ? e4 = this.parseFunctionExpression() : this.matchKeyword("this") ? (this.nextToken(), e4 = this.finalize(n3, new a.ThisExpression())) : e4 = this.matchKeyword("class") ? this.parseClassExpression() : this.throwUnexpectedToken(this.nextToken()));
                    break;
                  default:
                    e4 = this.throwUnexpectedToken(this.nextToken());
                }
                return e4;
              }, e3.prototype.parseSpreadElement = function() {
                var e4 = this.createNode();
                this.expect("...");
                var t3 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                return this.finalize(e4, new a.SpreadElement(t3));
              }, e3.prototype.parseArrayInitializer = function() {
                var e4 = this.createNode(), t3 = [];
                for (this.expect("["); !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), t3.push(null);
                  else if (this.match("...")) {
                    var r3 = this.parseSpreadElement();
                    this.match("]") || (this.context.isAssignmentTarget = false, this.context.isBindingElement = false, this.expect(",")), t3.push(r3);
                  } else
                    t3.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(",");
                return this.expect("]"), this.finalize(e4, new a.ArrayExpression(t3));
              }, e3.prototype.parsePropertyMethod = function(e4) {
                this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                var t3 = this.context.strict, r3 = this.context.allowStrictDirective;
                this.context.allowStrictDirective = e4.simple;
                var n3 = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                return this.context.strict && e4.firstRestricted && this.tolerateUnexpectedToken(e4.firstRestricted, e4.message), this.context.strict && e4.stricted && this.tolerateUnexpectedToken(e4.stricted, e4.message), this.context.strict = t3, this.context.allowStrictDirective = r3, n3;
              }, e3.prototype.parsePropertyMethodFunction = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters(), n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, false));
              }, e3.prototype.parsePropertyMethodAsyncFunction = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield, r3 = this.context.await;
                this.context.allowYield = false, this.context.await = true;
                var n3 = this.parseFormalParameters(), i2 = this.parsePropertyMethod(n3);
                return this.context.allowYield = t3, this.context.await = r3, this.finalize(e4, new a.AsyncFunctionExpression(null, n3.params, i2));
              }, e3.prototype.parseObjectPropertyKey = function() {
                var e4, t3 = this.createNode(), r3 = this.nextToken();
                switch (r3.type) {
                  case 8:
                  case 6:
                    this.context.strict && r3.octal && this.tolerateUnexpectedToken(r3, o.Messages.StrictOctalLiteral);
                    var n3 = this.getTokenRaw(r3);
                    e4 = this.finalize(t3, new a.Literal(r3.value, n3));
                    break;
                  case 3:
                  case 1:
                  case 5:
                  case 4:
                    e4 = this.finalize(t3, new a.Identifier(r3.value));
                    break;
                  case 7:
                    "[" === r3.value ? (e4 = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : e4 = this.throwUnexpectedToken(r3);
                    break;
                  default:
                    e4 = this.throwUnexpectedToken(r3);
                }
                return e4;
              }, e3.prototype.isPropertyKey = function(e4, t3) {
                return e4.type === u.Syntax.Identifier && e4.name === t3 || e4.type === u.Syntax.Literal && e4.value === t3;
              }, e3.prototype.parseObjectProperty = function(e4) {
                var t3, r3 = this.createNode(), n3 = this.lookahead, i2 = null, s2 = null, u2 = false, l2 = false, c2 = false, h = false;
                if (3 === n3.type) {
                  var p = n3.value;
                  this.nextToken(), u2 = this.match("["), i2 = (h = !(this.hasLineTerminator || "async" !== p || this.match(":") || this.match("(") || this.match("*") || this.match(","))) ? this.parseObjectPropertyKey() : this.finalize(r3, new a.Identifier(p));
                } else
                  this.match("*") ? this.nextToken() : (u2 = this.match("["), i2 = this.parseObjectPropertyKey());
                var f = this.qualifiedPropertyName(this.lookahead);
                if (3 === n3.type && !h && "get" === n3.value && f)
                  t3 = "get", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), this.context.allowYield = false, s2 = this.parseGetterMethod();
                else if (3 === n3.type && !h && "set" === n3.value && f)
                  t3 = "set", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseSetterMethod();
                else if (7 === n3.type && "*" === n3.value && f)
                  t3 = "init", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseGeneratorMethod(), l2 = true;
                else if (i2 || this.throwUnexpectedToken(this.lookahead), t3 = "init", this.match(":") && !h)
                  !u2 && this.isPropertyKey(i2, "__proto__") && (e4.value && this.tolerateError(o.Messages.DuplicateProtoProperty), e4.value = true), this.nextToken(), s2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                else if (this.match("("))
                  s2 = h ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), l2 = true;
                else if (3 === n3.type)
                  if (p = this.finalize(r3, new a.Identifier(n3.value)), this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), c2 = true;
                    var d = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    s2 = this.finalize(r3, new a.AssignmentPattern(p, d));
                  } else
                    c2 = true, s2 = p;
                else
                  this.throwUnexpectedToken(this.nextToken());
                return this.finalize(r3, new a.Property(t3, i2, u2, s2, l2, c2));
              }, e3.prototype.parseObjectInitializer = function() {
                var e4 = this.createNode();
                this.expect("{");
                for (var t3 = [], r3 = { value: false }; !this.match("}"); )
                  t3.push(this.parseObjectProperty(r3)), this.match("}") || this.expectCommaSeparator();
                return this.expect("}"), this.finalize(e4, new a.ObjectExpression(t3));
              }, e3.prototype.parseTemplateHead = function() {
                n2.assert(this.lookahead.head, "Template literal must start with a template head");
                var e4 = this.createNode(), t3 = this.nextToken(), r3 = t3.value, i2 = t3.cooked;
                return this.finalize(e4, new a.TemplateElement({ raw: r3, cooked: i2 }, t3.tail));
              }, e3.prototype.parseTemplateElement = function() {
                10 !== this.lookahead.type && this.throwUnexpectedToken();
                var e4 = this.createNode(), t3 = this.nextToken(), r3 = t3.value, n3 = t3.cooked;
                return this.finalize(e4, new a.TemplateElement({ raw: r3, cooked: n3 }, t3.tail));
              }, e3.prototype.parseTemplateLiteral = function() {
                var e4 = this.createNode(), t3 = [], r3 = [], n3 = this.parseTemplateHead();
                for (r3.push(n3); !n3.tail; )
                  t3.push(this.parseExpression()), n3 = this.parseTemplateElement(), r3.push(n3);
                return this.finalize(e4, new a.TemplateLiteral(r3, t3));
              }, e3.prototype.reinterpretExpressionAsPattern = function(e4) {
                switch (e4.type) {
                  case u.Syntax.Identifier:
                  case u.Syntax.MemberExpression:
                  case u.Syntax.RestElement:
                  case u.Syntax.AssignmentPattern:
                    break;
                  case u.Syntax.SpreadElement:
                    e4.type = u.Syntax.RestElement, this.reinterpretExpressionAsPattern(e4.argument);
                    break;
                  case u.Syntax.ArrayExpression:
                    e4.type = u.Syntax.ArrayPattern;
                    for (var t3 = 0; t3 < e4.elements.length; t3++)
                      null !== e4.elements[t3] && this.reinterpretExpressionAsPattern(e4.elements[t3]);
                    break;
                  case u.Syntax.ObjectExpression:
                    for (e4.type = u.Syntax.ObjectPattern, t3 = 0; t3 < e4.properties.length; t3++)
                      this.reinterpretExpressionAsPattern(e4.properties[t3].value);
                    break;
                  case u.Syntax.AssignmentExpression:
                    e4.type = u.Syntax.AssignmentPattern, delete e4.operator, this.reinterpretExpressionAsPattern(e4.left);
                }
              }, e3.prototype.parseGroupExpression = function() {
                var e4;
                if (this.expect("("), this.match(")"))
                  this.nextToken(), this.match("=>") || this.expect("=>"), e4 = { type: "ArrowParameterPlaceHolder", params: [], async: false };
                else {
                  var t3 = this.lookahead, r3 = [];
                  if (this.match("..."))
                    e4 = this.parseRestElement(r3), this.expect(")"), this.match("=>") || this.expect("=>"), e4 = { type: "ArrowParameterPlaceHolder", params: [e4], async: false };
                  else {
                    var n3 = false;
                    if (this.context.isBindingElement = true, e4 = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) {
                      var i2 = [];
                      for (this.context.isAssignmentTarget = false, i2.push(e4); 2 !== this.lookahead.type && this.match(","); ) {
                        if (this.nextToken(), this.match(")")) {
                          this.nextToken();
                          for (var o2 = 0; o2 < i2.length; o2++)
                            this.reinterpretExpressionAsPattern(i2[o2]);
                          n3 = true, e4 = { type: "ArrowParameterPlaceHolder", params: i2, async: false };
                        } else if (this.match("...")) {
                          for (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), i2.push(this.parseRestElement(r3)), this.expect(")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = false, o2 = 0; o2 < i2.length; o2++)
                            this.reinterpretExpressionAsPattern(i2[o2]);
                          n3 = true, e4 = { type: "ArrowParameterPlaceHolder", params: i2, async: false };
                        } else
                          i2.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                        if (n3)
                          break;
                      }
                      n3 || (e4 = this.finalize(this.startNode(t3), new a.SequenceExpression(i2)));
                    }
                    if (!n3) {
                      if (this.expect(")"), this.match("=>") && (e4.type === u.Syntax.Identifier && "yield" === e4.name && (n3 = true, e4 = { type: "ArrowParameterPlaceHolder", params: [e4], async: false }), !n3)) {
                        if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), e4.type === u.Syntax.SequenceExpression)
                          for (o2 = 0; o2 < e4.expressions.length; o2++)
                            this.reinterpretExpressionAsPattern(e4.expressions[o2]);
                        else
                          this.reinterpretExpressionAsPattern(e4);
                        e4 = { type: "ArrowParameterPlaceHolder", params: e4.type === u.Syntax.SequenceExpression ? e4.expressions : [e4], async: false };
                      }
                      this.context.isBindingElement = false;
                    }
                  }
                }
                return e4;
              }, e3.prototype.parseArguments = function() {
                this.expect("(");
                var e4 = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var t3 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (e4.push(t3), this.match(")"))
                      break;
                    if (this.expectCommaSeparator(), this.match(")"))
                      break;
                  }
                return this.expect(")"), e4;
              }, e3.prototype.isIdentifierName = function(e4) {
                return 3 === e4.type || 4 === e4.type || 1 === e4.type || 5 === e4.type;
              }, e3.prototype.parseIdentifierName = function() {
                var e4 = this.createNode(), t3 = this.nextToken();
                return this.isIdentifierName(t3) || this.throwUnexpectedToken(t3), this.finalize(e4, new a.Identifier(t3.value));
              }, e3.prototype.parseNewExpression = function() {
                var e4, t3 = this.createNode(), r3 = this.parseIdentifierName();
                if (n2.assert("new" === r3.name, "New expression must start with `new`"), this.match("."))
                  if (this.nextToken(), 3 === this.lookahead.type && this.context.inFunctionBody && "target" === this.lookahead.value) {
                    var i2 = this.parseIdentifierName();
                    e4 = new a.MetaProperty(r3, i2);
                  } else
                    this.throwUnexpectedToken(this.lookahead);
                else {
                  var o2 = this.isolateCoverGrammar(this.parseLeftHandSideExpression), s2 = this.match("(") ? this.parseArguments() : [];
                  e4 = new a.NewExpression(o2, s2), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                }
                return this.finalize(t3, e4);
              }, e3.prototype.parseAsyncArgument = function() {
                var e4 = this.parseAssignmentExpression();
                return this.context.firstCoverInitializedNameError = null, e4;
              }, e3.prototype.parseAsyncArguments = function() {
                this.expect("(");
                var e4 = [];
                if (!this.match(")"))
                  for (; ; ) {
                    var t3 = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                    if (e4.push(t3), this.match(")"))
                      break;
                    if (this.expectCommaSeparator(), this.match(")"))
                      break;
                  }
                return this.expect(")"), e4;
              }, e3.prototype.parseLeftHandSideExpressionAllowCall = function() {
                var e4, t3 = this.lookahead, r3 = this.matchContextualKeyword("async"), n3 = this.context.allowIn;
                for (this.context.allowIn = true, this.matchKeyword("super") && this.context.inFunctionBody ? (e4 = this.createNode(), this.nextToken(), e4 = this.finalize(e4, new a.Super()), this.match("(") || this.match(".") || this.match("[") || this.throwUnexpectedToken(this.lookahead)) : e4 = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match(".")) {
                    this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect(".");
                    var i2 = this.parseIdentifierName();
                    e4 = this.finalize(this.startNode(t3), new a.StaticMemberExpression(e4, i2));
                  } else if (this.match("(")) {
                    var o2 = r3 && t3.lineNumber === this.lookahead.lineNumber;
                    this.context.isBindingElement = false, this.context.isAssignmentTarget = false;
                    var s2 = o2 ? this.parseAsyncArguments() : this.parseArguments();
                    if (e4 = this.finalize(this.startNode(t3), new a.CallExpression(e4, s2)), o2 && this.match("=>")) {
                      for (var u2 = 0; u2 < s2.length; ++u2)
                        this.reinterpretExpressionAsPattern(s2[u2]);
                      e4 = { type: "ArrowParameterPlaceHolder", params: s2, async: true };
                    }
                  } else if (this.match("["))
                    this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("["), i2 = this.isolateCoverGrammar(this.parseExpression), this.expect("]"), e4 = this.finalize(this.startNode(t3), new a.ComputedMemberExpression(e4, i2));
                  else {
                    if (10 !== this.lookahead.type || !this.lookahead.head)
                      break;
                    var l2 = this.parseTemplateLiteral();
                    e4 = this.finalize(this.startNode(t3), new a.TaggedTemplateExpression(e4, l2));
                  }
                return this.context.allowIn = n3, e4;
              }, e3.prototype.parseSuper = function() {
                var e4 = this.createNode();
                return this.expectKeyword("super"), this.match("[") || this.match(".") || this.throwUnexpectedToken(this.lookahead), this.finalize(e4, new a.Super());
              }, e3.prototype.parseLeftHandSideExpression = function() {
                n2.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                for (var e4 = this.startNode(this.lookahead), t3 = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                  if (this.match("[")) {
                    this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("[");
                    var r3 = this.isolateCoverGrammar(this.parseExpression);
                    this.expect("]"), t3 = this.finalize(e4, new a.ComputedMemberExpression(t3, r3));
                  } else if (this.match("."))
                    this.context.isBindingElement = false, this.context.isAssignmentTarget = true, this.expect("."), r3 = this.parseIdentifierName(), t3 = this.finalize(e4, new a.StaticMemberExpression(t3, r3));
                  else {
                    if (10 !== this.lookahead.type || !this.lookahead.head)
                      break;
                    var i2 = this.parseTemplateLiteral();
                    t3 = this.finalize(e4, new a.TaggedTemplateExpression(t3, i2));
                  }
                return t3;
              }, e3.prototype.parseUpdateExpression = function() {
                var e4, t3 = this.lookahead;
                if (this.match("++") || this.match("--")) {
                  var r3 = this.startNode(t3), n3 = this.nextToken();
                  e4 = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && e4.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(e4.name) && this.tolerateError(o.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(o.Messages.InvalidLHSInAssignment);
                  var i2 = true;
                  e4 = this.finalize(r3, new a.UpdateExpression(n3.value, e4, i2)), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                } else if (e4 = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && 7 === this.lookahead.type && (this.match("++") || this.match("--"))) {
                  this.context.strict && e4.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(e4.name) && this.tolerateError(o.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(o.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                  var s2 = this.nextToken().value;
                  i2 = false, e4 = this.finalize(this.startNode(t3), new a.UpdateExpression(s2, e4, i2));
                }
                return e4;
              }, e3.prototype.parseAwaitExpression = function() {
                var e4 = this.createNode();
                this.nextToken();
                var t3 = this.parseUnaryExpression();
                return this.finalize(e4, new a.AwaitExpression(t3));
              }, e3.prototype.parseUnaryExpression = function() {
                var e4;
                if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                  var t3 = this.startNode(this.lookahead), r3 = this.nextToken();
                  e4 = this.inheritCoverGrammar(this.parseUnaryExpression), e4 = this.finalize(t3, new a.UnaryExpression(r3.value, e4)), this.context.strict && "delete" === e4.operator && e4.argument.type === u.Syntax.Identifier && this.tolerateError(o.Messages.StrictDelete), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                } else
                  e4 = this.context.await && this.matchContextualKeyword("await") ? this.parseAwaitExpression() : this.parseUpdateExpression();
                return e4;
              }, e3.prototype.parseExponentiationExpression = function() {
                var e4 = this.lookahead, t3 = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (t3.type !== u.Syntax.UnaryExpression && this.match("**")) {
                  this.nextToken(), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                  var r3 = t3, n3 = this.isolateCoverGrammar(this.parseExponentiationExpression);
                  t3 = this.finalize(this.startNode(e4), new a.BinaryExpression("**", r3, n3));
                }
                return t3;
              }, e3.prototype.binaryPrecedence = function(e4) {
                var t3 = e4.value;
                return 7 === e4.type ? this.operatorPrecedence[t3] || 0 : 4 === e4.type && ("instanceof" === t3 || this.context.allowIn && "in" === t3) ? 7 : 0;
              }, e3.prototype.parseBinaryExpression = function() {
                var e4 = this.lookahead, t3 = this.inheritCoverGrammar(this.parseExponentiationExpression), r3 = this.lookahead, n3 = this.binaryPrecedence(r3);
                if (n3 > 0) {
                  this.nextToken(), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                  for (var i2 = [e4, this.lookahead], o2 = t3, s2 = this.isolateCoverGrammar(this.parseExponentiationExpression), u2 = [o2, r3.value, s2], l2 = [n3]; !((n3 = this.binaryPrecedence(this.lookahead)) <= 0); ) {
                    for (; u2.length > 2 && n3 <= l2[l2.length - 1]; ) {
                      s2 = u2.pop();
                      var c2 = u2.pop();
                      l2.pop(), o2 = u2.pop(), i2.pop();
                      var h = this.startNode(i2[i2.length - 1]);
                      u2.push(this.finalize(h, new a.BinaryExpression(c2, o2, s2)));
                    }
                    u2.push(this.nextToken().value), l2.push(n3), i2.push(this.lookahead), u2.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                  }
                  var p = u2.length - 1;
                  t3 = u2[p];
                  for (var f = i2.pop(); p > 1; ) {
                    var d = i2.pop(), m = f && f.lineStart;
                    h = this.startNode(d, m), c2 = u2[p - 1], t3 = this.finalize(h, new a.BinaryExpression(c2, u2[p - 2], t3)), p -= 2, f = d;
                  }
                }
                return t3;
              }, e3.prototype.parseConditionalExpression = function() {
                var e4 = this.lookahead, t3 = this.inheritCoverGrammar(this.parseBinaryExpression);
                if (this.match("?")) {
                  this.nextToken();
                  var r3 = this.context.allowIn;
                  this.context.allowIn = true;
                  var n3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = r3, this.expect(":");
                  var i2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  t3 = this.finalize(this.startNode(e4), new a.ConditionalExpression(t3, n3, i2)), this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                }
                return t3;
              }, e3.prototype.checkPatternParam = function(e4, t3) {
                switch (t3.type) {
                  case u.Syntax.Identifier:
                    this.validateParam(e4, t3, t3.name);
                    break;
                  case u.Syntax.RestElement:
                    this.checkPatternParam(e4, t3.argument);
                    break;
                  case u.Syntax.AssignmentPattern:
                    this.checkPatternParam(e4, t3.left);
                    break;
                  case u.Syntax.ArrayPattern:
                    for (var r3 = 0; r3 < t3.elements.length; r3++)
                      null !== t3.elements[r3] && this.checkPatternParam(e4, t3.elements[r3]);
                    break;
                  case u.Syntax.ObjectPattern:
                    for (r3 = 0; r3 < t3.properties.length; r3++)
                      this.checkPatternParam(e4, t3.properties[r3].value);
                }
                e4.simple = e4.simple && t3 instanceof a.Identifier;
              }, e3.prototype.reinterpretAsCoverFormalsList = function(e4) {
                var t3, r3 = [e4], n3 = false;
                switch (e4.type) {
                  case u.Syntax.Identifier:
                    break;
                  case "ArrowParameterPlaceHolder":
                    r3 = e4.params, n3 = e4.async;
                    break;
                  default:
                    return null;
                }
                t3 = { simple: true, paramSet: {} };
                for (var i2 = 0; i2 < r3.length; ++i2)
                  (a2 = r3[i2]).type === u.Syntax.AssignmentPattern ? a2.right.type === u.Syntax.YieldExpression && (a2.right.argument && this.throwUnexpectedToken(this.lookahead), a2.right.type = u.Syntax.Identifier, a2.right.name = "yield", delete a2.right.argument, delete a2.right.delegate) : n3 && a2.type === u.Syntax.Identifier && "await" === a2.name && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(t3, a2), r3[i2] = a2;
                if (this.context.strict || !this.context.allowYield)
                  for (i2 = 0; i2 < r3.length; ++i2) {
                    var a2;
                    (a2 = r3[i2]).type === u.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead);
                  }
                if (t3.message === o.Messages.StrictParamDupe) {
                  var s2 = this.context.strict ? t3.stricted : t3.firstRestricted;
                  this.throwUnexpectedToken(s2, t3.message);
                }
                return { simple: t3.simple, params: r3, stricted: t3.stricted, firstRestricted: t3.firstRestricted, message: t3.message };
              }, e3.prototype.parseAssignmentExpression = function() {
                var e4;
                if (!this.context.allowYield && this.matchKeyword("yield"))
                  e4 = this.parseYieldExpression();
                else {
                  var t3 = this.lookahead, r3 = t3;
                  if (e4 = this.parseConditionalExpression(), 3 === r3.type && r3.lineNumber === this.lookahead.lineNumber && "async" === r3.value && (3 === this.lookahead.type || this.matchKeyword("yield"))) {
                    var n3 = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(n3), e4 = { type: "ArrowParameterPlaceHolder", params: [n3], async: true };
                  }
                  if ("ArrowParameterPlaceHolder" === e4.type || this.match("=>")) {
                    this.context.isAssignmentTarget = false, this.context.isBindingElement = false;
                    var i2 = e4.async, s2 = this.reinterpretAsCoverFormalsList(e4);
                    if (s2) {
                      this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null;
                      var l2 = this.context.strict, c2 = this.context.allowStrictDirective;
                      this.context.allowStrictDirective = s2.simple;
                      var h = this.context.allowYield, p = this.context.await;
                      this.context.allowYield = true, this.context.await = i2;
                      var f = this.startNode(t3);
                      this.expect("=>");
                      var d = void 0;
                      if (this.match("{")) {
                        var m = this.context.allowIn;
                        this.context.allowIn = true, d = this.parseFunctionSourceElements(), this.context.allowIn = m;
                      } else
                        d = this.isolateCoverGrammar(this.parseAssignmentExpression);
                      var y = d.type !== u.Syntax.BlockStatement;
                      this.context.strict && s2.firstRestricted && this.throwUnexpectedToken(s2.firstRestricted, s2.message), this.context.strict && s2.stricted && this.tolerateUnexpectedToken(s2.stricted, s2.message), e4 = i2 ? this.finalize(f, new a.AsyncArrowFunctionExpression(s2.params, d, y)) : this.finalize(f, new a.ArrowFunctionExpression(s2.params, d, y)), this.context.strict = l2, this.context.allowStrictDirective = c2, this.context.allowYield = h, this.context.await = p;
                    }
                  } else if (this.matchAssign()) {
                    if (this.context.isAssignmentTarget || this.tolerateError(o.Messages.InvalidLHSInAssignment), this.context.strict && e4.type === u.Syntax.Identifier) {
                      var v = e4;
                      this.scanner.isRestrictedWord(v.name) && this.tolerateUnexpectedToken(r3, o.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(v.name) && this.tolerateUnexpectedToken(r3, o.Messages.StrictReservedWord);
                    }
                    this.match("=") ? this.reinterpretExpressionAsPattern(e4) : (this.context.isAssignmentTarget = false, this.context.isBindingElement = false);
                    var _ = (r3 = this.nextToken()).value, g = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    e4 = this.finalize(this.startNode(t3), new a.AssignmentExpression(_, e4, g)), this.context.firstCoverInitializedNameError = null;
                  }
                }
                return e4;
              }, e3.prototype.parseExpression = function() {
                var e4 = this.lookahead, t3 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var r3 = [];
                  for (r3.push(t3); 2 !== this.lookahead.type && this.match(","); )
                    this.nextToken(), r3.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                  t3 = this.finalize(this.startNode(e4), new a.SequenceExpression(r3));
                }
                return t3;
              }, e3.prototype.parseStatementListItem = function() {
                var e4;
                if (this.context.isAssignmentTarget = true, this.context.isBindingElement = true, 4 === this.lookahead.type)
                  switch (this.lookahead.value) {
                    case "export":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, o.Messages.IllegalExportDeclaration), e4 = this.parseExportDeclaration();
                      break;
                    case "import":
                      this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, o.Messages.IllegalImportDeclaration), e4 = this.parseImportDeclaration();
                      break;
                    case "const":
                      e4 = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "function":
                      e4 = this.parseFunctionDeclaration();
                      break;
                    case "class":
                      e4 = this.parseClassDeclaration();
                      break;
                    case "let":
                      e4 = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                      break;
                    default:
                      e4 = this.parseStatement();
                  }
                else
                  e4 = this.parseStatement();
                return e4;
              }, e3.prototype.parseBlock = function() {
                var e4 = this.createNode();
                this.expect("{");
                for (var t3 = []; !this.match("}"); )
                  t3.push(this.parseStatementListItem());
                return this.expect("}"), this.finalize(e4, new a.BlockStatement(t3));
              }, e3.prototype.parseLexicalBinding = function(e4, t3) {
                var r3 = this.createNode(), n3 = this.parsePattern([], e4);
                this.context.strict && n3.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(n3.name) && this.tolerateError(o.Messages.StrictVarName);
                var i2 = null;
                return "const" === e4 ? this.matchKeyword("in") || this.matchContextualKeyword("of") || (this.match("=") ? (this.nextToken(), i2 = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(o.Messages.DeclarationMissingInitializer, "const")) : (!t3.inFor && n3.type !== u.Syntax.Identifier || this.match("=")) && (this.expect("="), i2 = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(r3, new a.VariableDeclarator(n3, i2));
              }, e3.prototype.parseBindingList = function(e4, t3) {
                for (var r3 = [this.parseLexicalBinding(e4, t3)]; this.match(","); )
                  this.nextToken(), r3.push(this.parseLexicalBinding(e4, t3));
                return r3;
              }, e3.prototype.isLexicalDeclaration = function() {
                var e4 = this.scanner.saveState();
                this.scanner.scanComments();
                var t3 = this.scanner.lex();
                return this.scanner.restoreState(e4), 3 === t3.type || 7 === t3.type && "[" === t3.value || 7 === t3.type && "{" === t3.value || 4 === t3.type && "let" === t3.value || 4 === t3.type && "yield" === t3.value;
              }, e3.prototype.parseLexicalDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.nextToken().value;
                n2.assert("let" === r3 || "const" === r3, "Lexical declaration must be either let or const");
                var i2 = this.parseBindingList(r3, e4);
                return this.consumeSemicolon(), this.finalize(t3, new a.VariableDeclaration(i2, r3));
              }, e3.prototype.parseBindingRestElement = function(e4, t3) {
                var r3 = this.createNode();
                this.expect("...");
                var n3 = this.parsePattern(e4, t3);
                return this.finalize(r3, new a.RestElement(n3));
              }, e3.prototype.parseArrayPattern = function(e4, t3) {
                var r3 = this.createNode();
                this.expect("[");
                for (var n3 = []; !this.match("]"); )
                  if (this.match(","))
                    this.nextToken(), n3.push(null);
                  else {
                    if (this.match("...")) {
                      n3.push(this.parseBindingRestElement(e4, t3));
                      break;
                    }
                    n3.push(this.parsePatternWithDefault(e4, t3)), this.match("]") || this.expect(",");
                  }
                return this.expect("]"), this.finalize(r3, new a.ArrayPattern(n3));
              }, e3.prototype.parsePropertyPattern = function(e4, t3) {
                var r3, n3, i2 = this.createNode(), o2 = false, s2 = false;
                if (3 === this.lookahead.type) {
                  var u2 = this.lookahead;
                  r3 = this.parseVariableIdentifier();
                  var l2 = this.finalize(i2, new a.Identifier(u2.value));
                  if (this.match("=")) {
                    e4.push(u2), s2 = true, this.nextToken();
                    var c2 = this.parseAssignmentExpression();
                    n3 = this.finalize(this.startNode(u2), new a.AssignmentPattern(l2, c2));
                  } else
                    this.match(":") ? (this.expect(":"), n3 = this.parsePatternWithDefault(e4, t3)) : (e4.push(u2), s2 = true, n3 = l2);
                } else
                  o2 = this.match("["), r3 = this.parseObjectPropertyKey(), this.expect(":"), n3 = this.parsePatternWithDefault(e4, t3);
                return this.finalize(i2, new a.Property("init", r3, o2, n3, false, s2));
              }, e3.prototype.parseObjectPattern = function(e4, t3) {
                var r3 = this.createNode(), n3 = [];
                for (this.expect("{"); !this.match("}"); )
                  n3.push(this.parsePropertyPattern(e4, t3)), this.match("}") || this.expect(",");
                return this.expect("}"), this.finalize(r3, new a.ObjectPattern(n3));
              }, e3.prototype.parsePattern = function(e4, t3) {
                var r3;
                return this.match("[") ? r3 = this.parseArrayPattern(e4, t3) : this.match("{") ? r3 = this.parseObjectPattern(e4, t3) : (!this.matchKeyword("let") || "const" !== t3 && "let" !== t3 || this.tolerateUnexpectedToken(this.lookahead, o.Messages.LetInLexicalBinding), e4.push(this.lookahead), r3 = this.parseVariableIdentifier(t3)), r3;
              }, e3.prototype.parsePatternWithDefault = function(e4, t3) {
                var r3 = this.lookahead, n3 = this.parsePattern(e4, t3);
                if (this.match("=")) {
                  this.nextToken();
                  var i2 = this.context.allowYield;
                  this.context.allowYield = true;
                  var o2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowYield = i2, n3 = this.finalize(this.startNode(r3), new a.AssignmentPattern(n3, o2));
                }
                return n3;
              }, e3.prototype.parseVariableIdentifier = function(e4) {
                var t3 = this.createNode(), r3 = this.nextToken();
                return 4 === r3.type && "yield" === r3.value ? this.context.strict ? this.tolerateUnexpectedToken(r3, o.Messages.StrictReservedWord) : this.context.allowYield || this.throwUnexpectedToken(r3) : 3 !== r3.type ? this.context.strict && 4 === r3.type && this.scanner.isStrictModeReservedWord(r3.value) ? this.tolerateUnexpectedToken(r3, o.Messages.StrictReservedWord) : (this.context.strict || "let" !== r3.value || "var" !== e4) && this.throwUnexpectedToken(r3) : (this.context.isModule || this.context.await) && 3 === r3.type && "await" === r3.value && this.tolerateUnexpectedToken(r3), this.finalize(t3, new a.Identifier(r3.value));
              }, e3.prototype.parseVariableDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.parsePattern([], "var");
                this.context.strict && r3.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(r3.name) && this.tolerateError(o.Messages.StrictVarName);
                var n3 = null;
                return this.match("=") ? (this.nextToken(), n3 = this.isolateCoverGrammar(this.parseAssignmentExpression)) : r3.type === u.Syntax.Identifier || e4.inFor || this.expect("="), this.finalize(t3, new a.VariableDeclarator(r3, n3));
              }, e3.prototype.parseVariableDeclarationList = function(e4) {
                var t3 = { inFor: e4.inFor }, r3 = [];
                for (r3.push(this.parseVariableDeclaration(t3)); this.match(","); )
                  this.nextToken(), r3.push(this.parseVariableDeclaration(t3));
                return r3;
              }, e3.prototype.parseVariableStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("var");
                var t3 = this.parseVariableDeclarationList({ inFor: false });
                return this.consumeSemicolon(), this.finalize(e4, new a.VariableDeclaration(t3, "var"));
              }, e3.prototype.parseEmptyStatement = function() {
                var e4 = this.createNode();
                return this.expect(";"), this.finalize(e4, new a.EmptyStatement());
              }, e3.prototype.parseExpressionStatement = function() {
                var e4 = this.createNode(), t3 = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(e4, new a.ExpressionStatement(t3));
              }, e3.prototype.parseIfClause = function() {
                return this.context.strict && this.matchKeyword("function") && this.tolerateError(o.Messages.StrictFunction), this.parseStatement();
              }, e3.prototype.parseIfStatement = function() {
                var e4, t3 = this.createNode(), r3 = null;
                this.expectKeyword("if"), this.expect("(");
                var n3 = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), e4 = this.finalize(this.createNode(), new a.EmptyStatement())) : (this.expect(")"), e4 = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), r3 = this.parseIfClause())), this.finalize(t3, new a.IfStatement(n3, e4, r3));
              }, e3.prototype.parseDoWhileStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("do");
                var t3 = this.context.inIteration;
                this.context.inIteration = true;
                var r3 = this.parseStatement();
                this.context.inIteration = t3, this.expectKeyword("while"), this.expect("(");
                var n3 = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(")"), this.match(";") && this.nextToken()), this.finalize(e4, new a.DoWhileStatement(r3, n3));
              }, e3.prototype.parseWhileStatement = function() {
                var e4, t3 = this.createNode();
                this.expectKeyword("while"), this.expect("(");
                var r3 = this.parseExpression();
                if (!this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), e4 = this.finalize(this.createNode(), new a.EmptyStatement());
                else {
                  this.expect(")");
                  var n3 = this.context.inIteration;
                  this.context.inIteration = true, e4 = this.parseStatement(), this.context.inIteration = n3;
                }
                return this.finalize(t3, new a.WhileStatement(r3, e4));
              }, e3.prototype.parseForStatement = function() {
                var e4, t3, r3, n3 = null, i2 = null, s2 = null, l2 = true, c2 = this.createNode();
                if (this.expectKeyword("for"), this.expect("("), this.match(";"))
                  this.nextToken();
                else if (this.matchKeyword("var")) {
                  n3 = this.createNode(), this.nextToken();
                  var h = this.context.allowIn;
                  this.context.allowIn = false;
                  var p = this.parseVariableDeclarationList({ inFor: true });
                  if (this.context.allowIn = h, 1 === p.length && this.matchKeyword("in")) {
                    var f = p[0];
                    f.init && (f.id.type === u.Syntax.ArrayPattern || f.id.type === u.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(o.Messages.ForInOfLoopInitializer, "for-in"), n3 = this.finalize(n3, new a.VariableDeclaration(p, "var")), this.nextToken(), e4 = n3, t3 = this.parseExpression(), n3 = null;
                  } else
                    1 === p.length && null === p[0].init && this.matchContextualKeyword("of") ? (n3 = this.finalize(n3, new a.VariableDeclaration(p, "var")), this.nextToken(), e4 = n3, t3 = this.parseAssignmentExpression(), n3 = null, l2 = false) : (n3 = this.finalize(n3, new a.VariableDeclaration(p, "var")), this.expect(";"));
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  n3 = this.createNode();
                  var d = this.nextToken().value;
                  this.context.strict || "in" !== this.lookahead.value ? (h = this.context.allowIn, this.context.allowIn = false, p = this.parseBindingList(d, { inFor: true }), this.context.allowIn = h, 1 === p.length && null === p[0].init && this.matchKeyword("in") ? (n3 = this.finalize(n3, new a.VariableDeclaration(p, d)), this.nextToken(), e4 = n3, t3 = this.parseExpression(), n3 = null) : 1 === p.length && null === p[0].init && this.matchContextualKeyword("of") ? (n3 = this.finalize(n3, new a.VariableDeclaration(p, d)), this.nextToken(), e4 = n3, t3 = this.parseAssignmentExpression(), n3 = null, l2 = false) : (this.consumeSemicolon(), n3 = this.finalize(n3, new a.VariableDeclaration(p, d)))) : (n3 = this.finalize(n3, new a.Identifier(d)), this.nextToken(), e4 = n3, t3 = this.parseExpression(), n3 = null);
                } else {
                  var m = this.lookahead;
                  if (h = this.context.allowIn, this.context.allowIn = false, n3 = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = h, this.matchKeyword("in"))
                    this.context.isAssignmentTarget && n3.type !== u.Syntax.AssignmentExpression || this.tolerateError(o.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(n3), e4 = n3, t3 = this.parseExpression(), n3 = null;
                  else if (this.matchContextualKeyword("of"))
                    this.context.isAssignmentTarget && n3.type !== u.Syntax.AssignmentExpression || this.tolerateError(o.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(n3), e4 = n3, t3 = this.parseAssignmentExpression(), n3 = null, l2 = false;
                  else {
                    if (this.match(",")) {
                      for (var y = [n3]; this.match(","); )
                        this.nextToken(), y.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      n3 = this.finalize(this.startNode(m), new a.SequenceExpression(y));
                    }
                    this.expect(";");
                  }
                }
                if (void 0 === e4 && (this.match(";") || (i2 = this.parseExpression()), this.expect(";"), this.match(")") || (s2 = this.parseExpression())), !this.match(")") && this.config.tolerant)
                  this.tolerateUnexpectedToken(this.nextToken()), r3 = this.finalize(this.createNode(), new a.EmptyStatement());
                else {
                  this.expect(")");
                  var v = this.context.inIteration;
                  this.context.inIteration = true, r3 = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = v;
                }
                return void 0 === e4 ? this.finalize(c2, new a.ForStatement(n3, i2, s2, r3)) : l2 ? this.finalize(c2, new a.ForInStatement(e4, t3, r3)) : this.finalize(c2, new a.ForOfStatement(e4, t3, r3));
              }, e3.prototype.parseContinueStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("continue");
                var t3 = null;
                if (3 === this.lookahead.type && !this.hasLineTerminator) {
                  var r3 = this.parseVariableIdentifier();
                  t3 = r3;
                  var n3 = "$" + r3.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, n3) || this.throwError(o.Messages.UnknownLabel, r3.name);
                }
                return this.consumeSemicolon(), null !== t3 || this.context.inIteration || this.throwError(o.Messages.IllegalContinue), this.finalize(e4, new a.ContinueStatement(t3));
              }, e3.prototype.parseBreakStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("break");
                var t3 = null;
                if (3 === this.lookahead.type && !this.hasLineTerminator) {
                  var r3 = this.parseVariableIdentifier(), n3 = "$" + r3.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, n3) || this.throwError(o.Messages.UnknownLabel, r3.name), t3 = r3;
                }
                return this.consumeSemicolon(), null !== t3 || this.context.inIteration || this.context.inSwitch || this.throwError(o.Messages.IllegalBreak), this.finalize(e4, new a.BreakStatement(t3));
              }, e3.prototype.parseReturnStatement = function() {
                this.context.inFunctionBody || this.tolerateError(o.Messages.IllegalReturn);
                var e4 = this.createNode();
                this.expectKeyword("return");
                var t3 = (this.match(";") || this.match("}") || this.hasLineTerminator || 2 === this.lookahead.type) && 8 !== this.lookahead.type && 10 !== this.lookahead.type ? null : this.parseExpression();
                return this.consumeSemicolon(), this.finalize(e4, new a.ReturnStatement(t3));
              }, e3.prototype.parseWithStatement = function() {
                this.context.strict && this.tolerateError(o.Messages.StrictModeWith);
                var e4, t3 = this.createNode();
                this.expectKeyword("with"), this.expect("(");
                var r3 = this.parseExpression();
                return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), e4 = this.finalize(this.createNode(), new a.EmptyStatement())) : (this.expect(")"), e4 = this.parseStatement()), this.finalize(t3, new a.WithStatement(r3, e4));
              }, e3.prototype.parseSwitchCase = function() {
                var e4, t3 = this.createNode();
                this.matchKeyword("default") ? (this.nextToken(), e4 = null) : (this.expectKeyword("case"), e4 = this.parseExpression()), this.expect(":");
                for (var r3 = []; !(this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")); )
                  r3.push(this.parseStatementListItem());
                return this.finalize(t3, new a.SwitchCase(e4, r3));
              }, e3.prototype.parseSwitchStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("switch"), this.expect("(");
                var t3 = this.parseExpression();
                this.expect(")");
                var r3 = this.context.inSwitch;
                this.context.inSwitch = true;
                var n3 = [], i2 = false;
                for (this.expect("{"); !this.match("}"); ) {
                  var s2 = this.parseSwitchCase();
                  null === s2.test && (i2 && this.throwError(o.Messages.MultipleDefaultsInSwitch), i2 = true), n3.push(s2);
                }
                return this.expect("}"), this.context.inSwitch = r3, this.finalize(e4, new a.SwitchStatement(t3, n3));
              }, e3.prototype.parseLabelledStatement = function() {
                var e4, t3 = this.createNode(), r3 = this.parseExpression();
                if (r3.type === u.Syntax.Identifier && this.match(":")) {
                  this.nextToken();
                  var n3 = r3, i2 = "$" + n3.name;
                  Object.prototype.hasOwnProperty.call(this.context.labelSet, i2) && this.throwError(o.Messages.Redeclaration, "Label", n3.name), this.context.labelSet[i2] = true;
                  var s2 = void 0;
                  if (this.matchKeyword("class"))
                    this.tolerateUnexpectedToken(this.lookahead), s2 = this.parseClassDeclaration();
                  else if (this.matchKeyword("function")) {
                    var l2 = this.lookahead, c2 = this.parseFunctionDeclaration();
                    this.context.strict ? this.tolerateUnexpectedToken(l2, o.Messages.StrictFunction) : c2.generator && this.tolerateUnexpectedToken(l2, o.Messages.GeneratorInLegacyContext), s2 = c2;
                  } else
                    s2 = this.parseStatement();
                  delete this.context.labelSet[i2], e4 = new a.LabeledStatement(n3, s2);
                } else
                  this.consumeSemicolon(), e4 = new a.ExpressionStatement(r3);
                return this.finalize(t3, e4);
              }, e3.prototype.parseThrowStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(o.Messages.NewlineAfterThrow);
                var t3 = this.parseExpression();
                return this.consumeSemicolon(), this.finalize(e4, new a.ThrowStatement(t3));
              }, e3.prototype.parseCatchClause = function() {
                var e4 = this.createNode();
                this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead);
                for (var t3 = [], r3 = this.parsePattern(t3), n3 = {}, i2 = 0; i2 < t3.length; i2++) {
                  var s2 = "$" + t3[i2].value;
                  Object.prototype.hasOwnProperty.call(n3, s2) && this.tolerateError(o.Messages.DuplicateBinding, t3[i2].value), n3[s2] = true;
                }
                this.context.strict && r3.type === u.Syntax.Identifier && this.scanner.isRestrictedWord(r3.name) && this.tolerateError(o.Messages.StrictCatchVariable), this.expect(")");
                var l2 = this.parseBlock();
                return this.finalize(e4, new a.CatchClause(r3, l2));
              }, e3.prototype.parseFinallyClause = function() {
                return this.expectKeyword("finally"), this.parseBlock();
              }, e3.prototype.parseTryStatement = function() {
                var e4 = this.createNode();
                this.expectKeyword("try");
                var t3 = this.parseBlock(), r3 = this.matchKeyword("catch") ? this.parseCatchClause() : null, n3 = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                return r3 || n3 || this.throwError(o.Messages.NoCatchOrFinally), this.finalize(e4, new a.TryStatement(t3, r3, n3));
              }, e3.prototype.parseDebuggerStatement = function() {
                var e4 = this.createNode();
                return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(e4, new a.DebuggerStatement());
              }, e3.prototype.parseStatement = function() {
                var e4;
                switch (this.lookahead.type) {
                  case 1:
                  case 5:
                  case 6:
                  case 8:
                  case 10:
                  case 9:
                    e4 = this.parseExpressionStatement();
                    break;
                  case 7:
                    var t3 = this.lookahead.value;
                    e4 = "{" === t3 ? this.parseBlock() : "(" === t3 ? this.parseExpressionStatement() : ";" === t3 ? this.parseEmptyStatement() : this.parseExpressionStatement();
                    break;
                  case 3:
                    e4 = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                    break;
                  case 4:
                    switch (this.lookahead.value) {
                      case "break":
                        e4 = this.parseBreakStatement();
                        break;
                      case "continue":
                        e4 = this.parseContinueStatement();
                        break;
                      case "debugger":
                        e4 = this.parseDebuggerStatement();
                        break;
                      case "do":
                        e4 = this.parseDoWhileStatement();
                        break;
                      case "for":
                        e4 = this.parseForStatement();
                        break;
                      case "function":
                        e4 = this.parseFunctionDeclaration();
                        break;
                      case "if":
                        e4 = this.parseIfStatement();
                        break;
                      case "return":
                        e4 = this.parseReturnStatement();
                        break;
                      case "switch":
                        e4 = this.parseSwitchStatement();
                        break;
                      case "throw":
                        e4 = this.parseThrowStatement();
                        break;
                      case "try":
                        e4 = this.parseTryStatement();
                        break;
                      case "var":
                        e4 = this.parseVariableStatement();
                        break;
                      case "while":
                        e4 = this.parseWhileStatement();
                        break;
                      case "with":
                        e4 = this.parseWithStatement();
                        break;
                      default:
                        e4 = this.parseExpressionStatement();
                    }
                    break;
                  default:
                    e4 = this.throwUnexpectedToken(this.lookahead);
                }
                return e4;
              }, e3.prototype.parseFunctionSourceElements = function() {
                var e4 = this.createNode();
                this.expect("{");
                var t3 = this.parseDirectivePrologues(), r3 = this.context.labelSet, n3 = this.context.inIteration, i2 = this.context.inSwitch, o2 = this.context.inFunctionBody;
                for (this.context.labelSet = {}, this.context.inIteration = false, this.context.inSwitch = false, this.context.inFunctionBody = true; 2 !== this.lookahead.type && !this.match("}"); )
                  t3.push(this.parseStatementListItem());
                return this.expect("}"), this.context.labelSet = r3, this.context.inIteration = n3, this.context.inSwitch = i2, this.context.inFunctionBody = o2, this.finalize(e4, new a.BlockStatement(t3));
              }, e3.prototype.validateParam = function(e4, t3, r3) {
                var n3 = "$" + r3;
                this.context.strict ? (this.scanner.isRestrictedWord(r3) && (e4.stricted = t3, e4.message = o.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(e4.paramSet, n3) && (e4.stricted = t3, e4.message = o.Messages.StrictParamDupe)) : e4.firstRestricted || (this.scanner.isRestrictedWord(r3) ? (e4.firstRestricted = t3, e4.message = o.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(r3) ? (e4.firstRestricted = t3, e4.message = o.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(e4.paramSet, n3) && (e4.stricted = t3, e4.message = o.Messages.StrictParamDupe)), "function" == typeof Object.defineProperty ? Object.defineProperty(e4.paramSet, n3, { value: true, enumerable: true, writable: true, configurable: true }) : e4.paramSet[n3] = true;
              }, e3.prototype.parseRestElement = function(e4) {
                var t3 = this.createNode();
                this.expect("...");
                var r3 = this.parsePattern(e4);
                return this.match("=") && this.throwError(o.Messages.DefaultRestParameter), this.match(")") || this.throwError(o.Messages.ParameterAfterRestParameter), this.finalize(t3, new a.RestElement(r3));
              }, e3.prototype.parseFormalParameter = function(e4) {
                for (var t3 = [], r3 = this.match("...") ? this.parseRestElement(t3) : this.parsePatternWithDefault(t3), n3 = 0; n3 < t3.length; n3++)
                  this.validateParam(e4, t3[n3], t3[n3].value);
                e4.simple = e4.simple && r3 instanceof a.Identifier, e4.params.push(r3);
              }, e3.prototype.parseFormalParameters = function(e4) {
                var t3;
                if (t3 = { simple: true, params: [], firstRestricted: e4 }, this.expect("("), !this.match(")"))
                  for (t3.paramSet = {}; 2 !== this.lookahead.type && (this.parseFormalParameter(t3), !this.match(")")) && (this.expect(","), !this.match(")")); )
                    ;
                return this.expect(")"), { simple: t3.simple, params: t3.params, stricted: t3.stricted, firstRestricted: t3.firstRestricted, message: t3.message };
              }, e3.prototype.matchAsyncFunction = function() {
                var e4 = this.matchContextualKeyword("async");
                if (e4) {
                  var t3 = this.scanner.saveState();
                  this.scanner.scanComments();
                  var r3 = this.scanner.lex();
                  this.scanner.restoreState(t3), e4 = t3.lineNumber === r3.lineNumber && 4 === r3.type && "function" === r3.value;
                }
                return e4;
              }, e3.prototype.parseFunctionDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.matchContextualKeyword("async");
                r3 && this.nextToken(), this.expectKeyword("function");
                var n3, i2 = !r3 && this.match("*");
                i2 && this.nextToken();
                var s2 = null, u2 = null;
                if (!e4 || !this.match("(")) {
                  var l2 = this.lookahead;
                  s2 = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(l2.value) && this.tolerateUnexpectedToken(l2, o.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(l2.value) ? (u2 = l2, n3 = o.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(l2.value) && (u2 = l2, n3 = o.Messages.StrictReservedWord);
                }
                var c2 = this.context.await, h = this.context.allowYield;
                this.context.await = r3, this.context.allowYield = !i2;
                var p = this.parseFormalParameters(u2), f = p.params, d = p.stricted;
                u2 = p.firstRestricted, p.message && (n3 = p.message);
                var m = this.context.strict, y = this.context.allowStrictDirective;
                this.context.allowStrictDirective = p.simple;
                var v = this.parseFunctionSourceElements();
                return this.context.strict && u2 && this.throwUnexpectedToken(u2, n3), this.context.strict && d && this.tolerateUnexpectedToken(d, n3), this.context.strict = m, this.context.allowStrictDirective = y, this.context.await = c2, this.context.allowYield = h, r3 ? this.finalize(t3, new a.AsyncFunctionDeclaration(s2, f, v)) : this.finalize(t3, new a.FunctionDeclaration(s2, f, v, i2));
              }, e3.prototype.parseFunctionExpression = function() {
                var e4 = this.createNode(), t3 = this.matchContextualKeyword("async");
                t3 && this.nextToken(), this.expectKeyword("function");
                var r3, n3 = !t3 && this.match("*");
                n3 && this.nextToken();
                var i2, s2 = null, u2 = this.context.await, l2 = this.context.allowYield;
                if (this.context.await = t3, this.context.allowYield = !n3, !this.match("(")) {
                  var c2 = this.lookahead;
                  s2 = this.context.strict || n3 || !this.matchKeyword("yield") ? this.parseVariableIdentifier() : this.parseIdentifierName(), this.context.strict ? this.scanner.isRestrictedWord(c2.value) && this.tolerateUnexpectedToken(c2, o.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(c2.value) ? (i2 = c2, r3 = o.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(c2.value) && (i2 = c2, r3 = o.Messages.StrictReservedWord);
                }
                var h = this.parseFormalParameters(i2), p = h.params, f = h.stricted;
                i2 = h.firstRestricted, h.message && (r3 = h.message);
                var d = this.context.strict, m = this.context.allowStrictDirective;
                this.context.allowStrictDirective = h.simple;
                var y = this.parseFunctionSourceElements();
                return this.context.strict && i2 && this.throwUnexpectedToken(i2, r3), this.context.strict && f && this.tolerateUnexpectedToken(f, r3), this.context.strict = d, this.context.allowStrictDirective = m, this.context.await = u2, this.context.allowYield = l2, t3 ? this.finalize(e4, new a.AsyncFunctionExpression(s2, p, y)) : this.finalize(e4, new a.FunctionExpression(s2, p, y, n3));
              }, e3.prototype.parseDirective = function() {
                var e4 = this.lookahead, t3 = this.createNode(), r3 = this.parseExpression(), n3 = r3.type === u.Syntax.Literal ? this.getTokenRaw(e4).slice(1, -1) : null;
                return this.consumeSemicolon(), this.finalize(t3, n3 ? new a.Directive(r3, n3) : new a.ExpressionStatement(r3));
              }, e3.prototype.parseDirectivePrologues = function() {
                for (var e4 = null, t3 = []; ; ) {
                  var r3 = this.lookahead;
                  if (8 !== r3.type)
                    break;
                  var n3 = this.parseDirective();
                  t3.push(n3);
                  var i2 = n3.directive;
                  if ("string" != typeof i2)
                    break;
                  "use strict" === i2 ? (this.context.strict = true, e4 && this.tolerateUnexpectedToken(e4, o.Messages.StrictOctalLiteral), this.context.allowStrictDirective || this.tolerateUnexpectedToken(r3, o.Messages.IllegalLanguageModeDirective)) : !e4 && r3.octal && (e4 = r3);
                }
                return t3;
              }, e3.prototype.qualifiedPropertyName = function(e4) {
                switch (e4.type) {
                  case 3:
                  case 8:
                  case 1:
                  case 5:
                  case 6:
                  case 4:
                    return true;
                  case 7:
                    return "[" === e4.value;
                }
                return false;
              }, e3.prototype.parseGetterMethod = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters();
                r3.params.length > 0 && this.tolerateError(o.Messages.BadGetterArity);
                var n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, false));
              }, e3.prototype.parseSetterMethod = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters();
                1 !== r3.params.length ? this.tolerateError(o.Messages.BadSetterArity) : r3.params[0] instanceof a.RestElement && this.tolerateError(o.Messages.BadSetterRestParameter);
                var n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, false));
              }, e3.prototype.parseGeneratorMethod = function() {
                var e4 = this.createNode(), t3 = this.context.allowYield;
                this.context.allowYield = true;
                var r3 = this.parseFormalParameters();
                this.context.allowYield = false;
                var n3 = this.parsePropertyMethod(r3);
                return this.context.allowYield = t3, this.finalize(e4, new a.FunctionExpression(null, r3.params, n3, true));
              }, e3.prototype.isStartOfExpression = function() {
                var e4 = true, t3 = this.lookahead.value;
                switch (this.lookahead.type) {
                  case 7:
                    e4 = "[" === t3 || "(" === t3 || "{" === t3 || "+" === t3 || "-" === t3 || "!" === t3 || "~" === t3 || "++" === t3 || "--" === t3 || "/" === t3 || "/=" === t3;
                    break;
                  case 4:
                    e4 = "class" === t3 || "delete" === t3 || "function" === t3 || "let" === t3 || "new" === t3 || "super" === t3 || "this" === t3 || "typeof" === t3 || "void" === t3 || "yield" === t3;
                }
                return e4;
              }, e3.prototype.parseYieldExpression = function() {
                var e4 = this.createNode();
                this.expectKeyword("yield");
                var t3 = null, r3 = false;
                if (!this.hasLineTerminator) {
                  var n3 = this.context.allowYield;
                  this.context.allowYield = false, (r3 = this.match("*")) ? (this.nextToken(), t3 = this.parseAssignmentExpression()) : this.isStartOfExpression() && (t3 = this.parseAssignmentExpression()), this.context.allowYield = n3;
                }
                return this.finalize(e4, new a.YieldExpression(t3, r3));
              }, e3.prototype.parseClassElement = function(e4) {
                var t3 = this.lookahead, r3 = this.createNode(), n3 = "", i2 = null, s2 = null, u2 = false, l2 = false, c2 = false, h = false;
                if (this.match("*"))
                  this.nextToken();
                else if (u2 = this.match("["), "static" === (i2 = this.parseObjectPropertyKey()).name && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (t3 = this.lookahead, c2 = true, u2 = this.match("["), this.match("*") ? this.nextToken() : i2 = this.parseObjectPropertyKey()), 3 === t3.type && !this.hasLineTerminator && "async" === t3.value) {
                  var p = this.lookahead.value;
                  ":" !== p && "(" !== p && "*" !== p && (h = true, t3 = this.lookahead, i2 = this.parseObjectPropertyKey(), 3 === t3.type && "constructor" === t3.value && this.tolerateUnexpectedToken(t3, o.Messages.ConstructorIsAsync));
                }
                var f = this.qualifiedPropertyName(this.lookahead);
                return 3 === t3.type ? "get" === t3.value && f ? (n3 = "get", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), this.context.allowYield = false, s2 = this.parseGetterMethod()) : "set" === t3.value && f && (n3 = "set", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseSetterMethod()) : 7 === t3.type && "*" === t3.value && f && (n3 = "init", u2 = this.match("["), i2 = this.parseObjectPropertyKey(), s2 = this.parseGeneratorMethod(), l2 = true), !n3 && i2 && this.match("(") && (n3 = "init", s2 = h ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), l2 = true), n3 || this.throwUnexpectedToken(this.lookahead), "init" === n3 && (n3 = "method"), u2 || (c2 && this.isPropertyKey(i2, "prototype") && this.throwUnexpectedToken(t3, o.Messages.StaticPrototype), !c2 && this.isPropertyKey(i2, "constructor") && (("method" !== n3 || !l2 || s2 && s2.generator) && this.throwUnexpectedToken(t3, o.Messages.ConstructorSpecialMethod), e4.value ? this.throwUnexpectedToken(t3, o.Messages.DuplicateConstructor) : e4.value = true, n3 = "constructor")), this.finalize(r3, new a.MethodDefinition(i2, u2, s2, n3, c2));
              }, e3.prototype.parseClassElementList = function() {
                var e4 = [], t3 = { value: false };
                for (this.expect("{"); !this.match("}"); )
                  this.match(";") ? this.nextToken() : e4.push(this.parseClassElement(t3));
                return this.expect("}"), e4;
              }, e3.prototype.parseClassBody = function() {
                var e4 = this.createNode(), t3 = this.parseClassElementList();
                return this.finalize(e4, new a.ClassBody(t3));
              }, e3.prototype.parseClassDeclaration = function(e4) {
                var t3 = this.createNode(), r3 = this.context.strict;
                this.context.strict = true, this.expectKeyword("class");
                var n3 = e4 && 3 !== this.lookahead.type ? null : this.parseVariableIdentifier(), i2 = null;
                this.matchKeyword("extends") && (this.nextToken(), i2 = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var o2 = this.parseClassBody();
                return this.context.strict = r3, this.finalize(t3, new a.ClassDeclaration(n3, i2, o2));
              }, e3.prototype.parseClassExpression = function() {
                var e4 = this.createNode(), t3 = this.context.strict;
                this.context.strict = true, this.expectKeyword("class");
                var r3 = 3 === this.lookahead.type ? this.parseVariableIdentifier() : null, n3 = null;
                this.matchKeyword("extends") && (this.nextToken(), n3 = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
                var i2 = this.parseClassBody();
                return this.context.strict = t3, this.finalize(e4, new a.ClassExpression(r3, n3, i2));
              }, e3.prototype.parseModule = function() {
                this.context.strict = true, this.context.isModule = true, this.scanner.isModule = true;
                for (var e4 = this.createNode(), t3 = this.parseDirectivePrologues(); 2 !== this.lookahead.type; )
                  t3.push(this.parseStatementListItem());
                return this.finalize(e4, new a.Module(t3));
              }, e3.prototype.parseScript = function() {
                for (var e4 = this.createNode(), t3 = this.parseDirectivePrologues(); 2 !== this.lookahead.type; )
                  t3.push(this.parseStatementListItem());
                return this.finalize(e4, new a.Script(t3));
              }, e3.prototype.parseModuleSpecifier = function() {
                var e4 = this.createNode();
                8 !== this.lookahead.type && this.throwError(o.Messages.InvalidModuleSpecifier);
                var t3 = this.nextToken(), r3 = this.getTokenRaw(t3);
                return this.finalize(e4, new a.Literal(t3.value, r3));
              }, e3.prototype.parseImportSpecifier = function() {
                var e4, t3, r3 = this.createNode();
                return 3 === this.lookahead.type ? (t3 = e4 = this.parseVariableIdentifier(), this.matchContextualKeyword("as") && (this.nextToken(), t3 = this.parseVariableIdentifier())) : (t3 = e4 = this.parseIdentifierName(), this.matchContextualKeyword("as") ? (this.nextToken(), t3 = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(r3, new a.ImportSpecifier(t3, e4));
              }, e3.prototype.parseNamedImports = function() {
                this.expect("{");
                for (var e4 = []; !this.match("}"); )
                  e4.push(this.parseImportSpecifier()), this.match("}") || this.expect(",");
                return this.expect("}"), e4;
              }, e3.prototype.parseImportDefaultSpecifier = function() {
                var e4 = this.createNode(), t3 = this.parseIdentifierName();
                return this.finalize(e4, new a.ImportDefaultSpecifier(t3));
              }, e3.prototype.parseImportNamespaceSpecifier = function() {
                var e4 = this.createNode();
                this.expect("*"), this.matchContextualKeyword("as") || this.throwError(o.Messages.NoAsAfterImportNamespace), this.nextToken();
                var t3 = this.parseIdentifierName();
                return this.finalize(e4, new a.ImportNamespaceSpecifier(t3));
              }, e3.prototype.parseImportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(o.Messages.IllegalImportDeclaration);
                var e4, t3 = this.createNode();
                this.expectKeyword("import");
                var r3 = [];
                if (8 === this.lookahead.type)
                  e4 = this.parseModuleSpecifier();
                else {
                  if (this.match("{") ? r3 = r3.concat(this.parseNamedImports()) : this.match("*") ? r3.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (r3.push(this.parseImportDefaultSpecifier()), this.match(",") && (this.nextToken(), this.match("*") ? r3.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? r3 = r3.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword("from")) {
                    var n3 = this.lookahead.value ? o.Messages.UnexpectedToken : o.Messages.MissingFromClause;
                    this.throwError(n3, this.lookahead.value);
                  }
                  this.nextToken(), e4 = this.parseModuleSpecifier();
                }
                return this.consumeSemicolon(), this.finalize(t3, new a.ImportDeclaration(r3, e4));
              }, e3.prototype.parseExportSpecifier = function() {
                var e4 = this.createNode(), t3 = this.parseIdentifierName(), r3 = t3;
                return this.matchContextualKeyword("as") && (this.nextToken(), r3 = this.parseIdentifierName()), this.finalize(e4, new a.ExportSpecifier(t3, r3));
              }, e3.prototype.parseExportDeclaration = function() {
                this.context.inFunctionBody && this.throwError(o.Messages.IllegalExportDeclaration);
                var e4, t3 = this.createNode();
                if (this.expectKeyword("export"), this.matchKeyword("default"))
                  if (this.nextToken(), this.matchKeyword("function")) {
                    var r3 = this.parseFunctionDeclaration(true);
                    e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3));
                  } else
                    this.matchKeyword("class") ? (r3 = this.parseClassDeclaration(true), e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3))) : this.matchContextualKeyword("async") ? (r3 = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression(), e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3))) : (this.matchContextualKeyword("from") && this.throwError(o.Messages.UnexpectedToken, this.lookahead.value), r3 = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression(), this.consumeSemicolon(), e4 = this.finalize(t3, new a.ExportDefaultDeclaration(r3)));
                else if (this.match("*")) {
                  if (this.nextToken(), !this.matchContextualKeyword("from")) {
                    var n3 = this.lookahead.value ? o.Messages.UnexpectedToken : o.Messages.MissingFromClause;
                    this.throwError(n3, this.lookahead.value);
                  }
                  this.nextToken();
                  var i2 = this.parseModuleSpecifier();
                  this.consumeSemicolon(), e4 = this.finalize(t3, new a.ExportAllDeclaration(i2));
                } else if (4 === this.lookahead.type) {
                  switch (r3 = void 0, this.lookahead.value) {
                    case "let":
                    case "const":
                      r3 = this.parseLexicalDeclaration({ inFor: false });
                      break;
                    case "var":
                    case "class":
                    case "function":
                      r3 = this.parseStatementListItem();
                      break;
                    default:
                      this.throwUnexpectedToken(this.lookahead);
                  }
                  e4 = this.finalize(t3, new a.ExportNamedDeclaration(r3, [], null));
                } else if (this.matchAsyncFunction())
                  r3 = this.parseFunctionDeclaration(), e4 = this.finalize(t3, new a.ExportNamedDeclaration(r3, [], null));
                else {
                  var s2 = [], u2 = null, l2 = false;
                  for (this.expect("{"); !this.match("}"); )
                    l2 = l2 || this.matchKeyword("default"), s2.push(this.parseExportSpecifier()), this.match("}") || this.expect(",");
                  this.expect("}"), this.matchContextualKeyword("from") ? (this.nextToken(), u2 = this.parseModuleSpecifier(), this.consumeSemicolon()) : l2 ? (n3 = this.lookahead.value ? o.Messages.UnexpectedToken : o.Messages.MissingFromClause, this.throwError(n3, this.lookahead.value)) : this.consumeSemicolon(), e4 = this.finalize(t3, new a.ExportNamedDeclaration(null, s2, u2));
                }
                return e4;
              }, e3;
            }();
            t2.Parser = c;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.assert = function(e3, t3) {
              if (!e3)
                throw new Error("ASSERT: " + t3);
            };
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var r2 = function() {
              function e3() {
                this.errors = [], this.tolerant = false;
              }
              return e3.prototype.recordError = function(e4) {
                this.errors.push(e4);
              }, e3.prototype.tolerate = function(e4) {
                if (!this.tolerant)
                  throw e4;
                this.recordError(e4);
              }, e3.prototype.constructError = function(e4, t3) {
                var r3 = new Error(e4);
                try {
                  throw r3;
                } catch (e5) {
                  Object.create && Object.defineProperty && (r3 = Object.create(e5), Object.defineProperty(r3, "column", { value: t3 }));
                }
                return r3;
              }, e3.prototype.createError = function(e4, t3, r3, n2) {
                var i = "Line " + t3 + ": " + n2, o = this.constructError(i, r3);
                return o.index = e4, o.lineNumber = t3, o.description = n2, o;
              }, e3.prototype.throwError = function(e4, t3, r3, n2) {
                throw this.createError(e4, t3, r3, n2);
              }, e3.prototype.tolerateError = function(e4, t3, r3, n2) {
                var i = this.createError(e4, t3, r3, n2);
                if (!this.tolerant)
                  throw i;
                this.recordError(i);
              }, e3;
            }();
            t2.ErrorHandler = r2;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.Messages = { BadGetterArity: "Getter must not have any formal parameters", BadSetterArity: "Setter must have exactly one formal parameter", BadSetterRestParameter: "Setter function argument must not be a rest parameter", ConstructorIsAsync: "Class constructor may not be an async method", ConstructorSpecialMethod: "Class constructor may not be an accessor", DeclarationMissingInitializer: "Missing initializer in %0 declaration", DefaultRestParameter: "Unexpected token =", DuplicateBinding: "Duplicate binding %0", DuplicateConstructor: "A class may only have one constructor", DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals", ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer", GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts", IllegalBreak: "Illegal break statement", IllegalContinue: "Illegal continue statement", IllegalExportDeclaration: "Unexpected token", IllegalImportDeclaration: "Unexpected token", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list", IllegalReturn: "Illegal return statement", InvalidEscapedReservedWord: "Keyword must not contain escaped characters", InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence", InvalidLHSInAssignment: "Invalid left-hand side in assignment", InvalidLHSInForIn: "Invalid left-hand side in for-in", InvalidLHSInForLoop: "Invalid left-hand side in for-loop", InvalidModuleSpecifier: "Unexpected token", InvalidRegExp: "Invalid regular expression", LetInLexicalBinding: "let is disallowed as a lexically bound name", MissingFromClause: "Unexpected token", MultipleDefaultsInSwitch: "More than one default clause in switch statement", NewlineAfterThrow: "Illegal newline after throw", NoAsAfterImportNamespace: "Unexpected token", NoCatchOrFinally: "Missing catch or finally after try", ParameterAfterRestParameter: "Rest parameter must be last formal parameter", Redeclaration: "%0 '%1' has already been declared", StaticPrototype: "Classes may not have static property named prototype", StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode", StrictDelete: "Delete of an unqualified identifier in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block", StrictFunctionName: "Function name may not be eval or arguments in strict mode", StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode", StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode", StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode", StrictModeWith: "Strict mode code may not include a with statement", StrictOctalLiteral: "Octal literals are not allowed in strict mode.", StrictParamDupe: "Strict mode function may not have duplicate parameter names", StrictParamName: "Parameter name eval or arguments is not allowed in strict mode", StrictReservedWord: "Use of future reserved word in strict mode", StrictVarName: "Variable name may not be eval or arguments in strict mode", TemplateOctalLiteral: "Octal literals are not allowed in template strings.", UnexpectedEOS: "Unexpected end of input", UnexpectedIdentifier: "Unexpected identifier", UnexpectedNumber: "Unexpected number", UnexpectedReserved: "Unexpected reserved word", UnexpectedString: "Unexpected string", UnexpectedTemplate: "Unexpected quasi %0", UnexpectedToken: "Unexpected token %0", UnexpectedTokenIllegal: "Unexpected token ILLEGAL", UnknownLabel: "Undefined label '%0'", UnterminatedRegExp: "Invalid regular expression: missing /" };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(9), i = r2(4), o = r2(11);
            function a(e3) {
              return "0123456789abcdef".indexOf(e3.toLowerCase());
            }
            function s(e3) {
              return "01234567".indexOf(e3);
            }
            var u = function() {
              function e3(e4, t3) {
                this.source = e4, this.errorHandler = t3, this.trackComment = false, this.isModule = false, this.length = e4.length, this.index = 0, this.lineNumber = e4.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
              }
              return e3.prototype.saveState = function() {
                return { index: this.index, lineNumber: this.lineNumber, lineStart: this.lineStart };
              }, e3.prototype.restoreState = function(e4) {
                this.index = e4.index, this.lineNumber = e4.lineNumber, this.lineStart = e4.lineStart;
              }, e3.prototype.eof = function() {
                return this.index >= this.length;
              }, e3.prototype.throwUnexpectedToken = function(e4) {
                return void 0 === e4 && (e4 = o.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, e4);
              }, e3.prototype.tolerateUnexpectedToken = function(e4) {
                void 0 === e4 && (e4 = o.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, e4);
              }, e3.prototype.skipSingleLineComment = function(e4) {
                var t3, r3, n3 = [];
                for (this.trackComment && (n3 = [], t3 = this.index - e4, r3 = { start: { line: this.lineNumber, column: this.index - this.lineStart - e4 }, end: {} }); !this.eof(); ) {
                  var o2 = this.source.charCodeAt(this.index);
                  if (++this.index, i.Character.isLineTerminator(o2)) {
                    if (this.trackComment) {
                      r3.end = { line: this.lineNumber, column: this.index - this.lineStart - 1 };
                      var a2 = { multiLine: false, slice: [t3 + e4, this.index - 1], range: [t3, this.index - 1], loc: r3 };
                      n3.push(a2);
                    }
                    return 13 === o2 && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, n3;
                  }
                }
                return this.trackComment && (r3.end = { line: this.lineNumber, column: this.index - this.lineStart }, a2 = { multiLine: false, slice: [t3 + e4, this.index], range: [t3, this.index], loc: r3 }, n3.push(a2)), n3;
              }, e3.prototype.skipMultiLineComment = function() {
                var e4, t3, r3 = [];
                for (this.trackComment && (r3 = [], e4 = this.index - 2, t3 = { start: { line: this.lineNumber, column: this.index - this.lineStart - 2 }, end: {} }); !this.eof(); ) {
                  var n3 = this.source.charCodeAt(this.index);
                  if (i.Character.isLineTerminator(n3))
                    13 === n3 && 10 === this.source.charCodeAt(this.index + 1) && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index;
                  else if (42 === n3) {
                    if (47 === this.source.charCodeAt(this.index + 1)) {
                      if (this.index += 2, this.trackComment) {
                        t3.end = { line: this.lineNumber, column: this.index - this.lineStart };
                        var o2 = { multiLine: true, slice: [e4 + 2, this.index - 2], range: [e4, this.index], loc: t3 };
                        r3.push(o2);
                      }
                      return r3;
                    }
                    ++this.index;
                  } else
                    ++this.index;
                }
                return this.trackComment && (t3.end = { line: this.lineNumber, column: this.index - this.lineStart }, o2 = { multiLine: true, slice: [e4 + 2, this.index], range: [e4, this.index], loc: t3 }, r3.push(o2)), this.tolerateUnexpectedToken(), r3;
              }, e3.prototype.scanComments = function() {
                var e4;
                this.trackComment && (e4 = []);
                for (var t3 = 0 === this.index; !this.eof(); ) {
                  var r3 = this.source.charCodeAt(this.index);
                  if (i.Character.isWhiteSpace(r3))
                    ++this.index;
                  else if (i.Character.isLineTerminator(r3))
                    ++this.index, 13 === r3 && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, t3 = true;
                  else if (47 === r3)
                    if (47 === (r3 = this.source.charCodeAt(this.index + 1))) {
                      this.index += 2;
                      var n3 = this.skipSingleLineComment(2);
                      this.trackComment && (e4 = e4.concat(n3)), t3 = true;
                    } else {
                      if (42 !== r3)
                        break;
                      this.index += 2, n3 = this.skipMultiLineComment(), this.trackComment && (e4 = e4.concat(n3));
                    }
                  else if (t3 && 45 === r3) {
                    if (45 !== this.source.charCodeAt(this.index + 1) || 62 !== this.source.charCodeAt(this.index + 2))
                      break;
                    this.index += 3, n3 = this.skipSingleLineComment(3), this.trackComment && (e4 = e4.concat(n3));
                  } else {
                    if (60 !== r3 || this.isModule)
                      break;
                    if ("!--" !== this.source.slice(this.index + 1, this.index + 4))
                      break;
                    this.index += 4, n3 = this.skipSingleLineComment(4), this.trackComment && (e4 = e4.concat(n3));
                  }
                }
                return e4;
              }, e3.prototype.isFutureReservedWord = function(e4) {
                switch (e4) {
                  case "enum":
                  case "export":
                  case "import":
                  case "super":
                    return true;
                  default:
                    return false;
                }
              }, e3.prototype.isStrictModeReservedWord = function(e4) {
                switch (e4) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }, e3.prototype.isRestrictedWord = function(e4) {
                return "eval" === e4 || "arguments" === e4;
              }, e3.prototype.isKeyword = function(e4) {
                switch (e4.length) {
                  case 2:
                    return "if" === e4 || "in" === e4 || "do" === e4;
                  case 3:
                    return "var" === e4 || "for" === e4 || "new" === e4 || "try" === e4 || "let" === e4;
                  case 4:
                    return "this" === e4 || "else" === e4 || "case" === e4 || "void" === e4 || "with" === e4 || "enum" === e4;
                  case 5:
                    return "while" === e4 || "break" === e4 || "catch" === e4 || "throw" === e4 || "const" === e4 || "yield" === e4 || "class" === e4 || "super" === e4;
                  case 6:
                    return "return" === e4 || "typeof" === e4 || "delete" === e4 || "switch" === e4 || "export" === e4 || "import" === e4;
                  case 7:
                    return "default" === e4 || "finally" === e4 || "extends" === e4;
                  case 8:
                    return "function" === e4 || "continue" === e4 || "debugger" === e4;
                  case 10:
                    return "instanceof" === e4;
                  default:
                    return false;
                }
              }, e3.prototype.codePointAt = function(e4) {
                var t3 = this.source.charCodeAt(e4);
                if (t3 >= 55296 && t3 <= 56319) {
                  var r3 = this.source.charCodeAt(e4 + 1);
                  r3 >= 56320 && r3 <= 57343 && (t3 = 1024 * (t3 - 55296) + r3 - 56320 + 65536);
                }
                return t3;
              }, e3.prototype.scanHexEscape = function(e4) {
                for (var t3 = "u" === e4 ? 4 : 2, r3 = 0, n3 = 0; n3 < t3; ++n3) {
                  if (this.eof() || !i.Character.isHexDigit(this.source.charCodeAt(this.index)))
                    return null;
                  r3 = 16 * r3 + a(this.source[this.index++]);
                }
                return String.fromCharCode(r3);
              }, e3.prototype.scanUnicodeCodePointEscape = function() {
                var e4 = this.source[this.index], t3 = 0;
                for ("}" === e4 && this.throwUnexpectedToken(); !this.eof() && (e4 = this.source[this.index++], i.Character.isHexDigit(e4.charCodeAt(0))); )
                  t3 = 16 * t3 + a(e4);
                return (t3 > 1114111 || "}" !== e4) && this.throwUnexpectedToken(), i.Character.fromCodePoint(t3);
              }, e3.prototype.getIdentifier = function() {
                for (var e4 = this.index++; !this.eof(); ) {
                  var t3 = this.source.charCodeAt(this.index);
                  if (92 === t3)
                    return this.index = e4, this.getComplexIdentifier();
                  if (t3 >= 55296 && t3 < 57343)
                    return this.index = e4, this.getComplexIdentifier();
                  if (!i.Character.isIdentifierPart(t3))
                    break;
                  ++this.index;
                }
                return this.source.slice(e4, this.index);
              }, e3.prototype.getComplexIdentifier = function() {
                var e4, t3 = this.codePointAt(this.index), r3 = i.Character.fromCodePoint(t3);
                for (this.index += r3.length, 92 === t3 && (117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, e4 = this.scanUnicodeCodePointEscape()) : null !== (e4 = this.scanHexEscape("u")) && "\\" !== e4 && i.Character.isIdentifierStart(e4.charCodeAt(0)) || this.throwUnexpectedToken(), r3 = e4); !this.eof() && (t3 = this.codePointAt(this.index), i.Character.isIdentifierPart(t3)); )
                  r3 += e4 = i.Character.fromCodePoint(t3), this.index += e4.length, 92 === t3 && (r3 = r3.substr(0, r3.length - 1), 117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, e4 = this.scanUnicodeCodePointEscape()) : null !== (e4 = this.scanHexEscape("u")) && "\\" !== e4 && i.Character.isIdentifierPart(e4.charCodeAt(0)) || this.throwUnexpectedToken(), r3 += e4);
                return r3;
              }, e3.prototype.octalToDecimal = function(e4) {
                var t3 = "0" !== e4, r3 = s(e4);
                return !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (t3 = true, r3 = 8 * r3 + s(this.source[this.index++]), "0123".indexOf(e4) >= 0 && !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (r3 = 8 * r3 + s(this.source[this.index++]))), { code: r3, octal: t3 };
              }, e3.prototype.scanIdentifier = function() {
                var e4, t3 = this.index, r3 = 92 === this.source.charCodeAt(t3) ? this.getComplexIdentifier() : this.getIdentifier();
                if (3 != (e4 = 1 === r3.length ? 3 : this.isKeyword(r3) ? 4 : "null" === r3 ? 5 : "true" === r3 || "false" === r3 ? 1 : 3) && t3 + r3.length !== this.index) {
                  var n3 = this.index;
                  this.index = t3, this.tolerateUnexpectedToken(o.Messages.InvalidEscapedReservedWord), this.index = n3;
                }
                return { type: e4, value: r3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: t3, end: this.index };
              }, e3.prototype.scanPunctuator = function() {
                var e4 = this.index, t3 = this.source[this.index];
                switch (t3) {
                  case "(":
                  case "{":
                    "{" === t3 && this.curlyStack.push("{"), ++this.index;
                    break;
                  case ".":
                    ++this.index, "." === this.source[this.index] && "." === this.source[this.index + 1] && (this.index += 2, t3 = "...");
                    break;
                  case "}":
                    ++this.index, this.curlyStack.pop();
                    break;
                  case ")":
                  case ";":
                  case ",":
                  case "[":
                  case "]":
                  case ":":
                  case "?":
                  case "~":
                    ++this.index;
                    break;
                  default:
                    ">>>=" === (t3 = this.source.substr(this.index, 4)) ? this.index += 4 : "===" === (t3 = t3.substr(0, 3)) || "!==" === t3 || ">>>" === t3 || "<<=" === t3 || ">>=" === t3 || "**=" === t3 ? this.index += 3 : "&&" === (t3 = t3.substr(0, 2)) || "||" === t3 || "==" === t3 || "!=" === t3 || "+=" === t3 || "-=" === t3 || "*=" === t3 || "/=" === t3 || "++" === t3 || "--" === t3 || "<<" === t3 || ">>" === t3 || "&=" === t3 || "|=" === t3 || "^=" === t3 || "%=" === t3 || "<=" === t3 || ">=" === t3 || "=>" === t3 || "**" === t3 ? this.index += 2 : (t3 = this.source[this.index], "<>=!+-*%&|^/".indexOf(t3) >= 0 && ++this.index);
                }
                return this.index === e4 && this.throwUnexpectedToken(), { type: 7, value: t3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanHexLiteral = function(e4) {
                for (var t3 = ""; !this.eof() && i.Character.isHexDigit(this.source.charCodeAt(this.index)); )
                  t3 += this.source[this.index++];
                return 0 === t3.length && this.throwUnexpectedToken(), i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: 6, value: parseInt("0x" + t3, 16), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanBinaryLiteral = function(e4) {
                for (var t3, r3 = ""; !this.eof() && ("0" === (t3 = this.source[this.index]) || "1" === t3); )
                  r3 += this.source[this.index++];
                return 0 === r3.length && this.throwUnexpectedToken(), this.eof() || (t3 = this.source.charCodeAt(this.index), (i.Character.isIdentifierStart(t3) || i.Character.isDecimalDigit(t3)) && this.throwUnexpectedToken()), { type: 6, value: parseInt(r3, 2), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanOctalLiteral = function(e4, t3) {
                var r3 = "", n3 = false;
                for (i.Character.isOctalDigit(e4.charCodeAt(0)) ? (n3 = true, r3 = "0" + this.source[this.index++]) : ++this.index; !this.eof() && i.Character.isOctalDigit(this.source.charCodeAt(this.index)); )
                  r3 += this.source[this.index++];
                return n3 || 0 !== r3.length || this.throwUnexpectedToken(), (i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || i.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), { type: 6, value: parseInt(r3, 8), octal: n3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: t3, end: this.index };
              }, e3.prototype.isImplicitOctalLiteral = function() {
                for (var e4 = this.index + 1; e4 < this.length; ++e4) {
                  var t3 = this.source[e4];
                  if ("8" === t3 || "9" === t3)
                    return false;
                  if (!i.Character.isOctalDigit(t3.charCodeAt(0)))
                    return true;
                }
                return true;
              }, e3.prototype.scanNumericLiteral = function() {
                var e4 = this.index, t3 = this.source[e4];
                n2.assert(i.Character.isDecimalDigit(t3.charCodeAt(0)) || "." === t3, "Numeric literal must start with a decimal digit or a decimal point");
                var r3 = "";
                if ("." !== t3) {
                  if (r3 = this.source[this.index++], t3 = this.source[this.index], "0" === r3) {
                    if ("x" === t3 || "X" === t3)
                      return ++this.index, this.scanHexLiteral(e4);
                    if ("b" === t3 || "B" === t3)
                      return ++this.index, this.scanBinaryLiteral(e4);
                    if ("o" === t3 || "O" === t3)
                      return this.scanOctalLiteral(t3, e4);
                    if (t3 && i.Character.isOctalDigit(t3.charCodeAt(0)) && this.isImplicitOctalLiteral())
                      return this.scanOctalLiteral(t3, e4);
                  }
                  for (; i.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    r3 += this.source[this.index++];
                  t3 = this.source[this.index];
                }
                if ("." === t3) {
                  for (r3 += this.source[this.index++]; i.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    r3 += this.source[this.index++];
                  t3 = this.source[this.index];
                }
                if ("e" === t3 || "E" === t3)
                  if (r3 += this.source[this.index++], "+" !== (t3 = this.source[this.index]) && "-" !== t3 || (r3 += this.source[this.index++]), i.Character.isDecimalDigit(this.source.charCodeAt(this.index)))
                    for (; i.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                      r3 += this.source[this.index++];
                  else
                    this.throwUnexpectedToken();
                return i.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: 6, value: parseFloat(r3), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanStringLiteral = function() {
                var e4 = this.index, t3 = this.source[e4];
                n2.assert("'" === t3 || '"' === t3, "String literal must starts with a quote"), ++this.index;
                for (var r3 = false, a2 = ""; !this.eof(); ) {
                  var s2 = this.source[this.index++];
                  if (s2 === t3) {
                    t3 = "";
                    break;
                  }
                  if ("\\" === s2)
                    if ((s2 = this.source[this.index++]) && i.Character.isLineTerminator(s2.charCodeAt(0)))
                      ++this.lineNumber, "\r" === s2 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index;
                    else
                      switch (s2) {
                        case "u":
                          if ("{" === this.source[this.index])
                            ++this.index, a2 += this.scanUnicodeCodePointEscape();
                          else {
                            var u2 = this.scanHexEscape(s2);
                            null === u2 && this.throwUnexpectedToken(), a2 += u2;
                          }
                          break;
                        case "x":
                          var l = this.scanHexEscape(s2);
                          null === l && this.throwUnexpectedToken(o.Messages.InvalidHexEscapeSequence), a2 += l;
                          break;
                        case "n":
                          a2 += "\n";
                          break;
                        case "r":
                          a2 += "\r";
                          break;
                        case "t":
                          a2 += "	";
                          break;
                        case "b":
                          a2 += "\b";
                          break;
                        case "f":
                          a2 += "\f";
                          break;
                        case "v":
                          a2 += "\v";
                          break;
                        case "8":
                        case "9":
                          a2 += s2, this.tolerateUnexpectedToken();
                          break;
                        default:
                          if (s2 && i.Character.isOctalDigit(s2.charCodeAt(0))) {
                            var c = this.octalToDecimal(s2);
                            r3 = c.octal || r3, a2 += String.fromCharCode(c.code);
                          } else
                            a2 += s2;
                      }
                  else {
                    if (i.Character.isLineTerminator(s2.charCodeAt(0)))
                      break;
                    a2 += s2;
                  }
                }
                return "" !== t3 && (this.index = e4, this.throwUnexpectedToken()), { type: 8, value: a2, octal: r3, lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.scanTemplate = function() {
                var e4 = "", t3 = false, r3 = this.index, n3 = "`" === this.source[r3], a2 = false, s2 = 2;
                for (++this.index; !this.eof(); ) {
                  var u2 = this.source[this.index++];
                  if ("`" === u2) {
                    s2 = 1, a2 = true, t3 = true;
                    break;
                  }
                  if ("$" === u2) {
                    if ("{" === this.source[this.index]) {
                      this.curlyStack.push("${"), ++this.index, t3 = true;
                      break;
                    }
                    e4 += u2;
                  } else if ("\\" === u2)
                    if (u2 = this.source[this.index++], i.Character.isLineTerminator(u2.charCodeAt(0)))
                      ++this.lineNumber, "\r" === u2 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index;
                    else
                      switch (u2) {
                        case "n":
                          e4 += "\n";
                          break;
                        case "r":
                          e4 += "\r";
                          break;
                        case "t":
                          e4 += "	";
                          break;
                        case "u":
                          if ("{" === this.source[this.index])
                            ++this.index, e4 += this.scanUnicodeCodePointEscape();
                          else {
                            var l = this.index, c = this.scanHexEscape(u2);
                            null !== c ? e4 += c : (this.index = l, e4 += u2);
                          }
                          break;
                        case "x":
                          var h = this.scanHexEscape(u2);
                          null === h && this.throwUnexpectedToken(o.Messages.InvalidHexEscapeSequence), e4 += h;
                          break;
                        case "b":
                          e4 += "\b";
                          break;
                        case "f":
                          e4 += "\f";
                          break;
                        case "v":
                          e4 += "\v";
                          break;
                        default:
                          "0" === u2 ? (i.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(o.Messages.TemplateOctalLiteral), e4 += "\0") : i.Character.isOctalDigit(u2.charCodeAt(0)) ? this.throwUnexpectedToken(o.Messages.TemplateOctalLiteral) : e4 += u2;
                      }
                  else
                    i.Character.isLineTerminator(u2.charCodeAt(0)) ? (++this.lineNumber, "\r" === u2 && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index, e4 += "\n") : e4 += u2;
                }
                return t3 || this.throwUnexpectedToken(), n3 || this.curlyStack.pop(), { type: 10, value: this.source.slice(r3 + 1, this.index - s2), cooked: e4, head: n3, tail: a2, lineNumber: this.lineNumber, lineStart: this.lineStart, start: r3, end: this.index };
              }, e3.prototype.testRegExp = function(e4, t3) {
                var r3 = e4, n3 = this;
                t3.indexOf("u") >= 0 && (r3 = r3.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function(e5, t4, r4) {
                  var i2 = parseInt(t4 || r4, 16);
                  return i2 > 1114111 && n3.throwUnexpectedToken(o.Messages.InvalidRegExp), i2 <= 65535 ? String.fromCharCode(i2) : "\uFFFF";
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "\uFFFF"));
                try {
                  RegExp(r3);
                } catch (e5) {
                  this.throwUnexpectedToken(o.Messages.InvalidRegExp);
                }
                try {
                  return new RegExp(e4, t3);
                } catch (e5) {
                  return null;
                }
              }, e3.prototype.scanRegExpBody = function() {
                var e4 = this.source[this.index];
                n2.assert("/" === e4, "Regular expression literal must start with a slash");
                for (var t3 = this.source[this.index++], r3 = false, a2 = false; !this.eof(); )
                  if (t3 += e4 = this.source[this.index++], "\\" === e4)
                    e4 = this.source[this.index++], i.Character.isLineTerminator(e4.charCodeAt(0)) && this.throwUnexpectedToken(o.Messages.UnterminatedRegExp), t3 += e4;
                  else if (i.Character.isLineTerminator(e4.charCodeAt(0)))
                    this.throwUnexpectedToken(o.Messages.UnterminatedRegExp);
                  else if (r3)
                    "]" === e4 && (r3 = false);
                  else {
                    if ("/" === e4) {
                      a2 = true;
                      break;
                    }
                    "[" === e4 && (r3 = true);
                  }
                return a2 || this.throwUnexpectedToken(o.Messages.UnterminatedRegExp), t3.substr(1, t3.length - 2);
              }, e3.prototype.scanRegExpFlags = function() {
                for (var e4 = ""; !this.eof(); ) {
                  var t3 = this.source[this.index];
                  if (!i.Character.isIdentifierPart(t3.charCodeAt(0)))
                    break;
                  if (++this.index, "\\" !== t3 || this.eof())
                    e4 += t3;
                  else if ("u" === (t3 = this.source[this.index])) {
                    ++this.index;
                    var r3 = this.index, n3 = this.scanHexEscape("u");
                    if (null !== n3)
                      for (e4 += n3; r3 < this.index; ++r3)
                        this.source[r3];
                    else
                      this.index = r3, e4 += "u";
                    this.tolerateUnexpectedToken();
                  } else
                    this.tolerateUnexpectedToken();
                }
                return e4;
              }, e3.prototype.scanRegExp = function() {
                var e4 = this.index, t3 = this.scanRegExpBody(), r3 = this.scanRegExpFlags();
                return { type: 9, value: "", pattern: t3, flags: r3, regex: this.testRegExp(t3, r3), lineNumber: this.lineNumber, lineStart: this.lineStart, start: e4, end: this.index };
              }, e3.prototype.lex = function() {
                if (this.eof())
                  return { type: 2, value: "", lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index };
                var e4 = this.source.charCodeAt(this.index);
                return i.Character.isIdentifierStart(e4) ? this.scanIdentifier() : 40 === e4 || 41 === e4 || 59 === e4 ? this.scanPunctuator() : 39 === e4 || 34 === e4 ? this.scanStringLiteral() : 46 === e4 ? i.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : i.Character.isDecimalDigit(e4) ? this.scanNumericLiteral() : 96 === e4 || 125 === e4 && "${" === this.curlyStack[this.curlyStack.length - 1] ? this.scanTemplate() : e4 >= 55296 && e4 < 57343 && i.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
              }, e3;
            }();
            t2.Scanner = u;
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.TokenName = {}, t2.TokenName[1] = "Boolean", t2.TokenName[2] = "<end>", t2.TokenName[3] = "Identifier", t2.TokenName[4] = "Keyword", t2.TokenName[5] = "Null", t2.TokenName[6] = "Numeric", t2.TokenName[7] = "Punctuator", t2.TokenName[8] = "String", t2.TokenName[9] = "RegularExpression", t2.TokenName[10] = "Template";
          }, function(e2, t2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.XHTMLEntities = { quot: '"', amp: "&", apos: "'", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666", lang: "\u27E8", rang: "\u27E9" };
          }, function(e2, t2, r2) {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n2 = r2(10), i = r2(12), o = r2(13), a = function() {
              function e3() {
                this.values = [], this.curly = this.paren = -1;
              }
              return e3.prototype.beforeFunctionExpression = function(e4) {
                return ["(", "{", "[", "in", "typeof", "instanceof", "new", "return", "case", "delete", "throw", "void", "=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ",", "+", "-", "*", "**", "/", "%", "++", "--", "<<", ">>", ">>>", "&", "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!=="].indexOf(e4) >= 0;
              }, e3.prototype.isRegexStart = function() {
                var e4 = this.values[this.values.length - 1], t3 = null !== e4;
                switch (e4) {
                  case "this":
                  case "]":
                    t3 = false;
                    break;
                  case ")":
                    var r3 = this.values[this.paren - 1];
                    t3 = "if" === r3 || "while" === r3 || "for" === r3 || "with" === r3;
                    break;
                  case "}":
                    if (t3 = false, "function" === this.values[this.curly - 3])
                      t3 = !!(n3 = this.values[this.curly - 4]) && !this.beforeFunctionExpression(n3);
                    else if ("function" === this.values[this.curly - 4]) {
                      var n3;
                      t3 = !(n3 = this.values[this.curly - 5]) || !this.beforeFunctionExpression(n3);
                    }
                }
                return t3;
              }, e3.prototype.push = function(e4) {
                7 === e4.type || 4 === e4.type ? ("{" === e4.value ? this.curly = this.values.length : "(" === e4.value && (this.paren = this.values.length), this.values.push(e4.value)) : this.values.push(null);
              }, e3;
            }(), s = function() {
              function e3(e4, t3) {
                this.errorHandler = new n2.ErrorHandler(), this.errorHandler.tolerant = !!t3 && "boolean" == typeof t3.tolerant && t3.tolerant, this.scanner = new i.Scanner(e4, this.errorHandler), this.scanner.trackComment = !!t3 && "boolean" == typeof t3.comment && t3.comment, this.trackRange = !!t3 && "boolean" == typeof t3.range && t3.range, this.trackLoc = !!t3 && "boolean" == typeof t3.loc && t3.loc, this.buffer = [], this.reader = new a();
              }
              return e3.prototype.errors = function() {
                return this.errorHandler.errors;
              }, e3.prototype.getNextToken = function() {
                if (0 === this.buffer.length) {
                  var e4 = this.scanner.scanComments();
                  if (this.scanner.trackComment)
                    for (var t3 = 0; t3 < e4.length; ++t3) {
                      var r3 = e4[t3], n3 = this.scanner.source.slice(r3.slice[0], r3.slice[1]), i2 = { type: r3.multiLine ? "BlockComment" : "LineComment", value: n3 };
                      this.trackRange && (i2.range = r3.range), this.trackLoc && (i2.loc = r3.loc), this.buffer.push(i2);
                    }
                  if (!this.scanner.eof()) {
                    var a2 = void 0;
                    this.trackLoc && (a2 = { start: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, end: {} });
                    var s2 = "/" === this.scanner.source[this.scanner.index] && this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.lex();
                    this.reader.push(s2);
                    var u = { type: o.TokenName[s2.type], value: this.scanner.source.slice(s2.start, s2.end) };
                    if (this.trackRange && (u.range = [s2.start, s2.end]), this.trackLoc && (a2.end = { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, u.loc = a2), 9 === s2.type) {
                      var l = s2.pattern, c = s2.flags;
                      u.regex = { pattern: l, flags: c };
                    }
                    this.buffer.push(u);
                  }
                }
                return this.buffer.shift();
              }, e3;
            }();
            t2.Tokenizer = s;
          }]);
        }, e.exports = n();
      }, function(e, t, r) {
        "use strict";
        var n = r(38), i = r(53), o = r(76), a = r(54), s = Object.prototype.toString, u = Object.prototype.hasOwnProperty, l = { 0: "\\0", 7: "\\a", 8: "\\b", 9: "\\t", 10: "\\n", 11: "\\v", 12: "\\f", 13: "\\r", 27: "\\e", 34: '\\"', 92: "\\\\", 133: "\\N", 160: "\\_", 8232: "\\L", 8233: "\\P" }, c = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"];
        function h(e2) {
          var t2, r2, o2;
          if (t2 = e2.toString(16).toUpperCase(), e2 <= 255)
            r2 = "x", o2 = 2;
          else if (e2 <= 65535)
            r2 = "u", o2 = 4;
          else {
            if (!(e2 <= 4294967295))
              throw new i("code point within a string may not be greater than 0xFFFFFFFF");
            r2 = "U", o2 = 8;
          }
          return "\\" + r2 + n.repeat("0", o2 - t2.length) + t2;
        }
        function p(e2) {
          this.schema = e2.schema || o, this.indent = Math.max(1, e2.indent || 2), this.noArrayIndent = e2.noArrayIndent || false, this.skipInvalid = e2.skipInvalid || false, this.flowLevel = n.isNothing(e2.flowLevel) ? -1 : e2.flowLevel, this.styleMap = function(e3, t2) {
            var r2, n2, i2, o2, a2, s2, l2;
            if (null === t2)
              return {};
            for (r2 = {}, i2 = 0, o2 = (n2 = Object.keys(t2)).length; i2 < o2; i2 += 1)
              a2 = n2[i2], s2 = String(t2[a2]), "!!" === a2.slice(0, 2) && (a2 = "tag:yaml.org,2002:" + a2.slice(2)), (l2 = e3.compiledTypeMap.fallback[a2]) && u.call(l2.styleAliases, s2) && (s2 = l2.styleAliases[s2]), r2[a2] = s2;
            return r2;
          }(this.schema, e2.styles || null), this.sortKeys = e2.sortKeys || false, this.lineWidth = e2.lineWidth || 80, this.noRefs = e2.noRefs || false, this.noCompatMode = e2.noCompatMode || false, this.condenseFlow = e2.condenseFlow || false, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
        }
        function f(e2, t2) {
          for (var r2, i2 = n.repeat(" ", t2), o2 = 0, a2 = -1, s2 = "", u2 = e2.length; o2 < u2; )
            -1 === (a2 = e2.indexOf("\n", o2)) ? (r2 = e2.slice(o2), o2 = u2) : (r2 = e2.slice(o2, a2 + 1), o2 = a2 + 1), r2.length && "\n" !== r2 && (s2 += i2), s2 += r2;
          return s2;
        }
        function d(e2, t2) {
          return "\n" + n.repeat(" ", e2.indent * t2);
        }
        function m(e2) {
          return 32 === e2 || 9 === e2;
        }
        function y(e2) {
          return 32 <= e2 && e2 <= 126 || 161 <= e2 && e2 <= 55295 && 8232 !== e2 && 8233 !== e2 || 57344 <= e2 && e2 <= 65533 && 65279 !== e2 || 65536 <= e2 && e2 <= 1114111;
        }
        function v(e2, t2) {
          return y(e2) && 65279 !== e2 && 44 !== e2 && 91 !== e2 && 93 !== e2 && 123 !== e2 && 125 !== e2 && 58 !== e2 && (35 !== e2 || t2 && function(e3) {
            return y(e3) && !m(e3) && 65279 !== e3 && 13 !== e3 && 10 !== e3;
          }(t2));
        }
        function _(e2) {
          return /^\n* /.test(e2);
        }
        function g(e2, t2, r2, n2, i2) {
          var o2, a2, s2, u2, l2 = false, c2 = false, h2 = -1 !== n2, p2 = -1, f2 = y(u2 = e2.charCodeAt(0)) && 65279 !== u2 && !m(u2) && 45 !== u2 && 63 !== u2 && 58 !== u2 && 44 !== u2 && 91 !== u2 && 93 !== u2 && 123 !== u2 && 125 !== u2 && 35 !== u2 && 38 !== u2 && 42 !== u2 && 33 !== u2 && 124 !== u2 && 61 !== u2 && 62 !== u2 && 39 !== u2 && 34 !== u2 && 37 !== u2 && 64 !== u2 && 96 !== u2 && !m(e2.charCodeAt(e2.length - 1));
          if (t2)
            for (o2 = 0; o2 < e2.length; o2++) {
              if (!y(a2 = e2.charCodeAt(o2)))
                return 5;
              s2 = o2 > 0 ? e2.charCodeAt(o2 - 1) : null, f2 = f2 && v(a2, s2);
            }
          else {
            for (o2 = 0; o2 < e2.length; o2++) {
              if (10 === (a2 = e2.charCodeAt(o2)))
                l2 = true, h2 && (c2 = c2 || o2 - p2 - 1 > n2 && " " !== e2[p2 + 1], p2 = o2);
              else if (!y(a2))
                return 5;
              s2 = o2 > 0 ? e2.charCodeAt(o2 - 1) : null, f2 = f2 && v(a2, s2);
            }
            c2 = c2 || h2 && o2 - p2 - 1 > n2 && " " !== e2[p2 + 1];
          }
          return l2 || c2 ? r2 > 9 && _(e2) ? 5 : c2 ? 4 : 3 : f2 && !i2(e2) ? 1 : 2;
        }
        function b(e2, t2, r2, n2) {
          e2.dump = function() {
            if (0 === t2.length)
              return "''";
            if (!e2.noCompatMode && -1 !== c.indexOf(t2))
              return "'" + t2 + "'";
            var o2 = e2.indent * Math.max(1, r2), a2 = -1 === e2.lineWidth ? -1 : Math.max(Math.min(e2.lineWidth, 40), e2.lineWidth - o2), s2 = n2 || e2.flowLevel > -1 && r2 >= e2.flowLevel;
            switch (g(t2, s2, e2.indent, a2, function(t3) {
              return function(e3, t4) {
                var r3, n3;
                for (r3 = 0, n3 = e3.implicitTypes.length; r3 < n3; r3 += 1)
                  if (e3.implicitTypes[r3].resolve(t4))
                    return true;
                return false;
              }(e2, t3);
            })) {
              case 1:
                return t2;
              case 2:
                return "'" + t2.replace(/'/g, "''") + "'";
              case 3:
                return "|" + x(t2, e2.indent) + w(f(t2, o2));
              case 4:
                return ">" + x(t2, e2.indent) + w(f(function(e3, t3) {
                  var r3, n3, i2 = /(\n+)([^\n]*)/g, o3 = (s3 = e3.indexOf("\n"), s3 = -1 !== s3 ? s3 : e3.length, i2.lastIndex = s3, E(e3.slice(0, s3), t3)), a3 = "\n" === e3[0] || " " === e3[0];
                  var s3;
                  for (; n3 = i2.exec(e3); ) {
                    var u2 = n3[1], l2 = n3[2];
                    r3 = " " === l2[0], o3 += u2 + (a3 || r3 || "" === l2 ? "" : "\n") + E(l2, t3), a3 = r3;
                  }
                  return o3;
                }(t2, a2), o2));
              case 5:
                return '"' + function(e3) {
                  for (var t3, r3, n3, i2 = "", o3 = 0; o3 < e3.length; o3++)
                    (t3 = e3.charCodeAt(o3)) >= 55296 && t3 <= 56319 && (r3 = e3.charCodeAt(o3 + 1)) >= 56320 && r3 <= 57343 ? (i2 += h(1024 * (t3 - 55296) + r3 - 56320 + 65536), o3++) : (n3 = l[t3], i2 += !n3 && y(t3) ? e3[o3] : n3 || h(t3));
                  return i2;
                }(t2) + '"';
              default:
                throw new i("impossible error: invalid scalar style");
            }
          }();
        }
        function x(e2, t2) {
          var r2 = _(e2) ? String(t2) : "", n2 = "\n" === e2[e2.length - 1];
          return r2 + (n2 && ("\n" === e2[e2.length - 2] || "\n" === e2) ? "+" : n2 ? "" : "-") + "\n";
        }
        function w(e2) {
          return "\n" === e2[e2.length - 1] ? e2.slice(0, -1) : e2;
        }
        function E(e2, t2) {
          if ("" === e2 || " " === e2[0])
            return e2;
          for (var r2, n2, i2 = / [^ ]/g, o2 = 0, a2 = 0, s2 = 0, u2 = ""; r2 = i2.exec(e2); )
            (s2 = r2.index) - o2 > t2 && (n2 = a2 > o2 ? a2 : s2, u2 += "\n" + e2.slice(o2, n2), o2 = n2 + 1), a2 = s2;
          return u2 += "\n", e2.length - o2 > t2 && a2 > o2 ? u2 += e2.slice(o2, a2) + "\n" + e2.slice(a2 + 1) : u2 += e2.slice(o2), u2.slice(1);
        }
        function D(e2, t2, r2) {
          var n2, o2, a2, l2, c2, h2;
          for (a2 = 0, l2 = (o2 = r2 ? e2.explicitTypes : e2.implicitTypes).length; a2 < l2; a2 += 1)
            if (((c2 = o2[a2]).instanceOf || c2.predicate) && (!c2.instanceOf || "object" == typeof t2 && t2 instanceof c2.instanceOf) && (!c2.predicate || c2.predicate(t2))) {
              if (e2.tag = r2 ? c2.tag : "?", c2.represent) {
                if (h2 = e2.styleMap[c2.tag] || c2.defaultStyle, "[object Function]" === s.call(c2.represent))
                  n2 = c2.represent(t2, h2);
                else {
                  if (!u.call(c2.represent, h2))
                    throw new i("!<" + c2.tag + '> tag resolver accepts not "' + h2 + '" style');
                  n2 = c2.represent[h2](t2, h2);
                }
                e2.dump = n2;
              }
              return true;
            }
          return false;
        }
        function S(e2, t2, r2, n2, o2, a2) {
          e2.tag = null, e2.dump = r2, D(e2, r2, false) || D(e2, r2, true);
          var u2 = s.call(e2.dump);
          n2 && (n2 = e2.flowLevel < 0 || e2.flowLevel > t2);
          var l2, c2, h2 = "[object Object]" === u2 || "[object Array]" === u2;
          if (h2 && (c2 = -1 !== (l2 = e2.duplicates.indexOf(r2))), (null !== e2.tag && "?" !== e2.tag || c2 || 2 !== e2.indent && t2 > 0) && (o2 = false), c2 && e2.usedDuplicates[l2])
            e2.dump = "*ref_" + l2;
          else {
            if (h2 && c2 && !e2.usedDuplicates[l2] && (e2.usedDuplicates[l2] = true), "[object Object]" === u2)
              n2 && 0 !== Object.keys(e2.dump).length ? (!function(e3, t3, r3, n3) {
                var o3, a3, s2, u3, l3, c3, h3 = "", p3 = e3.tag, f2 = Object.keys(r3);
                if (true === e3.sortKeys)
                  f2.sort();
                else if ("function" == typeof e3.sortKeys)
                  f2.sort(e3.sortKeys);
                else if (e3.sortKeys)
                  throw new i("sortKeys must be a boolean or a function");
                for (o3 = 0, a3 = f2.length; o3 < a3; o3 += 1)
                  c3 = "", n3 && 0 === o3 || (c3 += d(e3, t3)), u3 = r3[s2 = f2[o3]], S(e3, t3 + 1, s2, true, true, true) && ((l3 = null !== e3.tag && "?" !== e3.tag || e3.dump && e3.dump.length > 1024) && (e3.dump && 10 === e3.dump.charCodeAt(0) ? c3 += "?" : c3 += "? "), c3 += e3.dump, l3 && (c3 += d(e3, t3)), S(e3, t3 + 1, u3, true, l3) && (e3.dump && 10 === e3.dump.charCodeAt(0) ? c3 += ":" : c3 += ": ", h3 += c3 += e3.dump));
                e3.tag = p3, e3.dump = h3 || "{}";
              }(e2, t2, e2.dump, o2), c2 && (e2.dump = "&ref_" + l2 + e2.dump)) : (!function(e3, t3, r3) {
                var n3, i2, o3, a3, s2, u3 = "", l3 = e3.tag, c3 = Object.keys(r3);
                for (n3 = 0, i2 = c3.length; n3 < i2; n3 += 1)
                  s2 = "", 0 !== n3 && (s2 += ", "), e3.condenseFlow && (s2 += '"'), a3 = r3[o3 = c3[n3]], S(e3, t3, o3, false, false) && (e3.dump.length > 1024 && (s2 += "? "), s2 += e3.dump + (e3.condenseFlow ? '"' : "") + ":" + (e3.condenseFlow ? "" : " "), S(e3, t3, a3, false, false) && (u3 += s2 += e3.dump));
                e3.tag = l3, e3.dump = "{" + u3 + "}";
              }(e2, t2, e2.dump), c2 && (e2.dump = "&ref_" + l2 + " " + e2.dump));
            else if ("[object Array]" === u2) {
              var p2 = e2.noArrayIndent && t2 > 0 ? t2 - 1 : t2;
              n2 && 0 !== e2.dump.length ? (!function(e3, t3, r3, n3) {
                var i2, o3, a3 = "", s2 = e3.tag;
                for (i2 = 0, o3 = r3.length; i2 < o3; i2 += 1)
                  S(e3, t3 + 1, r3[i2], true, true) && (n3 && 0 === i2 || (a3 += d(e3, t3)), e3.dump && 10 === e3.dump.charCodeAt(0) ? a3 += "-" : a3 += "- ", a3 += e3.dump);
                e3.tag = s2, e3.dump = a3 || "[]";
              }(e2, p2, e2.dump, o2), c2 && (e2.dump = "&ref_" + l2 + e2.dump)) : (!function(e3, t3, r3) {
                var n3, i2, o3 = "", a3 = e3.tag;
                for (n3 = 0, i2 = r3.length; n3 < i2; n3 += 1)
                  S(e3, t3, r3[n3], false, false) && (0 !== n3 && (o3 += "," + (e3.condenseFlow ? "" : " ")), o3 += e3.dump);
                e3.tag = a3, e3.dump = "[" + o3 + "]";
              }(e2, p2, e2.dump), c2 && (e2.dump = "&ref_" + l2 + " " + e2.dump));
            } else {
              if ("[object String]" !== u2) {
                if (e2.skipInvalid)
                  return false;
                throw new i("unacceptable kind of an object to dump " + u2);
              }
              "?" !== e2.tag && b(e2, e2.dump, t2, a2);
            }
            null !== e2.tag && "?" !== e2.tag && (e2.dump = "!<" + e2.tag + "> " + e2.dump);
          }
          return true;
        }
        function C(e2, t2) {
          var r2, n2, i2 = [], o2 = [];
          for (function e3(t3, r3, n3) {
            var i3, o3, a2;
            if (null !== t3 && "object" == typeof t3)
              if (-1 !== (o3 = r3.indexOf(t3)))
                -1 === n3.indexOf(o3) && n3.push(o3);
              else if (r3.push(t3), Array.isArray(t3))
                for (o3 = 0, a2 = t3.length; o3 < a2; o3 += 1)
                  e3(t3[o3], r3, n3);
              else
                for (i3 = Object.keys(t3), o3 = 0, a2 = i3.length; o3 < a2; o3 += 1)
                  e3(t3[i3[o3]], r3, n3);
          }(e2, i2, o2), r2 = 0, n2 = o2.length; r2 < n2; r2 += 1)
            t2.duplicates.push(i2[o2[r2]]);
          t2.usedDuplicates = new Array(n2);
        }
        function A(e2, t2) {
          var r2 = new p(t2 = t2 || {});
          return r2.noRefs || C(e2, r2), S(r2, 0, e2, true, true) ? r2.dump + "\n" : "";
        }
        e.exports.dump = A, e.exports.safeDump = function(e2, t2) {
          return A(e2, n.extend({ schema: a }, t2));
        };
      }, function(e, t, r) {
        "use strict";
        r(31), r(32), r(33), r(64), r(19), r(65), r(20), r(68), r(92), r(144), r(22), r(94), r(23);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        }), o = this && this.__values || function(e2) {
          var t2 = "function" == typeof Symbol && Symbol.iterator, r2 = t2 && e2[t2], n2 = 0;
          if (r2)
            return r2.call(e2);
          if (e2 && "number" == typeof e2.length)
            return { next: function() {
              return e2 && n2 >= e2.length && (e2 = void 0), { value: e2 && e2[n2++], done: !e2 };
            } };
          throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }, a = this && this.__read || function(e2, t2) {
          var r2 = "function" == typeof Symbol && e2[Symbol.iterator];
          if (!r2)
            return e2;
          var n2, i2, o2 = r2.call(e2), a2 = [];
          try {
            for (; (void 0 === t2 || t2-- > 0) && !(n2 = o2.next()).done; )
              a2.push(n2.value);
          } catch (e3) {
            i2 = { error: e3 };
          } finally {
            try {
              n2 && !n2.done && (r2 = o2.return) && r2.call(o2);
            } finally {
              if (i2)
                throw i2.error;
            }
          }
          return a2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        var s = r(91), u = r(2), l = r(183), c = r(0), h = r(7), p = r(95), f = r(69), d = r(3), m = r(306), y = r(307), v = r(308), _ = function(e2) {
          function t2(t3, r2) {
            void 0 === r2 && (r2 = false);
            var n2 = e2.call(this) || this;
            return n2._hasDeclaration = false, n2._docTypeName = "", n2._hasDocumentElement = false, n2._currentElementSerialized = false, n2._openTags = [], n2._ended = false, n2._fragment = r2, n2._options = u.applyDefaults(t3 || {}, s.DefaultXMLBuilderCBOptions), n2._builderOptions = { defaultNamespace: n2._options.defaultNamespace, namespaceAlias: n2._options.namespaceAlias }, "json" === n2._options.format ? n2._writer = new y.JSONCBWriter(n2._options) : "yaml" === n2._options.format ? n2._writer = new v.YAMLCBWriter(n2._options) : n2._writer = new m.XMLCBWriter(n2._options), void 0 !== n2._options.data && n2.on("data", n2._options.data), void 0 !== n2._options.end && n2.on("end", n2._options.end), void 0 !== n2._options.error && n2.on("error", n2._options.error), n2._prefixMap = new p.NamespacePrefixMap(), n2._prefixMap.set("xml", h.namespace.XML), n2._prefixIndex = { value: 1 }, n2._push(n2._writer.frontMatter()), n2;
          }
          return i(t2, e2), t2.prototype.ele = function(e3, t3, r2) {
            var n2, i2;
            if (u.isObject(e3) || u.isString(e3) && (/^\s*</.test(e3) || /^\s*[\{\[]/.test(e3) || /^(\s*|(#.*)|(%.*))*---/.test(e3))) {
              var a2 = l.fragment().set(this._options);
              try {
                a2.ele(e3);
              } catch (e4) {
                return this.emit("error", e4), this;
              }
              try {
                for (var s2 = o(a2.node.childNodes), c2 = s2.next(); !c2.done; c2 = s2.next()) {
                  var h2 = c2.value;
                  this._fromNode(h2);
                }
              } catch (e4) {
                n2 = { error: e4 };
              } finally {
                try {
                  c2 && !c2.done && (i2 = s2.return) && i2.call(s2);
                } finally {
                  if (n2)
                    throw n2.error;
                }
              }
              return this;
            }
            if (this._serializeOpenTag(true), !this._fragment && this._hasDocumentElement && 0 === this._writer.level)
              return this.emit("error", new Error("Document cannot have multiple document element nodes.")), this;
            try {
              this._currentElement = l.fragment(this._builderOptions).ele(e3, t3, r2);
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._fragment || this._hasDocumentElement || "" === this._docTypeName || this._currentElement.node._qualifiedName === this._docTypeName ? (this._currentElementSerialized = false, this._fragment || (this._hasDocumentElement = true), this) : (this.emit("error", new Error("Document element name does not match DocType declaration name.")), this);
          }, t2.prototype.att = function(e3, t3, r2) {
            if (void 0 === this._currentElement)
              return this.emit("error", new Error("Cannot insert an attribute node as child of a document node.")), this;
            try {
              this._currentElement.att(e3, t3, r2);
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this;
          }, t2.prototype.com = function(e3) {
            var t3;
            this._serializeOpenTag(true);
            try {
              t3 = l.fragment(this._builderOptions).com(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return !this._options.wellFormed || c.xml_isLegalChar(t3.data) && -1 === t3.data.indexOf("--") && !t3.data.endsWith("-") ? (this._push(this._writer.comment(t3.data)), this) : (this.emit("error", new Error("Comment data contains invalid characters (well-formed required).")), this);
          }, t2.prototype.txt = function(e3) {
            if (!this._fragment && void 0 === this._currentElement)
              return this.emit("error", new Error("Cannot insert a text node as child of a document node.")), this;
            var t3;
            this._serializeOpenTag(true);
            try {
              t3 = l.fragment(this._builderOptions).txt(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            if (this._options.wellFormed && !c.xml_isLegalChar(t3.data))
              return this.emit("error", new Error("Text data contains invalid characters (well-formed required).")), this;
            var r2 = t3.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            return this._push(this._writer.text(r2)), this;
          }, t2.prototype.ins = function(e3, t3) {
            var r2;
            void 0 === t3 && (t3 = ""), this._serializeOpenTag(true);
            try {
              r2 = l.fragment(this._builderOptions).ins(e3, t3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._options.wellFormed && (-1 !== r2.target.indexOf(":") || /^xml$/i.test(r2.target)) ? (this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required).")), this) : this._options.wellFormed && !c.xml_isLegalChar(r2.data) ? (this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required).")), this) : (this._push(this._writer.instruction(r2.target, r2.data)), this);
          }, t2.prototype.dat = function(e3) {
            var t3;
            this._serializeOpenTag(true);
            try {
              t3 = l.fragment(this._builderOptions).dat(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._push(this._writer.cdata(t3.data)), this;
          }, t2.prototype.dec = function(e3) {
            return void 0 === e3 && (e3 = { version: "1.0" }), this._fragment ? (this.emit("error", Error("Cannot insert an XML declaration into a document fragment.")), this) : this._hasDeclaration ? (this.emit("error", Error("XML declaration is already inserted.")), this) : (this._push(this._writer.declaration(e3.version || "1.0", e3.encoding, e3.standalone)), this._hasDeclaration = true, this);
          }, t2.prototype.dtd = function(e3) {
            if (this._fragment)
              return this.emit("error", Error("Cannot insert a DocType declaration into a document fragment.")), this;
            if ("" !== this._docTypeName)
              return this.emit("error", new Error("DocType declaration is already inserted.")), this;
            if (this._hasDocumentElement)
              return this.emit("error", new Error("Cannot insert DocType declaration after document element.")), this;
            var t3;
            try {
              t3 = l.create().dtd(e3).first().node;
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            return this._options.wellFormed && !c.xml_isPubidChar(t3.publicId) ? (this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required).")), this) : this._options.wellFormed && (!c.xml_isLegalChar(t3.systemId) || -1 !== t3.systemId.indexOf('"') && -1 !== t3.systemId.indexOf("'")) ? (this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required).")), this) : (this._docTypeName = e3.name, this._push(this._writer.docType(e3.name, t3.publicId, t3.systemId)), this);
          }, t2.prototype.import = function(e3) {
            var t3, r2, n2 = l.fragment().set(this._options);
            try {
              n2.import(e3);
            } catch (e4) {
              return this.emit("error", e4), this;
            }
            try {
              for (var i2 = o(n2.node.childNodes), a2 = i2.next(); !a2.done; a2 = i2.next()) {
                var s2 = a2.value;
                this._fromNode(s2);
              }
            } catch (e4) {
              t3 = { error: e4 };
            } finally {
              try {
                a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
              } finally {
                if (t3)
                  throw t3.error;
              }
            }
            return this;
          }, t2.prototype.up = function() {
            return this._serializeOpenTag(false), this._serializeCloseTag(), this;
          }, t2.prototype.end = function() {
            for (this._serializeOpenTag(false); this._openTags.length > 0; )
              this._serializeCloseTag();
            return this._push(null), this;
          }, t2.prototype._serializeOpenTag = function(e3) {
            if (!this._currentElementSerialized && void 0 !== this._currentElement) {
              var r2 = this._currentElement.node;
              if (!this._options.wellFormed || -1 === r2.localName.indexOf(":") && c.xml_isName(r2.localName)) {
                var n2 = "", i2 = false, o2 = this._prefixMap.copy(), a2 = {}, s2 = this._recordNamespaceInformation(r2, o2, a2), u2 = 0 === this._openTags.length ? null : this._openTags[this._openTags.length - 1][1], l2 = r2.namespaceURI;
                if (null === l2 && (l2 = u2), u2 === l2)
                  null !== s2 && (i2 = true), n2 = l2 === h.namespace.XML ? "xml:" + r2.localName : r2.localName, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2));
                else {
                  var p2 = r2.prefix, f2 = null;
                  if (null === p2 && l2 === s2 || (f2 = o2.get(p2, l2)), "xmlns" === p2) {
                    if (this._options.wellFormed)
                      return void this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
                    f2 = p2;
                  }
                  null !== f2 ? (n2 = f2 + ":" + r2.localName, null !== s2 && s2 !== h.namespace.XML && (u2 = s2 || null), this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2))) : null !== p2 ? (p2 in a2 && (p2 = this._generatePrefix(l2, o2, this._prefixIndex)), o2.set(p2, l2), n2 += p2 + ":" + r2.localName, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2)), this._push(this._writer.attribute("xmlns:" + p2, this._serializeAttributeValue(l2, this._options.wellFormed))), null !== s2 && (u2 = s2 || null)) : null === s2 || null !== s2 && s2 !== l2 ? (i2 = true, n2 += r2.localName, u2 = l2, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2)), this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(l2, this._options.wellFormed)))) : (n2 += r2.localName, u2 = l2, this._writer.beginElement(n2), this._push(this._writer.openTagBegin(n2)));
                }
                this._serializeAttributes(r2, o2, this._prefixIndex, a2, i2, this._options.wellFormed);
                var d2 = l2 === h.namespace.HTML;
                d2 && !e3 && t2._VoidElementNames.has(r2.localName) ? (this._push(this._writer.openTagEnd(n2, true, true)), this._writer.endElement(n2)) : d2 || e3 ? this._push(this._writer.openTagEnd(n2, false, false)) : (this._push(this._writer.openTagEnd(n2, true, false)), this._writer.endElement(n2)), this._currentElementSerialized = true, this._openTags.push([n2, u2, this._prefixMap, e3]), this._isPrefixMapModified(this._prefixMap, o2) && (this._prefixMap = o2), this._writer.level++;
              } else
                this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
            }
          }, t2.prototype._serializeCloseTag = function() {
            this._writer.level--;
            var e3 = this._openTags.pop();
            if (void 0 !== e3) {
              var t3 = a(e3, 4), r2 = t3[0], n2 = (t3[1], t3[2]), i2 = t3[3];
              this._prefixMap = n2, i2 && (this._push(this._writer.closeTag(r2)), this._writer.endElement(r2));
            } else
              this.emit("error", new Error("Last element is undefined."));
          }, t2.prototype._push = function(e3) {
            null === e3 ? (this._ended = true, this.emit("end")) : this._ended ? this.emit("error", new Error("Cannot push to ended stream.")) : 0 !== e3.length && (this._writer.hasData = true, this.emit("data", e3, this._writer.level));
          }, t2.prototype._fromNode = function(e3) {
            var t3, r2, n2, i2;
            if (d.Guard.isElementNode(e3)) {
              var a2 = e3.prefix ? e3.prefix + ":" + e3.localName : e3.localName;
              null !== e3.namespaceURI ? this.ele(e3.namespaceURI, a2) : this.ele(a2);
              try {
                for (var s2 = o(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                  var l2 = u2.value, c2 = l2.prefix ? l2.prefix + ":" + l2.localName : l2.localName;
                  null !== l2.namespaceURI ? this.att(l2.namespaceURI, c2, l2.value) : this.att(c2, l2.value);
                }
              } catch (e4) {
                t3 = { error: e4 };
              } finally {
                try {
                  u2 && !u2.done && (r2 = s2.return) && r2.call(s2);
                } finally {
                  if (t3)
                    throw t3.error;
                }
              }
              try {
                for (var h2 = o(e3.childNodes), p2 = h2.next(); !p2.done; p2 = h2.next()) {
                  var f2 = p2.value;
                  this._fromNode(f2);
                }
              } catch (e4) {
                n2 = { error: e4 };
              } finally {
                try {
                  p2 && !p2.done && (i2 = h2.return) && i2.call(h2);
                } finally {
                  if (n2)
                    throw n2.error;
                }
              }
              this.up();
            } else
              d.Guard.isExclusiveTextNode(e3) && e3.data ? this.txt(e3.data) : d.Guard.isCommentNode(e3) ? this.com(e3.data) : d.Guard.isCDATASectionNode(e3) ? this.dat(e3.data) : d.Guard.isProcessingInstructionNode(e3) && this.ins(e3.target, e3.data);
          }, t2.prototype._serializeAttributes = function(e3, t3, r2, n2, i2, a2) {
            var s2, u2, l2 = a2 ? new f.LocalNameSet() : void 0;
            try {
              for (var p2 = o(e3.attributes), d2 = p2.next(); !d2.done; d2 = p2.next()) {
                var m2 = d2.value;
                if (a2 || i2 || null !== m2.namespaceURI) {
                  if (a2 && l2 && l2.has(m2.namespaceURI, m2.localName))
                    return void this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
                  a2 && l2 && l2.set(m2.namespaceURI, m2.localName);
                  var y2 = m2.namespaceURI, v2 = null;
                  if (null !== y2)
                    if (v2 = t3.get(m2.prefix, y2), y2 === h.namespace.XMLNS) {
                      if (m2.value === h.namespace.XML || null === m2.prefix && i2 || null !== m2.prefix && (!(m2.localName in n2) || n2[m2.localName] !== m2.value) && t3.has(m2.localName, m2.value))
                        continue;
                      if (a2 && m2.value === h.namespace.XMLNS)
                        return void this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
                      if (a2 && "" === m2.value)
                        return void this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
                      "xmlns" === m2.prefix && (v2 = "xmlns");
                    } else
                      null === v2 && (v2 = null === m2.prefix || t3.hasPrefix(m2.prefix) && !t3.has(m2.prefix, y2) ? this._generatePrefix(y2, t3, r2) : m2.prefix, this._push(this._writer.attribute("xmlns:" + v2, this._serializeAttributeValue(y2, this._options.wellFormed))));
                  if (a2 && (-1 !== m2.localName.indexOf(":") || !c.xml_isName(m2.localName) || "xmlns" === m2.localName && null === y2))
                    return void this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
                  this._push(this._writer.attribute((null !== v2 ? v2 + ":" : "") + m2.localName, this._serializeAttributeValue(m2.value, this._options.wellFormed)));
                } else
                  this._push(this._writer.attribute(m2.localName, this._serializeAttributeValue(m2.value, this._options.wellFormed)));
              }
            } catch (e4) {
              s2 = { error: e4 };
            } finally {
              try {
                d2 && !d2.done && (u2 = p2.return) && u2.call(p2);
              } finally {
                if (s2)
                  throw s2.error;
              }
            }
          }, t2.prototype._serializeAttributeValue = function(e3, t3) {
            return t3 && null !== e3 && !c.xml_isLegalChar(e3) ? (this.emit("error", new Error("Invalid characters in attribute value.")), "") : null === e3 ? "" : e3.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
          }, t2.prototype._recordNamespaceInformation = function(e3, t3, r2) {
            var n2, i2, a2 = null;
            try {
              for (var s2 = o(e3.attributes), u2 = s2.next(); !u2.done; u2 = s2.next()) {
                var l2 = u2.value, c2 = l2.namespaceURI, p2 = l2.prefix;
                if (c2 === h.namespace.XMLNS) {
                  if (null === p2) {
                    a2 = l2.value;
                    continue;
                  }
                  var f2 = l2.localName, d2 = l2.value;
                  if (d2 === h.namespace.XML)
                    continue;
                  if ("" === d2 && (d2 = null), t3.has(f2, d2))
                    continue;
                  t3.set(f2, d2), r2[f2] = d2 || "";
                }
              }
            } catch (e4) {
              n2 = { error: e4 };
            } finally {
              try {
                u2 && !u2.done && (i2 = s2.return) && i2.call(s2);
              } finally {
                if (n2)
                  throw n2.error;
              }
            }
            return a2;
          }, t2.prototype._generatePrefix = function(e3, t3, r2) {
            var n2 = "ns" + r2.value;
            return r2.value++, t3.set(n2, e3), n2;
          }, t2.prototype._isPrefixMapModified = function(e3, t3) {
            var r2 = e3._items, n2 = t3._items, i2 = e3._nullItems, o2 = t3._nullItems;
            for (var a2 in n2) {
              var s2 = r2[a2];
              if (void 0 === s2)
                return true;
              var u2 = n2[a2];
              if (s2.length !== u2.length)
                return true;
              for (var l2 = 0; l2 < s2.length; l2++)
                if (s2[l2] !== u2[l2])
                  return true;
            }
            if (i2.length !== o2.length)
              return true;
            for (l2 = 0; l2 < i2.length; l2++)
              if (i2[l2] !== o2[l2])
                return true;
            return false;
          }, t2._VoidElementNames = /* @__PURE__ */ new Set(["area", "base", "basefont", "bgsound", "br", "col", "embed", "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]), t2;
        }(r(309).EventEmitter);
        t.XMLBuilderCBImpl = _;
      }, function(e, t, r) {
        "use strict";
        r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this, t3) || this;
            return r2._lineLength = 0, r2;
          }
          return i(t2, e2), t2.prototype.frontMatter = function() {
            return "";
          }, t2.prototype.declaration = function(e3, t3, r2) {
            var n2 = this._beginLine() + "<?xml";
            return n2 += ' version="' + e3 + '"', void 0 !== t3 && (n2 += ' encoding="' + t3 + '"'), void 0 !== r2 && (n2 += ' standalone="' + (r2 ? "yes" : "no") + '"'), n2 += "?>";
          }, t2.prototype.docType = function(e3, t3, r2) {
            var n2 = this._beginLine();
            return n2 += t3 && r2 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '" "' + r2 + '">' : t3 ? "<!DOCTYPE " + e3 + ' PUBLIC "' + t3 + '">' : r2 ? "<!DOCTYPE " + e3 + ' SYSTEM "' + r2 + '">' : "<!DOCTYPE " + e3 + ">";
          }, t2.prototype.comment = function(e3) {
            return this._beginLine() + "<!--" + e3 + "-->";
          }, t2.prototype.text = function(e3) {
            return this._beginLine() + e3;
          }, t2.prototype.instruction = function(e3, t3) {
            return t3 ? this._beginLine() + "<?" + e3 + " " + t3 + "?>" : this._beginLine() + "<?" + e3 + "?>";
          }, t2.prototype.cdata = function(e3) {
            return this._beginLine() + "<![CDATA[" + e3 + "]]>";
          }, t2.prototype.openTagBegin = function(e3) {
            return this._lineLength += 1 + e3.length, this._beginLine() + "<" + e3;
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            return r2 ? " />" : t3 ? this._writerOptions.allowEmptyTags ? "></" + e3 + ">" : this._writerOptions.spaceBeforeSlash ? " />" : "/>" : ">";
          }, t2.prototype.closeTag = function(e3) {
            return this._beginLine() + "</" + e3 + ">";
          }, t2.prototype.attribute = function(e3, t3) {
            var r2 = e3 + '="' + t3 + '"';
            return this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._lineLength + 1 + r2.length > this._writerOptions.width ? (r2 = this._beginLine() + this._indent(1) + r2, this._lineLength = r2.length, r2) : (this._lineLength += 1 + r2.length, " " + r2);
          }, t2.prototype.beginElement = function(e3) {
          }, t2.prototype.endElement = function(e3) {
          }, t2.prototype._beginLine = function() {
            if (this._writerOptions.prettyPrint) {
              var e3 = (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level);
              return this._lineLength = e3.length, e3;
            }
            return "";
          }, t2.prototype._indent = function(e3) {
            return e3 <= 0 ? "" : this._writerOptions.indent.repeat(e3);
          }, t2;
        }(r(114).BaseCBWriter);
        t.XMLCBWriter = o;
      }, function(e, t, r) {
        "use strict";
        r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this, t3) || this;
            return r2._hasChildren = [], r2._additionalLevel = 0, r2;
          }
          return i(t2, e2), t2.prototype.frontMatter = function() {
            return "";
          }, t2.prototype.declaration = function(e3, t3, r2) {
            return "";
          }, t2.prototype.docType = function(e3, t3, r2) {
            return "";
          }, t2.prototype.comment = function(e3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.comment) + this._sep() + this._val(e3) + this._sep() + "}";
          }, t2.prototype.text = function(e3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.text) + this._sep() + this._val(e3) + this._sep() + "}";
          }, t2.prototype.instruction = function(e3, t3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.ins) + this._sep() + this._val(t3 ? e3 + " " + t3 : e3) + this._sep() + "}";
          }, t2.prototype.cdata = function(e3) {
            return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.cdata) + this._sep() + this._val(e3) + this._sep() + "}";
          }, t2.prototype.attribute = function(e3, t3) {
            return this._comma() + this._beginLine(1) + "{" + this._sep() + this._key(this._builderOptions.convert.att + e3) + this._sep() + this._val(t3) + this._sep() + "}";
          }, t2.prototype.openTagBegin = function(e3) {
            var t3 = this._comma() + this._beginLine() + "{" + this._sep() + this._key(e3) + this._sep() + "{";
            return this._additionalLevel++, this.hasData = true, t3 += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[", this._hasChildren.push(false), t3;
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            if (t3) {
              var n2 = this._sep() + "]";
              return this._additionalLevel--, n2 += this._beginLine() + "}" + this._sep() + "}";
            }
            return "";
          }, t2.prototype.closeTag = function(e3) {
            var t3 = this._beginLine() + "]";
            return this._additionalLevel--, t3 += this._beginLine() + "}" + this._sep() + "}";
          }, t2.prototype.beginElement = function(e3) {
          }, t2.prototype.endElement = function(e3) {
            this._hasChildren.pop();
          }, t2.prototype._beginLine = function(e3) {
            return void 0 === e3 && (e3 = 0), this._writerOptions.prettyPrint ? (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level + e3) : "";
          }, t2.prototype._indent = function(e3) {
            return e3 + this._additionalLevel <= 0 ? "" : this._writerOptions.indent.repeat(e3 + this._additionalLevel);
          }, t2.prototype._comma = function() {
            var e3 = this._hasChildren[this._hasChildren.length - 1] ? "," : "";
            return this._hasChildren.length > 0 && (this._hasChildren[this._hasChildren.length - 1] = true), e3;
          }, t2.prototype._sep = function() {
            return this._writerOptions.prettyPrint ? " " : "";
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2;
        }(r(114).BaseCBWriter);
        t.JSONCBWriter = o;
      }, function(e, t, r) {
        "use strict";
        r(74);
        var n, i = this && this.__extends || (n = function(e2, t2) {
          return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
            e3.__proto__ = t3;
          } || function(e3, t3) {
            for (var r2 in t3)
              t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
          })(e2, t2);
        }, function(e2, t2) {
          function r2() {
            this.constructor = e2;
          }
          n(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
        });
        Object.defineProperty(t, "__esModule", { value: true });
        var o = function(e2) {
          function t2(t3) {
            var r2 = e2.call(this, t3) || this;
            if (r2._rootWritten = false, r2._additionalLevel = 0, t3.indent.length < 2)
              throw new Error("YAML indententation string must be at least two characters long.");
            if (t3.offset < 0)
              throw new Error("YAML offset should be zero or a positive number.");
            return r2;
          }
          return i(t2, e2), t2.prototype.frontMatter = function() {
            return this._beginLine() + "---";
          }, t2.prototype.declaration = function(e3, t3, r2) {
            return "";
          }, t2.prototype.docType = function(e3, t3, r2) {
            return "";
          }, t2.prototype.comment = function(e3) {
            return this._beginLine() + this._key(this._builderOptions.convert.comment) + " " + this._val(e3);
          }, t2.prototype.text = function(e3) {
            return this._beginLine() + this._key(this._builderOptions.convert.text) + " " + this._val(e3);
          }, t2.prototype.instruction = function(e3, t3) {
            return this._beginLine() + this._key(this._builderOptions.convert.ins) + " " + this._val(t3 ? e3 + " " + t3 : e3);
          }, t2.prototype.cdata = function(e3) {
            return this._beginLine() + this._key(this._builderOptions.convert.cdata) + " " + this._val(e3);
          }, t2.prototype.attribute = function(e3, t3) {
            this._additionalLevel++;
            var r2 = this._beginLine() + this._key(this._builderOptions.convert.att + e3) + " " + this._val(t3);
            return this._additionalLevel--, r2;
          }, t2.prototype.openTagBegin = function(e3) {
            var t3 = this._beginLine() + this._key(e3);
            return this._rootWritten || (this._rootWritten = true), this.hasData = true, this._additionalLevel++, t3 += this._beginLine(true) + this._key(this._builderOptions.convert.text);
          }, t2.prototype.openTagEnd = function(e3, t3, r2) {
            return t3 ? " " + this._val("") : "";
          }, t2.prototype.closeTag = function(e3) {
            return this._additionalLevel--, "";
          }, t2.prototype.beginElement = function(e3) {
          }, t2.prototype.endElement = function(e3) {
          }, t2.prototype._beginLine = function(e3) {
            return void 0 === e3 && (e3 = false), (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level, e3);
          }, t2.prototype._indent = function(e3, t3) {
            if (e3 + this._additionalLevel <= 0)
              return "";
            var r2 = this._writerOptions.indent.repeat(e3 + this._additionalLevel);
            return !t3 && this._rootWritten ? r2.substr(0, r2.length - 2) + "-" + r2.substr(-1, 1) : r2;
          }, t2.prototype._key = function(e3) {
            return '"' + e3 + '":';
          }, t2.prototype._val = function(e3) {
            return JSON.stringify(e3);
          }, t2;
        }(r(114).BaseCBWriter);
        t.YAMLCBWriter = o;
      }, function(e, t, r) {
        "use strict";
        var n, i = "object" == typeof Reflect ? Reflect : null, o = i && "function" == typeof i.apply ? i.apply : function(e2, t2, r2) {
          return Function.prototype.apply.call(e2, t2, r2);
        };
        n = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var a = Number.isNaN || function(e2) {
          return e2 != e2;
        };
        function s() {
          s.init.call(this);
        }
        e.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
        var u = 10;
        function l(e2) {
          if ("function" != typeof e2)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function c(e2) {
          return void 0 === e2._maxListeners ? s.defaultMaxListeners : e2._maxListeners;
        }
        function h(e2, t2, r2, n2) {
          var i2, o2, a2, s2;
          if (l(r2), void 0 === (o2 = e2._events) ? (o2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== o2.newListener && (e2.emit("newListener", t2, r2.listener ? r2.listener : r2), o2 = e2._events), a2 = o2[t2]), void 0 === a2)
            a2 = o2[t2] = r2, ++e2._eventsCount;
          else if ("function" == typeof a2 ? a2 = o2[t2] = n2 ? [r2, a2] : [a2, r2] : n2 ? a2.unshift(r2) : a2.push(r2), (i2 = c(e2)) > 0 && a2.length > i2 && !a2.warned) {
            a2.warned = true;
            var u2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            u2.name = "MaxListenersExceededWarning", u2.emitter = e2, u2.type = t2, u2.count = a2.length, s2 = u2, console && console.warn && console.warn(s2);
          }
          return e2;
        }
        function p() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function f(e2, t2, r2) {
          var n2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: r2 }, i2 = p.bind(n2);
          return i2.listener = r2, n2.wrapFn = i2, i2;
        }
        function d(e2, t2, r2) {
          var n2 = e2._events;
          if (void 0 === n2)
            return [];
          var i2 = n2[t2];
          return void 0 === i2 ? [] : "function" == typeof i2 ? r2 ? [i2.listener || i2] : [i2] : r2 ? function(e3) {
            for (var t3 = new Array(e3.length), r3 = 0; r3 < t3.length; ++r3)
              t3[r3] = e3[r3].listener || e3[r3];
            return t3;
          }(i2) : y(i2, i2.length);
        }
        function m(e2) {
          var t2 = this._events;
          if (void 0 !== t2) {
            var r2 = t2[e2];
            if ("function" == typeof r2)
              return 1;
            if (void 0 !== r2)
              return r2.length;
          }
          return 0;
        }
        function y(e2, t2) {
          for (var r2 = new Array(t2), n2 = 0; n2 < t2; ++n2)
            r2[n2] = e2[n2];
          return r2;
        }
        Object.defineProperty(s, "defaultMaxListeners", { enumerable: true, get: function() {
          return u;
        }, set: function(e2) {
          if ("number" != typeof e2 || e2 < 0 || a(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          u = e2;
        } }), s.init = function() {
          void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, s.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || e2 < 0 || a(e2))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, s.prototype.getMaxListeners = function() {
          return c(this);
        }, s.prototype.emit = function(e2) {
          for (var t2 = [], r2 = 1; r2 < arguments.length; r2++)
            t2.push(arguments[r2]);
          var n2 = "error" === e2, i2 = this._events;
          if (void 0 !== i2)
            n2 = n2 && void 0 === i2.error;
          else if (!n2)
            return false;
          if (n2) {
            var a2;
            if (t2.length > 0 && (a2 = t2[0]), a2 instanceof Error)
              throw a2;
            var s2 = new Error("Unhandled error." + (a2 ? " (" + a2.message + ")" : ""));
            throw s2.context = a2, s2;
          }
          var u2 = i2[e2];
          if (void 0 === u2)
            return false;
          if ("function" == typeof u2)
            o(u2, this, t2);
          else {
            var l2 = u2.length, c2 = y(u2, l2);
            for (r2 = 0; r2 < l2; ++r2)
              o(c2[r2], this, t2);
          }
          return true;
        }, s.prototype.addListener = function(e2, t2) {
          return h(this, e2, t2, false);
        }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(e2, t2) {
          return h(this, e2, t2, true);
        }, s.prototype.once = function(e2, t2) {
          return l(t2), this.on(e2, f(this, e2, t2)), this;
        }, s.prototype.prependOnceListener = function(e2, t2) {
          return l(t2), this.prependListener(e2, f(this, e2, t2)), this;
        }, s.prototype.removeListener = function(e2, t2) {
          var r2, n2, i2, o2, a2;
          if (l(t2), void 0 === (n2 = this._events))
            return this;
          if (void 0 === (r2 = n2[e2]))
            return this;
          if (r2 === t2 || r2.listener === t2)
            0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n2[e2], n2.removeListener && this.emit("removeListener", e2, r2.listener || t2));
          else if ("function" != typeof r2) {
            for (i2 = -1, o2 = r2.length - 1; o2 >= 0; o2--)
              if (r2[o2] === t2 || r2[o2].listener === t2) {
                a2 = r2[o2].listener, i2 = o2;
                break;
              }
            if (i2 < 0)
              return this;
            0 === i2 ? r2.shift() : function(e3, t3) {
              for (; t3 + 1 < e3.length; t3++)
                e3[t3] = e3[t3 + 1];
              e3.pop();
            }(r2, i2), 1 === r2.length && (n2[e2] = r2[0]), void 0 !== n2.removeListener && this.emit("removeListener", e2, a2 || t2);
          }
          return this;
        }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(e2) {
          var t2, r2, n2;
          if (void 0 === (r2 = this._events))
            return this;
          if (void 0 === r2.removeListener)
            return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r2[e2]), this;
          if (0 === arguments.length) {
            var i2, o2 = Object.keys(r2);
            for (n2 = 0; n2 < o2.length; ++n2)
              "removeListener" !== (i2 = o2[n2]) && this.removeAllListeners(i2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t2 = r2[e2]))
            this.removeListener(e2, t2);
          else if (void 0 !== t2)
            for (n2 = t2.length - 1; n2 >= 0; n2--)
              this.removeListener(e2, t2[n2]);
          return this;
        }, s.prototype.listeners = function(e2) {
          return d(this, e2, true);
        }, s.prototype.rawListeners = function(e2) {
          return d(this, e2, false);
        }, s.listenerCount = function(e2, t2) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : m.call(e2, t2);
        }, s.prototype.listenerCount = m, s.prototype.eventNames = function() {
          return this._eventsCount > 0 ? n(this._events) : [];
        };
      }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        var n = r(77);
        t.createCB = function(e2) {
          return new n.XMLBuilderCBImpl(e2);
        }, t.fragmentCB = function(e2) {
          return new n.XMLBuilderCBImpl(e2, true);
        };
      }]);
    });
  }
});

// .wrangler/tmp/bundle-PqeCQB/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/bundle-PqeCQB/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();

// src/index.ts
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/error.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/version.mjs
init_checked_fetch();
init_modules_watch_stub();
var versionInfo = Object.freeze({
  major: 16,
  minor: 8,
  patch: 1,
  preReleaseTag: null
});

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/devAssert.mjs
init_checked_fetch();
init_modules_watch_stub();
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/isPromise.mjs
init_checked_fetch();
init_modules_watch_stub();
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/parser.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/syntaxError.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/GraphQLError.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/isObjectLike.mjs
init_checked_fetch();
init_modules_watch_stub();
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/location.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/invariant.mjs
init_checked_fetch();
init_modules_watch_stub();
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/printLocation.mjs
init_checked_fetch();
init_modules_watch_stub();
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/ast.mjs
init_checked_fetch();
init_modules_watch_stub();
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/directiveLocation.mjs
init_checked_fetch();
init_modules_watch_stub();
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/kinds.mjs
init_checked_fetch();
init_modules_watch_stub();
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/lexer.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/blockString.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/characterClasses.mjs
init_checked_fetch();
init_modules_watch_stub();
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/tokenKind.mjs
init_checked_fetch();
init_modules_watch_stub();
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/source.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/inspect.mjs
init_checked_fetch();
init_modules_watch_stub();
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/instanceOf.mjs
init_checked_fetch();
init_modules_watch_stub();
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
var Parser = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/validate.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/typeComparators.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/definition.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/didYouMean.mjs
init_checked_fetch();
init_modules_watch_stub();
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/identityFunc.mjs
init_checked_fetch();
init_modules_watch_stub();
function identityFunc(x) {
  return x;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/keyMap.mjs
init_checked_fetch();
init_modules_watch_stub();
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/keyValMap.mjs
init_checked_fetch();
init_modules_watch_stub();
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/mapValue.mjs
init_checked_fetch();
init_modules_watch_stub();
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/suggestionList.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/naturalCompare.mjs
init_checked_fetch();
init_modules_watch_stub();
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const aLength = a.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1; i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1; j <= bLength; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j] + 1,
          // delete
          currentRow[j - 1] + 1,
          // insert
          upRow[j - 1] + cost
          // substitute
        );
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/toObjMap.mjs
init_checked_fetch();
init_modules_watch_stub();
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/printer.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/printString.mjs
init_checked_fetch();
init_modules_watch_stub();
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/visitor.mjs
init_checked_fetch();
init_modules_watch_stub();
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i = 0; i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/valueFromASTUntyped.mjs
init_checked_fetch();
init_modules_watch_stub();
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/assertName.mjs
init_checked_fetch();
init_modules_watch_stub();
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(
      this._values.map((enumValue) => [enumValue.value, enumValue])
    );
    this._nameLookup = keyMap(this._values, (value) => value.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema2, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema2.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema2, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema2.getPossibleTypes(typeA).some((type) => schema2.isSubType(typeB, type));
    }
    return schema2.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema2.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/directives.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/scalars.mjs
init_checked_fetch();
init_modules_watch_stub();
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/introspection.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/astFromValue.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/isIterableObject.mjs
init_checked_fetch();
init_modules_watch_stub();
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema2) => schema2.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema2) {
        return Object.values(schema2.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema2) => schema2.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema2) => schema2.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema2) => schema2.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema2) => schema2.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => "name" in type ? type.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type) => (
        /* c8 ignore next */
        "description" in type ? type.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema: schema2 }) {
        if (isAbstractType(type)) {
          return schema2.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => "ofType" in type ? type.ofType : void 0
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema: schema2 }) => schema2,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema: schema2 }) => schema2.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/schema.mjs
init_checked_fetch();
init_modules_watch_stub();
function isSchema(schema2) {
  return instanceOf(schema2, GraphQLSchema);
}
function assertSchema(schema2) {
  if (!isSchema(schema2)) {
    throw new Error(`Expected ${inspect(schema2)} to be a GraphQL schema.`);
  }
  return schema2;
}
var GraphQLSchema = class {
  // Used as a cache for validateSchema().
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : void 0;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(
      false,
      `"types" must be Array if provided but got: ${inspect(config.types)}.`
    );
    !config.directives || Array.isArray(config.directives) || devAssert(
      false,
      `"directives" must be Array if provided but got: ${inspect(config.directives)}.`
    );
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type of config.types) {
        allReferencedTypes.delete(type);
        collectReferencedTypes(type, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = /* @__PURE__ */ Object.create(null);
    this._subTypeMap = /* @__PURE__ */ Object.create(null);
    this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(
        false,
        "One of the provided types for building the Schema is missing a name."
      );
      if (this._typeMap[typeName] !== void 0) {
        throw new Error(
          `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
        );
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== void 0 ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === void 0) {
      map = /* @__PURE__ */ Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type of abstractType.getTypes()) {
          map[type.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type of implementations.objects) {
          map[type.name] = true;
        }
        for (const type of implementations.interfaces) {
          map[type.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== void 0;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0
    };
  }
};
function collectReferencedTypes(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/validate.mjs
function validateSchema(schema2) {
  assertSchema(schema2);
  if (schema2.__validationErrors) {
    return schema2.__validationErrors;
  }
  const context = new SchemaValidationContext(schema2);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema2.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema2) {
  const errors = validateSchema(schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var SchemaValidationContext = class {
  constructor(schema2) {
    this._errors = [];
    this.schema = schema2;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(
      new GraphQLError(message, {
        nodes: _nodes
      })
    );
  }
  getErrors() {
    return this._errors;
  }
};
function validateRootTypes(context) {
  const schema2 = context.schema;
  const queryType = schema2.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema2.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(
      `Query root type must be Object type, it cannot be ${inspect(
        queryType
      )}.`,
      (_getOperationTypeNode = getOperationTypeNode(
        schema2,
        OperationTypeNode.QUERY
      )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
    );
  }
  const mutationType = schema2.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
      (_getOperationTypeNode2 = getOperationTypeNode(
        schema2,
        OperationTypeNode.MUTATION
      )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
    );
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
      (_getOperationTypeNode3 = getOperationTypeNode(
        schema2,
        OperationTypeNode.SUBSCRIPTION
      )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
    );
  }
}
function getOperationTypeNode(schema2, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema2.astNode, ...schema2.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode) => {
      var _schemaNode$operation;
      return (
        /* c8 ignore next */
        (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
      );
    }
  ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(
        `Expected directive but got: ${inspect(directive)}.`,
        directive === null || directive === void 0 ? void 0 : directive.astNode
      );
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(
          `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
          arg.astNode
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(
          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
          ]
        );
      }
    }
  }
}
function validateName(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(
      `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      node.astNode
    );
  }
}
function validateTypes(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(
        `Expected GraphQL named type but got: ${inspect(type)}.`,
        type.astNode
      );
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
}
function validateFields(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(
        `The type of ${type.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
        (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
      );
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(
          `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(
          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
          ]
        );
      }
    }
  }
}
function validateInterfaces(context, type) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(
        `Type ${inspect(type)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (type === iface) {
      context.reportError(
        `Type ${type.name} cannot implement itself because it would create a circular reference.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(
        `Type ${type.name} can only implement ${iface.name} once.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
}
function validateTypeImplementsInterface(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
      );
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type.name}.${fieldName} is type ${inspect(typeField.type)}.`,
        [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
        ]
      );
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
          [ifaceArg.astNode, typeField.astNode]
        );
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
          [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
          ]
        );
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(
          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
          [typeArg.astNode, ifaceField.astNode]
        );
      }
    }
  }
}
function validateTypeImplementsAncestors(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(
        transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
        [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type, iface)
        ]
      );
    }
  }
}
function validateUnionMembers(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(
      `Union type ${union.name} must define one or more member types.`,
      [union.astNode, ...union.extensionASTNodes]
    );
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(
        `Union type ${union.name} can only include type ${memberType.name} once.`,
        getUnionMemberTypeNodes(union, memberType.name)
      );
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(
        `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
        getUnionMemberTypeNodes(union, String(memberType))
      );
    }
  }
}
function validateEnumValues(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(
      `Enum type ${enumType.name} must define one or more values.`,
      [enumType.astNode, ...enumType.extensionASTNodes]
    );
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
}
function validateInputFields(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(
      `Input Object type ${inputObj.name} must define one or more fields.`,
      [inputObj.astNode, ...inputObj.extensionASTNodes]
    );
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(
        `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
      );
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(
        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
        [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
        ]
      );
    }
  }
}
function createInputObjectCircularRefsValidator(context) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(
            `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
            cyclePath.map((fieldObj) => fieldObj.astNode)
          );
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (
      /* c8 ignore next */
      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
    );
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (
      /* c8 ignore next */
      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
    );
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
    (node) => node.name.value === GraphQLDeprecatedDirective.name
  );
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/validate.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/TypeInfo.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/typeFromAST.mjs
init_checked_fetch();
init_modules_watch_stub();
function typeFromAST(schema2, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema2.getType(typeNode.name.value);
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/TypeInfo.mjs
var TypeInfo = class {
  constructor(schema2, initialType, getFieldDefFn) {
    this._schema = schema2;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema2 = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(
          isCompositeType(namedType) ? namedType : void 0
        );
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema2, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema2.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema2.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema2, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema2, node.type);
        this._inputTypeStack.push(
          isInputType(inputType) ? inputType : void 0
        );
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find(
            (arg) => arg.name === node.name.value
          );
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(void 0);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(
          inputField ? inputField.defaultValue : void 0
        );
        this._inputTypeStack.push(
          isInputType(inputFieldType) ? inputFieldType : void 0
        );
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
};
function getFieldDef(schema2, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor, args);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/specifiedRules.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/predicates.mjs
init_checked_fetch();
init_modules_watch_stub();
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema2 = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema2, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema2, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema2.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema2.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema2.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path2, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function KnownTypeNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypesMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type) => type.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/sortValueNode.mjs
init_checked_fetch();
init_modules_watch_stub();
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i]
      );
      for (let j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j = i + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value) {
  return print(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a, b, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a, b, areMutuallyExclusive) {
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const map = this._data.get(key1);
    if (map === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function PossibleTypeExtensionsRule(context) {
  const schema2 = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema2 === null || schema2 === void 0 ? void 0 : schema2.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema2 === null || schema2 === void 0 ? void 0 : schema2.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema2 === null || schema2 === void 0 ? void 0 : schema2.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/collectFields.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/values.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/printPathArray.mjs
init_checked_fetch();
init_modules_watch_stub();
function printPathArray(path) {
  return path.map(
    (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
  ).join("");
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/coerceInputValue.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/Path.mjs
init_checked_fetch();
init_modules_watch_stub();
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, void 0);
}
function defaultOnError(path, invalidValue, error) {
  let errorPrefix2 = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix2 += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix2 + ": " + error.message;
  throw error;
}
function coerceInputValueImpl(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(
      pathToArray(path),
      inputValue,
      new GraphQLError(
        `Expected non-nullable type "${inspect(type)}" not to be null.`
      )
    );
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, void 0);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}" to be an object.`)
      );
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(
              `Field "${field.name}" of required type "${typeStr}" was not provided.`
            )
          );
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(
        fieldValue,
        field.type,
        onError,
        addPath(path, field.name, type.name)
      );
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(
          fieldName,
          Object.keys(type.getFields())
        );
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)
          )
        );
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}". ` + error.message, {
            originalError: error
          })
        );
      }
      return;
    }
    if (parseResult === void 0) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}".`)
      );
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/valueFromAST.mjs
init_checked_fetch();
init_modules_watch_stub();
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/collectFields.mjs
function collectFields(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema2,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema2,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema2, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema2,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema2, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema2,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema2, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema2, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema2.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema2 = context.getSchema();
        const subscriptionType = schema2.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema2,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/groupBy.mjs
init_checked_fetch();
init_modules_watch_stub();
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema2 = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema2 !== null && schema2 !== void 0 && schema2.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueEnumValueNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueFieldDefinitionNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueOperationTypesRule(context) {
  const schema2 = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema2 ? {
    query: schema2.getQueryType(),
    mutation: schema2.getMutationType(),
    subscription: schema2.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema2 = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema2 !== null && schema2 !== void 0 && schema2.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
init_checked_fetch();
init_modules_watch_stub();
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema2 = context.getSchema();
            const varType = typeFromAST(schema2, varDef.type);
            if (varType && !allowedVariableUsage(
              schema2,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema2, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema2, varType, locationType);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/ValidationContext.mjs
init_checked_fetch();
init_modules_watch_stub();
var ASTValidationContext = class {
  constructor(ast, onError) {
    this._ast = ast;
    this._fragments = void 0;
    this._fragmentSpreads = /* @__PURE__ */ new Map();
    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = /* @__PURE__ */ Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = /* @__PURE__ */ Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
};
var SDLValidationContext = class extends ASTValidationContext {
  constructor(ast, schema2, onError) {
    super(ast, onError);
    this._schema = schema2;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
};
var ValidationContext = class extends ASTValidationContext {
  constructor(schema2, ast, typeInfo, onError) {
    super(ast, onError);
    this._schema = schema2;
    this._typeInfo = typeInfo;
    this._variableUsages = /* @__PURE__ */ new Map();
    this._recursiveVariableUsages = /* @__PURE__ */ new Map();
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(
        node,
        visitWithTypeInfo(typeInfo, {
          VariableDefinition: () => false,
          Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue()
            });
          }
        })
      );
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
};

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/validate.mjs
function validate(schema2, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema2)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema2);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(
    schema2,
    documentAST,
    typeInfo,
    (error) => {
      if (errors.length >= maxErrors) {
        errors.push(
          new GraphQLError(
            "Too many validation errors, error limit reached. Validation aborted."
          )
        );
        throw abortObj;
      }
      errors.push(error);
    }
  );
  const visitor = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/execute.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/memoize3.mjs
init_checked_fetch();
init_modules_watch_stub();
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/locatedError.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/toError.mjs
init_checked_fetch();
init_modules_watch_stub();
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
var NonErrorThrown = class extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
};

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
function isLocatedGraphQLError(error) {
  return Array.isArray(error.path);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);
var defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value.__typename === "string") {
    return value.__typename;
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0; i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0; i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source, args, contextValue, info) {
  if (isObjectLike(source) || typeof source === "function") {
    const property = source[info.fieldName];
    if (typeof property === "function") {
      return source[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/getOperationAST.mjs
init_checked_fetch();
init_modules_watch_stub();
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
        return definition;
      }
    }
  }
  return operation;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/lexicographicSortSchema.mjs
init_checked_fetch();
init_modules_watch_stub();
function lexicographicSortSchema(schema2) {
  const schemaConfig = schema2.toConfig();
  const typeMap = keyValMap(
    sortByName(schemaConfig.types),
    (type) => type.name,
    sortNamedType
  );
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
function sortObjMap(map, sortValueFn) {
  const sortedMap = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, (obj) => obj.name);
}
function sortBy(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/getArgumentValues.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/cross-inspect@1.0.0/node_modules/cross-inspect/esm/index.js
init_checked_fetch();
init_modules_watch_stub();
var MAX_RECURSIVE_DEPTH2 = 3;
function inspect2(value) {
  return formatValue2(value, []);
}
function formatValue2(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue2(value, seenValues);
    default:
      return String(value);
  }
}
function formatError2(value) {
  if (value.name = "GraphQLError") {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
function formatObjectValue2(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
    }
    return formatError2(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable2(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray2(value, seenValues);
  }
  return formatObject2(value, seenValues);
}
function isJSONable2(value) {
  return typeof value.toJSON === "function";
}
function formatObject2(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[" + getObjectTag2(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray2(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue2(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag2(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/errors.js
init_checked_fetch();
init_modules_watch_stub();
var possibleGraphQLErrorProperties = [
  "message",
  "locations",
  "path",
  "nodes",
  "source",
  "positions",
  "originalError",
  "name",
  "stack",
  "extensions"
];
function isGraphQLErrorLike(error) {
  return error != null && typeof error === "object" && Object.keys(error).every((key) => possibleGraphQLErrorProperties.includes(key));
}
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/jsutils.js
init_checked_fetch();
init_modules_watch_stub();
function isIterableObject2(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value;
}
function isObjectLike2(value) {
  return typeof value === "object" && value !== null;
}
function isPromise2(value) {
  return value?.then != null;
}
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise2(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues2(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== void 0) {
        coercedValues[name] = defaultValue;
      } else if (isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect2(argType)}" was not provided.`, {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
        if (defaultValue !== void 0) {
          coercedValues[name] = defaultValue;
        } else if (isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect2(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect2(argType)}" must not be null.`, {
        nodes: [valueNode]
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/rootTypes.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/memoize.js
init_checked_fetch();
init_modules_watch_stub();
function memoize1(fn) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize32(fn) {
  const memoize3Cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2, a3) {
    let cache2 = memoize3Cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize3Cache.set(a1, cache2);
      const cache32 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache32);
      const newValue = fn(a1, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache3);
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === void 0) {
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize5Cache.set(a1, cache2);
      const cache32 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache32);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache32.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache3);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache4);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache5);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === void 0) {
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema2, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema2);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema2) {
  const rootTypes = getRootTypes(schema2);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema2) {
  const rootTypeMap = getRootTypeMap(schema2);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema2) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema2.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
init_checked_fetch();
init_modules_watch_stub();
function mapAsyncIterator(iterator, onNext, onError, onEnd) {
  let $return;
  let abruptClose;
  let onEndWithValue;
  if (onEnd) {
    onEndWithValue = (value) => {
      const onEnd$ = onEnd();
      return isPromise2(onEnd$) ? onEnd$.then(() => value) : value;
    };
  }
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error) => {
      const rethrow = () => Promise.reject(error);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    if (result.done) {
      return onEndWithValue ? onEndWithValue(result) : result;
    }
    return asyncMapValue(result.value, onNext).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (onError) {
    const reject = onError;
    mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
      return onEndWithValue ? res$.then(onEndWithValue) : res$;
    },
    throw(error) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error).then(mapResult, mapReject);
      }
      return Promise.reject(error).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function asyncMapValue(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
}
function iteratorResult(value) {
  return { value, done: false };
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/collectFields.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
init_checked_fetch();
init_modules_watch_stub();
var AccumulatorMap = class extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item) {
    const group = this.get(key);
    if (group === void 0) {
      this.set(key, [item]);
    } else {
      group.push(item);
    }
  }
};

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/directives.js
init_checked_fetch();
init_modules_watch_stub();
var GraphQLDeferDirective = new GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FIELD],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/collectFields.js
function collectFieldsImpl2(schema2, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey2(selection), selection);
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema2, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap();
          collectFieldsImpl2(schema2, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema2, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch2(schema2, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap();
          collectFieldsImpl2(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
}
function collectFields2(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap();
  const patches = [];
  collectFieldsImpl2(schema2, fragments, variableValues, runtimeType, selectionSet, fields, patches, /* @__PURE__ */ new Set());
  return { fields, patches };
}
function shouldIncludeNode2(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch2(schema2, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema2, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema2.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey2(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : void 0
  };
}
var collectSubFields = memoize5(function collectSubfields3(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl2(schema2, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
init_checked_fetch();
init_modules_watch_stub();
function isAsyncIterable(value) {
  return value?.[Symbol.asyncIterator] != null;
}

// node_modules/.pnpm/@graphql-tools+utils@10.1.0_graphql@16.8.1/node_modules/@graphql-tools/utils/esm/Path.js
init_checked_fetch();
init_modules_watch_stub();
function addPath2(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray2(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray2(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/error.js
function isAggregateError(obj) {
  return obj != null && typeof obj === "object" && "errors" in obj;
}
function hasToString(obj) {
  return obj != null && typeof obj.toString === "function";
}
function isGraphQLError(val) {
  return val instanceof GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function handleError(error, maskedErrorsOpts, logger) {
  const errors = /* @__PURE__ */ new Set();
  if (isAggregateError(error)) {
    for (const singleError of error.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
      for (const handledError of handledErrors) {
        errors.add(handledError);
      }
    }
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error) {
      logger.error(error);
    }
    errors.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error)) {
    errors.add(error);
  } else if (error instanceof Error) {
    errors.add(createGraphQLError(error.message, {
      originalError: error
    }));
  } else if (typeof error === "string") {
    errors.add(createGraphQLError(error, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error)) {
    errors.add(createGraphQLError(error.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger.error(error);
    errors.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if ("extensions" in result && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if ("errors" in result && result.errors?.length) {
    for (const error of result.errors) {
      if (error.extensions?.http) {
        if (error.extensions.http.headers) {
          Object.assign(headers, error.extensions.http.headers);
        }
        if (isApplicationJson && error.extensions.http.spec) {
          continue;
        }
        if (error.extensions.http.status && (!status || error.extensions.http.status > status)) {
          status = error.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error) || error.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && // if one item in the array is a GraphQLError, we're good
  obj.some(isGraphQLError);
}

// node_modules/.pnpm/@graphql-yoga+logger@2.0.0/node_modules/@graphql-yoga/logger/esm/index.js
init_checked_fetch();
init_modules_watch_stub();
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args) => console.log(prefix, ...args);
var debugLog = console.debug ? (...args) => console.debug(debugPrefix, ...args) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args) => console.info(infoPrefix, ...args) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args) => console.warn(warnPrefix, ...args) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args) => console.error(errorPrefix, ...args) : consoleLog(errorPrefix);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-graphiql.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/graphiql-html.js
init_checked_fetch();
init_modules_watch_stub();
var graphiql_html_default = '<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.2.1/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from"https://unpkg.com/@graphql-yoga/graphiql@4.2.1/dist/yoga-graphiql.es.js";renderYogaGraphiQL(root,__OPTS__)<\/script></body></html>';

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));
function useGraphiQL(config) {
  const logger = config.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config?.options === "function") {
    graphiqlOptionsFactory = config?.options;
  } else if (typeof config?.options === "object") {
    graphiqlOptionsFactory = () => config?.options;
  } else if (config?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse: endResponse2, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || request.url.endsWith(`${config.graphqlEndpoint}/`) || url.pathname === config.graphqlEndpoint || url.pathname === `${config.graphqlEndpoint}/` || getUrlPattern(fetchAPI).test(url))) {
        logger.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse2(response);
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-schema.js
init_checked_fetch();
init_modules_watch_stub();
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if (isSchema(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema2;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema2 ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema2) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema2);
      }
    };
  }
  const schemaByRequest = /* @__PURE__ */ new WeakMap();
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema2 = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema2);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema2 = schemaByRequest.get(context.request);
      if (schema2 == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema2);
    }
  };
};

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/server.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/create.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/orchestrator.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/document-string-map.js
init_checked_fetch();
init_modules_watch_stub();
var documentStringMap = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/utils.js
init_checked_fetch();
init_modules_watch_stub();
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
function getSubscribeArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
}
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
function mapAsyncIterator2(source, mapper) {
  const iterator = source[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error) {
      try {
        await iterator.return?.();
      } catch (_error) {
      }
      throw error;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await mapResult(await promise) : { value: void 0, done: true };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await mapResult(await promise);
      }
      throw error;
    }
  };
  return stream;
}
function getExecuteArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
}
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));
function isAsyncIterable2(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable2(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return void 0;
}
function finalAsyncIterator(source, onFinal) {
  const iterator = source[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: void 0 };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
function errorAsyncIterator(source, onError) {
  const iterator = source[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error) {
        onError(error);
        return { done: true, value: void 0 };
      }
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await promise : { done: true, value: void 0 };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/orchestrator.js
function throwEngineFunctionError(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
}
function createEnvelopOrchestrator({ plugins }) {
  let schema2 = null;
  let initDone = false;
  const parse2 = () => throwEngineFunctionError("parse");
  const validate2 = () => throwEngineFunctionError("validate");
  const execute3 = () => throwEngineFunctionError("execute");
  const subscribe3 = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema2 = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema: schema2,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];
    const pluginsToAdd = [];
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        pluginsToAdd.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
    pluginsToAdd.length && plugins.splice(i + 1, 0, ...pluginsToAdd);
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source, parseOptions) => {
    let result = null;
    let parseFn = parse2;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source.toString());
    return result;
  } : () => parse2;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema3, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : void 0;
    let validateFn = validate2;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema3,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema3, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate2;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          }
        });
      }
      return context;
    } catch (err) {
      let error = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error,
          setError: (err2) => {
            error = err2;
          }
        });
      }
      throw error;
    }
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = subscribe3;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    const context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== void 0) {
        break;
      }
    }
    if (result === void 0) {
      result = await subscribeFn({
        ...args,
        contextValue: context
        // Casted for GraphQL.js 15 compatibility
        // Can be removed once we drop support for GraphQL.js 15
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable2(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error,
            setError: (err2) => {
              error = err2;
            }
          });
        }
        throw error;
      });
    }
    return result;
  }) : makeSubscribe(subscribe3);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = execute3;
    let result;
    const afterCalls = [];
    const context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            Object.assign(context, extension);
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== void 0) {
        break;
      }
    }
    if (result === void 0) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute3);
  initDone = true;
  if (schema2) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema: schema2,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema2;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/create.js
function notEmpty(value) {
  return value != null;
}
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator = createEnvelopOrchestrator({
    plugins
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/plugins/use-masked-errors.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
function isGraphQLError2(error) {
  return error instanceof Error && error.name === "GraphQLError";
}
function isOriginalGraphQLError2(error) {
  if (isGraphQLError2(error)) {
    if (error.originalError != null) {
      return isOriginalGraphQLError2(error.originalError);
    }
    return true;
  }
  return false;
}
function createSerializableGraphQLError(message, originalError, isDev2) {
  const error = new Error(message);
  error.name = "GraphQLError";
  if (isDev2) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error, "toJSON", {
    value() {
      return {
        message: error.message,
        extensions: error.extensions
      };
    }
  });
  return error;
}
var createDefaultMaskError = (isDev2) => (error, message) => {
  if (isOriginalGraphQLError2(error)) {
    return error;
  }
  return createSerializableGraphQLError(message, error, isDev2);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError2, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error) => maskError2(error, message)) });
  }
};
function useMaskedErrors(opts) {
  const maskError2 = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError2, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error, setError }) => {
        setError(maskError2(error, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error, setError }) {
          setError(maskError2(error, message));
        }
      };
    }
  };
}

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/plugins/use-extend-context.js
init_checked_fetch();
init_modules_watch_stub();
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// node_modules/.pnpm/@envelop+core@5.0.0/node_modules/@envelop/core/esm/plugins/use-engine.js
init_checked_fetch();
init_modules_watch_stub();
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// node_modules/.pnpm/@graphql-tools+executor@1.2.1_graphql@16.8.1/node_modules/@graphql-tools/executor/esm/execution/execute.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/value-or-promise@1.0.12/node_modules/value-or-promise/build/module/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/value-or-promise@1.0.12/node_modules/value-or-promise/build/module/ValueOrPromise.js
init_checked_fetch();
init_modules_watch_stub();
function isPromiseLike(object) {
  return object != null && typeof object.then === "function";
}
var defaultOnRejectedFn = (reason) => {
  throw reason;
};
var ValueOrPromise = class {
  state;
  constructor(executor) {
    let value;
    try {
      value = executor();
    } catch (reason) {
      this.state = { status: "rejected", value: reason };
      return;
    }
    if (isPromiseLike(value)) {
      this.state = { status: "pending", value };
      return;
    }
    this.state = { status: "fulfilled", value };
  }
  then(onFulfilled, onRejected) {
    const state = this.state;
    if (state.status === "pending") {
      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
    }
    const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
    if (state.status === "rejected") {
      return new ValueOrPromise(() => onRejectedFn(state.value));
    }
    try {
      const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : void 0;
      return onFulfilledFn === void 0 ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
    } catch (e) {
      return new ValueOrPromise(() => onRejectedFn(e));
    }
  }
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  resolve() {
    const state = this.state;
    if (state.status === "pending") {
      return Promise.resolve(state.value);
    }
    if (state.status === "rejected") {
      throw state.value;
    }
    return state.value;
  }
  static all(valueOrPromises) {
    let rejected = false;
    let reason;
    let containsPromise = false;
    const values = [];
    for (const valueOrPromise of valueOrPromises) {
      const state = valueOrPromise.state;
      if (state.status === "rejected") {
        if (rejected) {
          continue;
        }
        rejected = true;
        reason = state.value;
        continue;
      }
      if (state.status === "pending") {
        containsPromise = true;
      }
      values.push(state.value);
    }
    if (containsPromise) {
      if (rejected) {
        Promise.all(values).catch(() => {
        });
        return new ValueOrPromise(() => {
          throw reason;
        });
      }
      return new ValueOrPromise(() => Promise.all(values));
    }
    return new ValueOrPromise(() => values);
  }
};

// node_modules/.pnpm/@graphql-tools+executor@1.2.1_graphql@16.8.1/node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
init_checked_fetch();
init_modules_watch_stub();
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: void 0, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = void 0;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = void 0;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: void 0, done: true };
    },
    async throw(error) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/.pnpm/@graphql-tools+executor@1.2.1_graphql@16.8.1/node_modules/@graphql-tools/executor/esm/execution/invariant.js
init_checked_fetch();
init_modules_watch_stub();
function invariant2(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/.pnpm/@graphql-tools+executor@1.2.1_graphql@16.8.1/node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
init_checked_fetch();
init_modules_watch_stub();
async function promiseForObject(object, signal) {
  const resolvedObject = /* @__PURE__ */ Object.create(null);
  await new Promise((resolve, reject) => {
    signal?.addEventListener("abort", () => {
      resolve();
    });
    Promise.all(Object.entries(object).map(async ([key, value]) => {
      resolvedObject[key] = await value;
    })).then(() => resolve(), reject);
  });
  return resolvedObject;
}

// node_modules/.pnpm/@graphql-tools+executor@1.2.1_graphql@16.8.1/node_modules/@graphql-tools/executor/esm/execution/values.js
init_checked_fetch();
init_modules_watch_stub();
function getVariableValues2(schema2, varDefNodes, inputs, options) {
  const errors = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema2, varDefNodes, inputs, (error) => {
      if (maxErrors != null && errors.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors.push(error);
    });
    if (errors.length === 0) {
      return { coerced };
    }
  } catch (error) {
    errors.push(error);
  }
  return { errors };
}
function coerceVariableValues(schema2, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema2, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(createGraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty2(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect2(varType);
        onError(createGraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect2(varType);
      onError(createGraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error) => {
      let prefix = `Variable "$${varName}" got invalid value ` + inspect2(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray2(path)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error.message, {
        nodes: varDefNode,
        originalError: error.originalError
      }));
    });
  }
  return coercedValues;
}

// node_modules/.pnpm/@graphql-tools+executor@1.2.1_graphql@16.8.1/node_modules/@graphql-tools/executor/esm/execution/execute.js
var collectSubfields4 = memoize32((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
function execute2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  return executeImpl(exeContext);
}
function executeImpl(exeContext) {
  return new ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error) => {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }).resolve();
}
function buildResponse(data, errors) {
  return errors.length === 0 ? { data } : { errors, data };
}
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document2) {
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document2.definitions) {
    if (definition.kind === Kind.FRAGMENT_DEFINITION) {
      fragments[definition.name.value] = definition;
    }
  }
  return fragments;
});
function buildExecutionContext(args) {
  const { schema: schema2, document: document2, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal } = args;
  assertValidSchema(schema2);
  const fragments = getFragmentsFromDocument(document2);
  let operation;
  for (const definition of document2.definitions) {
    switch (definition.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== void 0) {
            return [
              createGraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition;
        } else if (definition.name?.value === operationName) {
          operation = definition;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues2(schema2, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema2,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver2,
    typeResolver: typeResolver ?? defaultTypeResolver2,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver2,
    subsequentPayloads: /* @__PURE__ */ new Set(),
    errors: [],
    signal
  };
}
function buildPerEventExecutionContext(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: /* @__PURE__ */ new Set(),
    errors: []
  };
}
function executeOperation(exeContext) {
  const { operation, schema: schema2, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema2, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields2(schema2, fragments, variableValues, rootType, operation.selectionSet);
  const path = void 0;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
  }
  return result;
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  let abortErrorThrown = false;
  return promiseReduce(fields, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath2(path, responseName, parentType.name);
    if (exeContext.signal?.aborted) {
      results[responseName] = null;
      return results;
    }
    return new ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === void 0) {
        return results;
      }
      results[responseName] = result;
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray2(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
      return results;
    });
  }, /* @__PURE__ */ Object.create(null)).resolve();
}
function executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  let abortErrorThrown = false;
  try {
    for (const [responseName, fieldNodes] of fields) {
      if (exeContext.signal?.aborted) {
        results[responseName] = null;
        continue;
      }
      const fieldPath = addPath2(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== void 0) {
        results[responseName] = result;
        if (isPromise2(result)) {
          containsPromise = true;
        }
      }
      if (exeContext.signal?.aborted && !abortErrorThrown) {
        exeContext.errors.push(createGraphQLError("Execution aborted", {
          nodes: fieldNodes,
          path: pathToArray2(fieldPath),
          originalError: exeContext.signal?.reason
        }));
        abortErrorThrown = true;
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results, exeContext.signal).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results, exeContext.signal);
}
function executeField(exeContext, parentType, source, fieldNodes, path, asyncPayloadRecord) {
  const errors = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise2(result)) {
      completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    if (isPromise2(completed)) {
      return completed.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(path));
        const handledError = handleFieldError(error, returnType, errors);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(path));
    const handledError = handleFieldError(error, returnType, errors);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    return handledError;
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error, returnType, errors) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  errors.push(error);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect2(returnType));
}
function getStreamValues(exeContext, fieldNodes, path) {
  if (typeof path.key === "number") {
    return;
  }
  const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant2(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant2(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : void 0
  };
}
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {
  exeContext.signal?.addEventListener("abort", () => {
    iterator.return?.();
    exeContext.errors.push(createGraphQLError("Execution aborted", {
      nodes: fieldNodes,
      path: pathToArray2(path),
      originalError: exeContext.signal?.reason
    }));
  });
  const errors = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath2(path, index, void 0);
    let iteration;
    try {
      iteration = await iterator.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
      completedResults.push(handleFieldError(error, itemType, errors));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);
  }
  if (!isIterableObject2(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item of result) {
    const itemPath = addPath2(path, index, void 0);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise2(item)) {
      completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    }
    if (isPromise2(completedItem)) {
      completedResults.push(completedItem.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const handledError = handleFieldError(error, itemType, errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
}
function completeLeafValue(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect2(returnType)}.serialize(${inspect2(result)})\` to return non-nullable value, returned: ${inspect2(serializedResult)}`);
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise2(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if (isObjectType(runtimeTypeName)) {
    throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect2(result)}, received "${inspect2(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!isObjectType(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise2(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect2(result)}.`, {
    nodes: fieldNodes
  });
}
function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields4(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
  }
  return subFields;
}
var defaultTypeResolver2 = function(value, contextValue, info, abstractType) {
  if (isObjectLike2(value) && typeof value["__typename"] === "string") {
    return value["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0; i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise2(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0; i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver2 = function(source, args, contextValue, info) {
  if (isObjectLike2(source) || typeof source === "function") {
    const property = source[info.fieldName];
    if (typeof property === "function") {
      return source[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
function subscribe2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise2(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults, signal) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  signal?.addEventListener("abort", () => {
    done = true;
    subsequentIterator.throw?.(signal?.reason);
  });
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      if (done) {
        return Promise.resolve({
          value: void 0,
          done
        });
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error) {
      done = true;
      return subsequentIterator.throw(error);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult, signal) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult, signal);
  } else {
    yield someExecutionResult;
  }
}
function mapSourceToResponse(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream[Symbol.asyncIterator](), async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload)), exeContext.signal), async function* (error) {
    const wrappedError = createGraphQLError(error.message, {
      originalError: error,
      nodes: [exeContext.operation]
    });
    yield {
      errors: [wrappedError]
    };
  }));
}
function createSourceEventStreamImpl(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise2(eventStream)) {
      return eventStream.then(void 0, (error) => ({ errors: [error] }));
    }
    return eventStream;
  } catch (error) {
    return { errors: [error] };
  }
}
function executeSubscription(exeContext) {
  const { schema: schema2, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema2.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", {
      nodes: operation
    });
  }
  const { fields: rootFields } = collectFields2(schema2, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef2(schema2, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, {
      nodes: fieldNodes
    });
  }
  const path = addPath2(void 0, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args, contextValue, info);
    if (isPromise2(result)) {
      return result.then(assertEventStream).then(void 0, (error) => {
        throw locatedError(error, fieldNodes, pathToArray2(path));
      });
    }
    return assertEventStream(result, exeContext.signal);
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray2(path));
  }
}
function assertEventStream(result, signal) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError(`Subscription field must return Async Iterable. Received: ${inspect2(result)}.`);
  }
  return {
    [Symbol.asyncIterator]() {
      const asyncIterator = result[Symbol.asyncIterator]();
      signal?.addEventListener("abort", () => {
        asyncIterator.return?.();
      });
      return asyncIterator;
    }
  };
}
function executeDeferredFragment(exeContext, parentType, sourceValue, fields, label, path, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);
    if (isPromise2(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e) => {
        asyncPayloadRecord.errors.push(e);
        return null;
      });
    }
  } catch (e) {
    asyncPayloadRecord.errors.push(e);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
}
function executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise2(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
      }
      if (isPromise2(completedItem)) {
        completedItem = completedItem.then(void 0, (rawError) => {
          const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
          const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
      completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error) {
    asyncPayloadRecord.errors.push(error);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise2(completedItem)) {
    completedItems = completedItem.then((value) => [value], (error) => {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
}
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item;
  try {
    const { value, done } = await iterator.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: void 0 };
    }
    item = value;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    return { done: true, value };
  }
  let completedItem;
  try {
    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    if (isPromise2(completedItem)) {
      completedItem = completedItem.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value };
  }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? void 0;
  while (true) {
    const itemPath = addPath2(path, index, void 0);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error) {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator?.return) {
        iterator.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise2(completedItem)) {
      completedItems = completedItem.then((value) => [value], (error) => {
        asyncPayloadRecord.errors.push(error);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
function filterSubsequentPayloads(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray2(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0; i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
}
function getCompletedIncrementalResults(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
}
function yieldSubsequentPayloads(exeContext) {
  let isDone = false;
  async function next() {
    if (isDone) {
      return { value: void 0, done: true };
    }
    await Promise.race(Array.from(exeContext.subsequentPayloads).map((p) => p.promise));
    if (isDone) {
      return { value: void 0, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: void 0, done: true };
    },
    async throw(error) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error);
    }
  };
}
var DeferredFragmentRecord = class {
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
};
var StreamRecord = class {
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
};
function isStreamPayload(asyncPayload) {
  return asyncPayload.type === "stream";
}
function getFieldDef2(schema2, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}

// node_modules/.pnpm/@graphql-tools+executor@1.2.1_graphql@16.8.1/node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
init_checked_fetch();
init_modules_watch_stub();
function normalizedExecutor(args) {
  const operationAST = getOperationAST(args.document, args.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe2(args);
  }
  return new ValueOrPromise(() => execute2(args)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result, args.signal);
    }
    return result;
  }).resolve();
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/server.js
var defaultFetchAPI = __toESM(require_global_ponyfill(), 1);

// node_modules/.pnpm/@whatwg-node+server@0.9.26/node_modules/@whatwg-node/server/esm/createServerAdapter.js
init_checked_fetch();
init_modules_watch_stub();
var DefaultFetchAPI = __toESM(require_global_ponyfill(), 1);

// node_modules/.pnpm/@whatwg-node+server@0.9.26/node_modules/@whatwg-node/server/esm/utils.js
init_checked_fetch();
init_modules_watch_stub();
var import_fetch = __toESM(require_global_ponyfill(), 1);
function isAsyncIterable3(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
function getPort(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
}
function getHostnameWithPort(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
}
function buildFullUrl(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? "https" : "http");
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
}
function isRequestBody(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable3(body)) {
    return true;
  }
  return false;
}
var ServerAdapterRequestAbortSignal = class extends EventTarget {
  constructor() {
    super(...arguments);
    this.aborted = false;
    this._onabort = null;
  }
  throwIfAborted() {
    if (this.aborted) {
      throw new DOMException("Aborted", "AbortError");
    }
  }
  sendAbort() {
    this.aborted = true;
    this.dispatchEvent(new Event("abort"));
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value) {
    this._onabort = value;
    if (value) {
      this.addEventListener("abort", value);
    } else {
      this.removeEventListener("abort", value);
    }
  }
};
var bunNodeCompatModeWarned = false;
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new import_fetch.URL(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  let signal;
  if (RequestCtor !== globalThis.Request) {
    signal = new ServerAdapterRequestAbortSignal();
    if (rawRequest?.once) {
      rawRequest.once("close", () => {
        if (rawRequest.aborted) {
          signal.sendAbort();
        }
      });
    }
  } else {
    const controller = new AbortController();
    signal = controller.signal;
    if (rawRequest.once) {
      rawRequest.once("close", () => {
        if (rawRequest.aborted) {
          controller.abort();
        }
      });
    }
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
        body: maybeParsedBody,
        signal
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      signal
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  if (globalThis.process?.versions?.bun && isReadable(rawRequest)) {
    if (!bunNodeCompatModeWarned) {
      bunNodeCompatModeWarned = true;
      console.warn(`You use Bun Node compatibility mode, which is not recommended!
It will affect your performance. Please check our Bun integration recipe, and avoid using 'node:http' for your server implementation.`);
    }
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers,
      duplex: "half",
      body: new ReadableStream({
        start(controller) {
          rawRequest.on("data", (chunk) => {
            controller.enqueue(chunk);
          });
          rawRequest.on("error", (e) => {
            controller.error(e);
          });
          rawRequest.on("end", () => {
            controller.close();
          });
        },
        cancel(e) {
          rawRequest.destroy(e);
        }
      }),
      signal
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: nodeRequest.headers,
    body: rawRequest,
    duplex: "half",
    signal
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
function configureSocket(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
}
function endResponse(serverResponse) {
  serverResponse.end(null, null, null);
}
async function sendAsyncIterable(serverResponse, asyncIterable) {
  for await (const chunk of asyncIterable) {
    if (!serverResponse.write(chunk)) {
      break;
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {
    return;
  }
  if (!fetchResponse) {
    serverResponse.statusCode = 404;
    serverResponse.end();
    return;
  }
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  let setCookiesSet = false;
  fetchResponse.headers.forEach((value, key) => {
    if (key === "set-cookie") {
      if (setCookiesSet) {
        return;
      }
      setCookiesSet = true;
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value);
  });
  const bufOfRes = fetchResponse._buffer;
  if (bufOfRes) {
    serverResponse.write(bufOfRes);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable3(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && ("body" in val || "cache" in val || "credentials" in val || "headers" in val || "integrity" in val || "keepalive" in val || "method" in val || "mode" in val || "redirect" in val || "referrer" in val || "referrerPolicy" in val || "signal" in val || "window" in val);
}
function completeAssign(...args) {
  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");
  sources.forEach((source) => {
    const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors2, key) => {
      descriptors2[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}
function isPromise3(val) {
  return val?.then != null;
}
function iterateAsyncVoid(iterable, callback) {
  const iterator = iterable[Symbol.iterator]();
  let stopEarlyFlag = false;
  function stopEarlyFn() {
    stopEarlyFlag = true;
  }
  function iterate() {
    const { done: endOfIterator, value } = iterator.next();
    if (endOfIterator) {
      return;
    }
    const result$ = callback(value, stopEarlyFn);
    if (isPromise3(result$)) {
      return result$.then(() => {
        if (stopEarlyFlag) {
          return;
        }
        return iterate();
      });
    }
    if (stopEarlyFlag) {
      return;
    }
    return iterate();
  }
  return iterate();
}
function handleErrorFromRequestHandler(error, ResponseCtor) {
  return new ResponseCtor(error.stack || error.message || error.toString(), {
    status: error.status || 500
  });
}
function isolateObject(originalCtx, waitUntilPromises) {
  if (originalCtx == null) {
    return {};
  }
  const extraProps = {};
  const deletedProps = /* @__PURE__ */ new Set();
  return new Proxy(originalCtx, {
    get(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return function waitUntil(promise) {
          waitUntilPromises.push(promise.catch((err) => console.error(err)));
        };
      }
      const extraPropVal = extraProps[prop];
      if (extraPropVal != null) {
        if (typeof extraPropVal === "function") {
          return extraPropVal.bind(extraProps);
        }
        return extraPropVal;
      }
      if (deletedProps.has(prop)) {
        return void 0;
      }
      return originalCtx2[prop];
    },
    set(_originalCtx, prop, value) {
      extraProps[prop] = value;
      return true;
    },
    has(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return true;
      }
      if (deletedProps.has(prop)) {
        return false;
      }
      if (prop in extraProps) {
        return true;
      }
      return prop in originalCtx2;
    },
    defineProperty(_originalCtx, prop, descriptor) {
      return Reflect.defineProperty(extraProps, prop, descriptor);
    },
    deleteProperty(_originalCtx, prop) {
      if (prop in extraProps) {
        return Reflect.deleteProperty(extraProps, prop);
      }
      deletedProps.add(prop);
      return true;
    },
    ownKeys(originalCtx2) {
      const extraKeys = Reflect.ownKeys(extraProps);
      const originalKeys = Reflect.ownKeys(originalCtx2);
      const deletedKeys = Array.from(deletedProps);
      const allKeys = new Set(extraKeys.concat(originalKeys.filter((keys) => !deletedKeys.includes(keys))));
      if (waitUntilPromises != null) {
        allKeys.add("waitUntil");
      }
      return Array.from(allKeys);
    },
    getOwnPropertyDescriptor(originalCtx2, prop) {
      if (prop in extraProps) {
        return Reflect.getOwnPropertyDescriptor(extraProps, prop);
      }
      if (deletedProps.has(prop)) {
        return void 0;
      }
      return Reflect.getOwnPropertyDescriptor(originalCtx2, prop);
    }
  });
}

// node_modules/.pnpm/@whatwg-node+server@0.9.26/node_modules/@whatwg-node/server/esm/uwebsockets.js
init_checked_fetch();
init_modules_watch_stub();
function isUWSResponse(res) {
  return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    body = new fetchAPI.ReadableStream({});
    const readable = body.readable;
    res.onAborted(() => {
      readable.push(null);
    });
    res.onData(function(ab, isLast) {
      const chunk = Buffer.from(ab, 0, ab.byteLength);
      readable.push(Buffer.from(chunk));
      if (isLast) {
        readable.push(null);
      }
    });
  }
  const headers = new fetchAPI.Headers();
  req.forEach((key, value) => {
    headers.append(key, value);
  });
  let url = `http://localhost${req.getUrl()}`;
  const query = req.getQuery();
  if (query) {
    url += `?${query}`;
  }
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal: new ServerAdapterRequestAbortSignal()
  });
}
async function forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse) {
  let resAborted = false;
  uwsResponse.onAborted(function() {
    resAborted = true;
  });
  for await (const chunk of fetchResponse.body) {
    if (resAborted) {
      return;
    }
    uwsResponse.cork(() => {
      uwsResponse.write(chunk);
    });
  }
  uwsResponse.cork(() => {
    uwsResponse.end();
  });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse) {
  if (!fetchResponse) {
    uwsResponse.writeStatus("404 Not Found");
    uwsResponse.end();
    return;
  }
  const bufferOfRes = fetchResponse._buffer;
  uwsResponse.cork(() => {
    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
    for (const [key, value] of fetchResponse.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = fetchResponse.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              uwsResponse.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        uwsResponse.writeHeader(key, value);
      }
    }
    if (bufferOfRes) {
      uwsResponse.end(bufferOfRes);
    }
  });
  if (bufferOfRes) {
    return;
  }
  if (!fetchResponse.body) {
    uwsResponse.end();
    return;
  }
  return forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse);
}

// node_modules/.pnpm/@whatwg-node+server@0.9.26/node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  await Promise.allSettled(waitUntilPromises);
}
function isRequestAccessible(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
}
var EMPTY_OBJECT = {};
function createServerAdapter(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...DefaultFetchAPI,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin of options.plugins) {
      if (plugin.onRequest) {
        onRequestHooks.push(plugin.onRequest);
      }
      if (plugin.onResponse) {
        onResponseHooks.push(plugin.onResponse);
      }
    }
  }
  const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest2(request, serverContext) {
    let requestHandler = givenHandleRequest;
    let response;
    if (onRequestHooks.length === 0) {
      return handleEarlyResponse();
    }
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
      request,
      serverContext,
      fetchAPI,
      url,
      requestHandler,
      setRequestHandler(newRequestHandler) {
        requestHandler = newRequestHandler;
      },
      endResponse(newResponse) {
        response = newResponse;
        if (newResponse) {
          stopEarly();
        }
      }
    }));
    function handleResponse(response2) {
      if (onRequestHooks.length === 0) {
        return response2;
      }
      const onResponseHookPayload = {
        request,
        response: response2,
        serverContext
      };
      const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, (onResponseHook) => onResponseHook(onResponseHookPayload));
      if (isPromise3(onResponseHooksIteration$)) {
        return onResponseHooksIteration$.then(() => response2);
      }
      return response2;
    }
    function handleEarlyResponse() {
      if (!response) {
        const response$ = requestHandler(request, serverContext);
        if (isPromise3(response$)) {
          return response$.then(handleResponse);
        }
        return handleResponse(response$);
      }
      return handleResponse(response);
    }
    if (isPromise3(onRequestHooksIteration$)) {
      return onRequestHooksIteration$.then(handleEarlyResponse);
    }
    return handleEarlyResponse();
  } : givenHandleRequest;
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function requestListener(nodeRequest, serverResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: serverResponse,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    let response$;
    try {
      response$ = handleNodeRequest(nodeRequest, defaultServerContext, ...ctx);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise3(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => sendNodeResponse(response, serverResponse, nodeRequest)).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendNodeResponse(response$, serverResponse, nodeRequest);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI
    });
    let resAborted = false;
    res.onAborted(() => {
      resAborted = true;
      request.signal.sendAbort();
    });
    let response$;
    try {
      response$ = handleRequest(request, serverContext);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise3(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => {
        if (!resAborted) {
          return sendResponseToUwsOpts(res, response);
        }
      }).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendResponseToUwsOpts(res, response$);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign({}, event, ...filteredCtxParts) : isolateObject(event);
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    let waitUntilPromises;
    const serverContext = filteredCtxParts.length > 1 ? completeAssign(...filteredCtxParts) : isolateObject(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null ? waitUntilPromises = [] : void 0);
    const response$ = handleRequest(request, serverContext);
    if (waitUntilPromises?.length) {
      return handleWaitUntils(waitUntilPromises).then(() => response$);
    }
    return response$;
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || "href" in input) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        return handleRequestWithWaitUntil(new fetchAPI.Request(input, initOrCtx), ...restOfCtx);
      }
      return handleRequestWithWaitUntil(new fetchAPI.Request(input), ...maybeCtx);
    }
    return handleRequestWithWaitUntil(input, ...maybeCtx);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest,
    fetch: fetchFn,
    handleNodeRequest,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    // It should have all the attributes of the handler function and the server instance
    has: (_, prop) => {
      return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;
    },
    get: (_, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args) {
              const returnedVal = serverAdapterBaseObject[prop](...args);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_, __, args) {
      return genericRequestHandler(...args);
    }
  });
  return serverAdapter;
}

// node_modules/.pnpm/@whatwg-node+server@0.9.26/node_modules/@whatwg-node/server/esm/plugins/useCors.js
init_checked_fetch();
init_modules_watch_stub();
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      }
      headers["Vary"] = "Access-Control-Request-Headers";
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          // Safari (and potentially other browsers) need content-length 0,
          // for 204 or they just hang waiting for a body
          // see: https://github.com/expressjs/cors/blob/master/lib/index.js#L176
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// node_modules/.pnpm/@whatwg-node+server@0.9.26/node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
init_checked_fetch();
init_modules_watch_stub();
var import_fetch2 = __toESM(require_global_ponyfill(), 1);
function createDefaultErrorHandler(ResponseCtor = import_fetch2.Response) {
  return function defaultErrorHandler(e) {
    if (e.details || e.status || e.headers || e.name === "HTTPError") {
      return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.message, {
        status: e.status,
        headers: e.headers || {}
      });
    }
    console.error(e);
    if (ResponseCtor.error) {
      return ResponseCtor.error();
    }
    return new ResponseCtor(null, { status: 500 });
  };
}
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler2 = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(function handlerWithErrorHandling(request, serverContext) {
        try {
          const response$ = requestHandler(request, serverContext);
          if (isPromise3(response$)) {
            return response$.catch((e) => errorHandler2(e, request, serverContext));
          }
          return response$;
        } catch (e) {
          return errorHandler2(e, request, serverContext);
        }
      });
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/get.js
init_checked_fetch();
init_modules_watch_stub();
var import_fetch4 = __toESM(require_global_ponyfill(), 1);

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
init_checked_fetch();
init_modules_watch_stub();
var import_fetch3 = __toESM(require_global_ponyfill(), 1);
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || void 0;
  const query = searchParams.get("query") || void 0;
  const variablesStr = searchParams.get("variables") || void 0;
  const extensionsStr = searchParams.get("extensions") || void 0;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : void 0,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : void 0
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new import_fetch3.URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/get.js
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new import_fetch4.URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
init_checked_fetch();
init_modules_watch_stub();
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
init_checked_fetch();
init_modules_watch_stub();
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
init_checked_fetch();
init_modules_watch_stub();
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/dset@3.1.3/node_modules/dset/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k;
  while (i < l) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map;
    try {
      map = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map) {
      const file = requestBody.get(fileIndex);
      const keys = map[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
init_checked_fetch();
init_modules_watch_stub();
var expectedParameters = /* @__PURE__ */ new Set(["query", "variables", "operationName", "extensions"]);
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType = extendedTypeof(params.query);
  if (queryType !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
function extendedTypeof(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
}
function isObject(val) {
  return extendedTypeof(val) === "object";
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
init_checked_fetch();
init_modules_watch_stub();
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
init_checked_fetch();
init_modules_watch_stub();
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error of result) {
            error.extensions.http = {
              ...error.extensions.http,
              spec: error.extensions.http?.spec ?? true,
              status: error.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
init_checked_fetch();
init_modules_watch_stub();
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
init_checked_fetch();
init_modules_watch_stub();
function assertMutationViaGet(method, document2, operationName) {
  const operation = document2 ? getOperationAST(document2, operationName) ?? void 0 : void 0;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        // the `params` might be missing in cases where the user provided
        // malformed context to getEnveloped (like `yoga.getEnveloped({})`)
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-health-check.js
init_checked_fetch();
init_modules_watch_stub();
function useHealthCheck({ id = Date.now().toString(), logger = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id
          }
        });
        endResponse2(response);
      }
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/utils/create-lru-cache.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/lru-cache@10.2.0/node_modules/lru-cache/dist/esm/index.js
init_checked_fetch();
init_modules_watch_stub();
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class {
  heap;
  length;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s = new _Stack(max, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s;
  }
  constructor(max, HeapCls) {
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var Stack = _Stack;
_constructing = new WeakMap();
// private constructor
__privateAdd(Stack, _constructing, false);
var LRUCache = class {
  // properties coming in from the options of these, only max and maxSize
  // really *need* to be protected. The rest can be modified, as they just
  // set defaults for various methods.
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string description of an object.
   * Called by the built-in method Object.prototype.toString.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
   * single key. Always returns stale values, if their info is found in the
   * cache, so be sure to check for expired TTLs if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/utils/create-lru-cache.js
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 36e5;
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document2 = documentCache.get(strDocument);
      if (document2) {
        setParsedDocument(document2);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema2, documentAST, rules },
      setResult
      // eslint-disable-next-line @typescript-eslint/ban-types
    }) {
      if (schema2 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = /* @__PURE__ */ new WeakMap();
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema2);
        if (!validationCacheByDocument) {
          validationCacheByDocument = /* @__PURE__ */ new WeakMap();
          validationCacheBySchema.set(schema2, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-request-parser.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_MATCHER = () => true;
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-result-processor.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
init_checked_fetch();
init_modules_watch_stub();
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
init_checked_fetch();
init_modules_watch_stub();
function jsonStringifyResultWithoutInternals(result) {
  if (Array.isArray(result)) {
    return `[${result.map((r) => {
      const sanitizedResult2 = omitInternalsFromResultErrors(r);
      const stringifier2 = r.stringify || JSON.stringify;
      return stringifier2(sanitizedResult2);
    }).join(",")}]`;
  }
  const sanitizedResult = omitInternalsFromResultErrors(result);
  const stringifier = result.stringify || JSON.stringify;
  return stringifier(sanitizedResult);
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions } = result.extensions;
      newResult.extensions = Object.keys(extensions).length ? extensions : void 0;
    }
    return newResult;
  }
  return result;
}
function omitInternalsFromError(err) {
  if (isGraphQLError(err)) {
    const serializedError = "toJSON" in err && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || void 0),
      extensions: Object.keys(extensions).length ? extensions : void 0
    });
  }
  return err;
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator;
  const textEncoder = new fetchAPI.TextEncoder();
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable2(result)) {
        iterator = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (value != null) {
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
        controller.enqueue(textEncoder.encode("\r\n"));
        const chunk = jsonStringifyResultWithoutInternals(value);
        const encodedChunk = textEncoder.encode(chunk);
        controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(encodedChunk);
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("---"));
      }
      if (done) {
        controller.enqueue(textEncoder.encode("--\r\n"));
        controller.close();
      }
    },
    async cancel(e) {
      await iterator.return?.(e);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
init_checked_fetch();
init_modules_watch_stub();
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(
    executionResult,
    headersInit,
    // prefer 200 only if accepting application/json and all errors are exclusively GraphQL errors
    acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions?.originalError || isGraphQLError(err.extensions.originalError))
  );
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
init_checked_fetch();
init_modules_watch_stub();
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12e3;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder();
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        controller.enqueue(textEncoder.encode(":\n\n"));
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable2(result)) {
          iterator = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(textEncoder.encode(`event: next
`));
          const chunk = jsonStringifyResultWithoutInternals(value);
          controller.enqueue(textEncoder.encode(`data: ${chunk}

`));
        }
        if (done) {
          controller.enqueue(textEncoder.encode(`event: complete

`));
          clearInterval(pingInterval);
          controller.close();
        }
      },
      async cancel(e) {
        clearInterval(pingInterval);
        await iterator.return?.(e);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var multipart = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
function getSSEProcessorConfig() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
}
var regular = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};
function useResultProcessors() {
  const isSubscriptionRequestMap = /* @__PURE__ */ new WeakMap();
  const sse = getSSEProcessorConfig();
  const defaultList = [sse, multipart, regular];
  const subscriptionList = [sse, regular];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable2(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/landing-page-html.js
init_checked_fetch();
init_modules_watch_stub();
var landing_page_html_default = `<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \u{1F440}</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args.graphqlEndpoint) && !request.url.endsWith(`${args.graphqlEndpoint}/`) && url.pathname !== args.graphqlEndpoint && url.pathname !== `${args.graphqlEndpoint}/` && !getUrlPattern(fetchAPI).test(url)) {
        if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/process-request.js
init_checked_fetch();
init_modules_watch_stub();
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document2 = enveloped.parse(params.query);
  const errors = enveloped.validate(enveloped.schema, document2);
  if (errors.length > 0) {
    return { errors };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document: document2,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = getOperationAST(document2, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/utils/mask-error.js
init_checked_fetch();
init_modules_watch_stub();
var maskError = (error, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error)) {
    if (error.originalError) {
      if (error.originalError.name === "GraphQLError") {
        return error;
      }
      const extensions = {
        ...error.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions.originalError = {
          message: error.originalError.message,
          stack: error.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error.nodes,
        source: error.source,
        positions: error.positions,
        path: error.path,
        extensions
      });
    }
    return error;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error instanceof Error ? {
        message: error.message,
        stack: error.stack
      } : error : void 0
    }
  });
};

// node_modules/.pnpm/graphql-yoga@5.1.1_graphql@16.8.1/node_modules/graphql-yoga/esm/server.js
var YogaServer = class {
  /**
   * Instance of envelop
   */
  getEnveloped;
  logger;
  graphqlEndpoint;
  fetchAPI;
  plugins;
  onRequestParseHooks;
  onParamsHooks;
  onResultProcessHooks;
  maskedErrorsOpts;
  id;
  constructor(options) {
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...defaultFetchAPI
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger = options?.logging == null ? true : options.logging;
    this.logger = typeof logger === "boolean" ? logger === true ? createLogger() : createLogger("silent") : typeof logger === "string" ? createLogger(logger) : logger;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = /* @__PURE__ */ new WeakSet();
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error, message) => {
        if (maskedErrorSet.has(error)) {
          return error;
        }
        const newError = maskErrorFn(error, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error) {
          this.logger.error(error);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse,
        validate,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules
      }),
      // Use the schema provided by the user
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      // Middlewares before processing the incoming HTTP request
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      // Middlewares before the GraphQL execution
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      // Middlewares after the GraphQL execution
      useResultProcessors(),
      useErrorHandling((error, request) => {
        const errors = handleError(error, this.maskedErrorsOpts, this.logger);
        const result = {
          errors
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      // To make sure those are called at the end
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(
              // @ts-expect-error Add plugins has context but this hook doesn't care
              useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache)
            );
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(
            // @ts-expect-error Add plugins has context but this hook doesn't care
            useUnhandledRoute({
              graphqlEndpoint,
              showLandingPage: options?.landingPage ?? true
            })
          );
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(
            // We handle validation errors at the end
            useHTTPValidationError()
          );
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin of this.plugins) {
      if (plugin) {
        if (plugin.onYogaInit) {
          plugin.onYogaInit({
            yoga: this
          });
        }
        if (plugin.onRequestParse) {
          this.onRequestParseHooks.push(plugin.onRequestParse);
        }
        if (plugin.onParams) {
          this.onParamsHooks.push(plugin.onParams);
        }
        if (plugin.onResultProcess) {
          this.onResultProcessHooks.push(plugin.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request, batched }, ...args) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const additionalContext = args[0]?.request ? {
          params
        } : {
          request,
          params
        };
        const initialContext = args[0] ? batched ? Object.assign({}, args[0], additionalContext) : Object.assign(args[0], additionalContext) : additionalContext;
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      return result;
    } catch (error) {
      const errors = handleError(error, this.maskedErrorsOpts, this.logger);
      const result = {
        errors
      };
      return result;
    }
  }
  handle = async (request, serverContext) => {
    let url = new Proxy({}, {
      get: (_target, prop, _receiver) => {
        url = new this.fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    let requestParser;
    const onRequestParseDoneList = [];
    for (const onRequestParse of this.onRequestParseHooks) {
      const onRequestParseResult = await onRequestParse({
        request,
        url,
        requestParser,
        serverContext,
        setRequestParser(parser) {
          requestParser = parser;
        }
      });
      if (onRequestParseResult?.onRequestParseDone != null) {
        onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
      }
    }
    this.logger.debug(`Parsing request to extract GraphQL parameters`);
    if (!requestParser) {
      return new this.fetchAPI.Response(null, {
        status: 415,
        statusText: "Unsupported Media Type"
      });
    }
    let requestParserResult = await requestParser(request);
    for (const onRequestParseDone of onRequestParseDoneList) {
      await onRequestParseDone({
        requestParserResult,
        setRequestParserResult(newParams) {
          requestParserResult = newParams;
        }
      });
    }
    const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
      params,
      request,
      batched: true
    }, serverContext))) : this.getResultForParams({
      params: requestParserResult,
      request,
      batched: false
    }, serverContext));
    return processResult({
      request,
      result,
      fetchAPI: this.fetchAPI,
      onResultProcessHooks: this.onResultProcessHooks
    });
  };
};
function createYoga(options) {
  const server = new YogaServer(options);
  return createServerAdapter(server, {
    fetchAPI: server.fetchAPI,
    plugins: server["plugins"]
  });
}

// src/index.ts
var import_xmlbuilder2 = __toESM(require_xmlbuilder2_min());

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/global/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/global/type-options.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/global/field-options.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/global/classes.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/global/schema-types.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/builder.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/build-cache.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/errors.js
init_checked_fetch();
init_modules_watch_stub();
var PothosError = class extends GraphQLError {
  constructor(message, options) {
    super(message, options);
    this.name = "PothosError";
  }
};
var PothosSchemaError = class extends PothosError {
  constructor(message, options) {
    super(message, options);
    this.name = "PothosSchemaError";
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/plugins/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/plugins/merge-plugins.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/plugins/plugin.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/context-cache.js
init_checked_fetch();
init_modules_watch_stub();
var contextCacheSymbol = Symbol.for("Pothos.contextCache");
function createContextCache(create2) {
  const cache = /* @__PURE__ */ new WeakMap();
  return (context, ...args) => {
    const cacheKey = context[contextCacheSymbol] || context;
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    const entry = create2(context, ...args);
    cache.set(cacheKey, entry);
    return entry;
  };
}

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/plugins/plugin.js
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var runCache = /* @__PURE__ */ new WeakMap();
var BasePlugin = class {
  /**
  * Called for each type defined with the SchemaBuilder
  * @param  {PothosTypeConfig} typeConfig - Config object describing the added type
  * @return {PothosTypeConfig} Original or updated `typeConfig`
  */
  onTypeConfig(typeConfig) {
    return typeConfig;
  }
  /**
  * Called for each field on an Object or Interface type
  * @param  {PothosOutputFieldConfig} fieldConfig - Config object describing the added field
  * @return {PothosOutputFieldConfig} Original or updated `fieldConfig`
  */
  onOutputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  /**
  * Called for each argument or field on an Input object defined in your schema
  * @param  {PothosInputFieldConfig} fieldConfig - Config object describing the added field
  * @return {PothosInputFieldConfig} Original or updated `fieldConfig`
  */
  onInputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  /**
  * Called for each Enum value defined in your schema
  * @param  {PothosEnumValueConfig} valueConfig - Config object describing the enum value
  * @return {PothosEnumValueConfig} Original or updated `valueConfig`
  */
  onEnumValueConfig(valueConfig) {
    return valueConfig;
  }
  /**
  * Called before builder.toSchema() schema is called
  */
  beforeBuild() {
  }
  /**
  * Called after all fields and types have been built during `builder.toSchema()`
  * @param  {GraphQLSchema} schema - the generated schema
  * @return {PothosEnumValueConfig} Original or updated `schema`
  */
  afterBuild(schema2) {
    return schema2;
  }
  /**
  * Called with the resolver for each field in the schema
  * @param  {GraphQLFieldResolver} resolve - the resolve function
  * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function
  * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field
  */
  wrapResolve(resolver, fieldConfig) {
    return resolver;
  }
  /**
  * Called with the subscribe for each field on the Subscription type
  * @param  {GraphQLFieldResolver} subscribe - the subscribe function
  * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this subscribe function
  * @return {GraphQLFieldResolver} - Either the original, or a new subscribe function to use for this field
  */
  wrapSubscribe(subscribe3, fieldConfig) {
    return subscribe3;
  }
  /**
  * Called with the resolveType for each Interface or Union type
  * @param  {GraphQLTypeResolver} resolveType - the resolveType function
  * @param  {PothosInterfaceTypeConfig | PothosUnionTypeConfig} typeConfig - the config object for the Interface or Union type
  * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
  */
  wrapResolveType(resolveType, typeConfig) {
    return resolveType;
  }
  /**
  * Called with the isTypeOf for each Object type
  * @param  {GraphQLTypeResolver} resolveType - the resolveType function
  * @param  {PothosObjectTypeConfig} typeConfig - the config object for the Interface or Union type
  * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
  */
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return isTypeOf;
  }
  runUnique(key, cb) {
    if (!runCache.has(this.builder)) {
      runCache.set(this.builder, /* @__PURE__ */ new Map());
    }
    if (!runCache.get(this.builder).has(key)) {
      const result = cb();
      runCache.get(this.builder).set(key, result);
      return result;
    }
    return runCache.get(this.builder).get(key);
  }
  /**
  * Creates a data object unique to the current request for use by this plugin
  * @param  {Types['Context']} context - the context object for the current request
  * @return {object} - The data object for the current request
  */
  createRequestData(context) {
    throw new PothosError("createRequestData not implemented");
  }
  /**
  * Returns a data object for the current request.  requires `createRequestData` to be implemented
  * @param  {Types['Context']} context - the context object for the current request
  * @return {object} - The data object for the current request
  */
  requestData(context) {
    return this.requestDataMap(context);
  }
  constructor(buildCache, name) {
    _define_property(this, "name", void 0);
    _define_property(this, "builder", void 0);
    _define_property(this, "buildCache", void 0);
    _define_property(this, "options", void 0);
    _define_property(this, "requestDataMap", createContextCache((ctx) => this.createRequestData(ctx)));
    this.name = name;
    this.builder = buildCache.builder;
    this.buildCache = buildCache;
    this.options = buildCache.options;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/plugins/merge-plugins.js
function _define_property2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MergedPlugins = class extends BasePlugin {
  onTypeConfig(typeConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onTypeConfig(config), typeConfig);
  }
  onInputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onInputFieldConfig(config), fieldConfig);
  }
  onOutputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onOutputFieldConfig(config), fieldConfig);
  }
  onEnumValueConfig(valueConfig) {
    return this.plugins.reduceRight((config, plugin) => config === null ? config : plugin.onEnumValueConfig(config), valueConfig);
  }
  beforeBuild() {
    for (const plugin of this.plugins) {
      plugin.beforeBuild();
    }
  }
  afterBuild(schema2) {
    return this.plugins.reduceRight((nextSchema, plugin) => plugin.afterBuild(nextSchema), schema2);
  }
  wrapResolve(resolve, fieldConfig) {
    return this.plugins.reduceRight((nextResolve, plugin) => plugin.wrapResolve(nextResolve, fieldConfig), resolve);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return this.plugins.reduceRight((nextSubscribe, plugin) => plugin.wrapSubscribe(nextSubscribe, fieldConfig), subscribe3);
  }
  wrapResolveType(resolveType, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapResolveType(nextResolveType, typeConfig), resolveType);
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
  }
  constructor(buildCache, plugins) {
    super(buildCache, "PothosMergedPlugin");
    _define_property2(this, "plugins", void 0);
    this.plugins = plugins;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/builtin-scalar.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/scalar.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/builder-options.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/configs.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/plugins.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/schema-types.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/type-params.js
init_checked_fetch();
init_modules_watch_stub();
var outputShapeKey = Symbol.for("Pothos.outputShapeKey");
var parentShapeKey = Symbol.for("Pothos.parentShapeKey");
var abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
var inputShapeKey = Symbol.for("Pothos.inputShapeKey");
var inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
var outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
var typeBrandKey = Symbol.for("Pothos.typeBrandKey");

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/types/utils.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/base.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BaseTypeRef = class {
  toString() {
    return `${this.kind}Ref<${this.name}>`;
  }
  constructor(kind, name) {
    _define_property3(this, "kind", void 0);
    _define_property3(this, "name", void 0);
    this.kind = kind;
    this.name = name;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/scalar.js
function _define_property4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey = outputShapeKey;
var _parentShapeKey = parentShapeKey;
var _inputShapeKey = inputShapeKey;
var ScalarRef = class extends BaseTypeRef {
  constructor(name) {
    super("Scalar", name);
    _define_property4(this, "kind", "Scalar");
    _define_property4(this, "$inferType", void 0);
    _define_property4(this, "$inferInput", void 0);
    _define_property4(this, _outputShapeKey, void 0);
    _define_property4(this, _parentShapeKey, void 0);
    _define_property4(this, _inputShapeKey, void 0);
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/builtin-scalar.js
function _define_property5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BuiltinScalarRef = class extends ScalarRef {
  constructor(type) {
    super(type.name);
    _define_property5(this, "type", void 0);
    this.type = type;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/input-list.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputShapeKey2 = inputShapeKey;
var InputListRef = class extends BaseTypeRef {
  constructor(listType, required) {
    super("InputList", `InputList<${String(listType)}>`);
    _define_property6(this, "kind", "InputList");
    _define_property6(this, _inputShapeKey2, void 0);
    _define_property6(this, "$inferInput", void 0);
    _define_property6(this, "listType", void 0);
    _define_property6(this, "required", void 0);
    this.listType = listType;
    this.required = required;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/list.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey2 = outputShapeKey;
var _parentShapeKey2 = parentShapeKey;
var ListRef = class extends BaseTypeRef {
  constructor(listType, nullable) {
    super("List", `List<${String(listType)}>`);
    _define_property7(this, "kind", "List");
    _define_property7(this, "$inferType", void 0);
    _define_property7(this, _outputShapeKey2, void 0);
    _define_property7(this, _parentShapeKey2, void 0);
    _define_property7(this, "listType", void 0);
    _define_property7(this, "nullable", void 0);
    this.listType = listType;
    this.nullable = nullable;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/base64.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/enums.js
init_checked_fetch();
init_modules_watch_stub();
function normalizeEnumValues(values) {
  const result = {};
  if (Array.isArray(values)) {
    values.forEach((key) => {
      result[String(key)] = {
        pothosOptions: {}
      };
    });
  } else {
    Object.entries(values).forEach(([key, value]) => {
      if (value && typeof value === "object") {
        result[key] = {
          ...value,
          pothosOptions: value
        };
      } else if (typeof value === "string") {
        result[value] = {
          pothosOptions: {}
        };
      }
    });
  }
  return result;
}
function valuesFromEnum(Enum, values) {
  const result = {};
  Object.keys(Enum).filter((key) => typeof Enum[Enum[key]] !== "number").forEach((key) => {
    result[key] = {
      value: Enum[key],
      pothosOptions: {},
      ...values === null || values === void 0 ? void 0 : values[key]
    };
  });
  return result;
}

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/input.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/params.js
init_checked_fetch();
init_modules_watch_stub();
function typeFromParam(param, configStore, nullableOption) {
  const itemNullable = typeof nullableOption === "object" ? nullableOption.items : false;
  const nullable = typeof nullableOption === "object" ? nullableOption.list : !!nullableOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: typeFromParam(param[0], configStore, itemNullable),
      nullable
    };
  }
  if (param instanceof ListRef) {
    return {
      kind: "List",
      type: typeFromParam(param.listType, configStore, param.nullable),
      nullable
    };
  }
  const ref = configStore.getOutputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind !== "InputObject" && kind !== "List" && kind !== "InputList") {
    return {
      kind,
      ref,
      nullable
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an output type but got ${kind}`);
}
function inputTypeFromParam(param, configStore, requiredOption) {
  const itemRequired = typeof requiredOption === "object" ? requiredOption.items : true;
  const required = typeof requiredOption === "object" ? requiredOption.list : !!requiredOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: inputTypeFromParam(param[0], configStore, itemRequired),
      required
    };
  }
  if (param instanceof InputListRef) {
    return {
      kind: "List",
      type: inputTypeFromParam(param.listType, configStore, param.required),
      required
    };
  }
  const ref = configStore.getInputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
    return {
      kind,
      ref,
      required
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/sort-classes.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/utils/index.js
function assertNever(value) {
  throw new TypeError(`Unexpected value: ${value}`);
}
function isThenable(value) {
  return !!(value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function");
}
function verifyRef(ref) {
  if (ref === void 0) {
    throw new PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
  }
}
function verifyInterfaces(interfaces) {
  if (!interfaces || typeof interfaces === "function") {
    return;
  }
  if (!Array.isArray(interfaces)) {
    throw new PothosSchemaError("interfaces must be an array or function");
  }
  for (const iface of interfaces) {
    if (iface === void 0) {
      throw new PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
    }
  }
}
function getTypeBrand(val) {
  if (typeof val === "object" && val !== null && typeBrandKey in val) {
    return val[typeBrandKey];
  }
  return null;
}
function unwrapListParam(param) {
  if (Array.isArray(param)) {
    return unwrapListParam(param[0]);
  }
  if (param instanceof ListRef || param instanceof InputListRef) {
    return unwrapListParam(param.listType);
  }
  return param;
}

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/build-cache.js
function _define_property8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BuildCache = class {
  getTypeConfig(ref, kind) {
    const baseConfig = this.configStore.getTypeConfig(ref, kind);
    if (!this.typeConfigs.has(baseConfig.name)) {
      this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
    }
    const typeConfig = this.typeConfigs.get(baseConfig.name);
    return typeConfig;
  }
  getInputTypeFieldConfigs(ref) {
    const typeConfig = this.getTypeConfig(ref, "InputObject");
    const builtType = this.types.get(typeConfig.name);
    if (!builtType) {
      throw new PothosSchemaError(`Input type ${typeConfig.name} has not been built yet`);
    }
    const fields = builtType.getFields();
    const fieldConfigs = {};
    Object.keys(fields).forEach((fieldName) => {
      var _fields_fieldName_extensions;
      fieldConfigs[fieldName] = (_fields_fieldName_extensions = fields[fieldName].extensions) === null || _fields_fieldName_extensions === void 0 ? void 0 : _fields_fieldName_extensions.pothosConfig;
    });
    return fieldConfigs;
  }
  getImplementers(iface) {
    if (this.implementers.has(iface.name)) {
      return this.implementers.get(iface.name);
    }
    const implementers = [
      ...this.configStore.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.configStore.getTypeConfig(i).name === iface.name));
    this.implementers.set(iface.name, implementers);
    return implementers;
  }
  buildAll() {
    this.configStore.prepareForBuild();
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Enum" || baseConfig.kind === "Scalar") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "InputObject") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof GraphQLInputObjectType) {
        type.getFields();
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Interface") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Object") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Union") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Query" || baseConfig.kind === "Mutation" || baseConfig.kind === "Subscription") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType) {
        type.getFields();
      } else if (type instanceof GraphQLUnionType) {
        type.getTypes();
      }
    });
  }
  buildTypeFromConfig(baseConfig) {
    const config = this.getTypeConfig(baseConfig.name);
    const { name } = config;
    this.typeConfigs.set(name, config);
    switch (config.kind) {
      case "Enum":
        this.addType(name, this.buildEnum(config));
        break;
      case "InputObject":
        this.addType(name, this.buildInputObject(config));
        break;
      case "Interface":
        this.addType(name, this.buildInterface(config));
        break;
      case "Scalar":
        this.addType(name, this.buildScalar(config));
        break;
      case "Union":
        this.addType(name, this.buildUnion(config));
        break;
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        this.addType(name, this.buildObject(config));
        break;
      default:
        assertNever(config);
    }
  }
  addType(ref, type) {
    if (this.types.has(ref)) {
      throw new PothosSchemaError(`reference or name has already been used to create another type (${type.name})`);
    }
    this.types.set(ref, type);
  }
  buildOutputTypeParam(type) {
    if (type.kind === "List") {
      if (type.nullable) {
        return new GraphQLList(this.buildOutputTypeParam(type.type));
      }
      return new GraphQLNonNull(new GraphQLList(this.buildOutputTypeParam(type.type)));
    }
    if (type.nullable) {
      return this.getOutputType(type.ref);
    }
    return new GraphQLNonNull(this.getOutputType(type.ref));
  }
  buildInputTypeParam(type) {
    if (type.kind === "List") {
      if (type.required) {
        return new GraphQLNonNull(new GraphQLList(this.buildInputTypeParam(type.type)));
      }
      return new GraphQLList(this.buildInputTypeParam(type.type));
    }
    if (type.required) {
      return new GraphQLNonNull(this.getInputType(type.ref));
    }
    return this.getInputType(type.ref);
  }
  buildFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.outputFieldConfigs.has(originalConfig)) {
        this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
      }
      const updatedConfig = this.outputFieldConfigs.get(originalConfig);
      if (!updatedConfig) {
        continue;
      }
      const config = {
        ...updatedConfig
      };
      const argMap = /* @__PURE__ */ new Map();
      Object.keys(config.args).forEach((argName) => {
        argMap.set(argName, config.args[argName]);
      });
      const args = this.buildInputFields(argMap);
      const argConfigs = {};
      Object.keys(config.args).forEach((argName) => {
        argConfigs[argName] = this.inputFieldConfigs.get(config.args[argName]);
      });
      config.args = argConfigs;
      var _config_resolve;
      const resolve = this.plugin.wrapResolve((_config_resolve = config.resolve) !== null && _config_resolve !== void 0 ? _config_resolve : defaultFieldResolver, config);
      const subscribe3 = this.plugin.wrapSubscribe(config.subscribe, config);
      var _config_resolve1;
      built[fieldName] = {
        ...config,
        type: this.buildOutputTypeParam(config.type),
        args,
        extensions: {
          ...config.extensions,
          pothosResolveWrapped: resolve !== ((_config_resolve1 = config.resolve) !== null && _config_resolve1 !== void 0 ? _config_resolve1 : defaultFieldResolver),
          pothosSubscribeWrapped: subscribe3 !== config.subscribe,
          pothosOptions: config.pothosOptions,
          pothosConfig: config
        },
        resolve: resolve === defaultFieldResolver ? void 0 : resolve,
        subscribe: subscribe3
      };
    }
    return built;
  }
  buildInputFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.inputFieldConfigs.has(originalConfig)) {
        this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
      }
      const config = this.inputFieldConfigs.get(originalConfig);
      if (config) {
        built[fieldName] = {
          ...config,
          type: this.buildInputTypeParam(config.type),
          extensions: {
            ...config.extensions,
            pothosOptions: config.pothosOptions,
            pothosConfig: config
          }
        };
      }
    }
    return built;
  }
  getInterfaceFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const configs = this.configStore.getFields(type.name, "Interface");
    const fields = this.buildFields(configs);
    return {
      ...interfaceFields,
      ...fields
    };
  }
  getObjectFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const objectFields = this.buildFields(this.configStore.getFields(type.name, "Object"));
    return {
      ...interfaceFields,
      ...objectFields
    };
  }
  getRootFields(type) {
    return this.buildFields(this.configStore.getFields(type.name, "Object"));
  }
  getFields(type) {
    if (type instanceof GraphQLObjectType) {
      if (type.name === "Query" || type.name === "Mutation" || type.name === "Subscription") {
        return this.getRootFields(type);
      }
      return this.getObjectFields(type);
    }
    if (type instanceof GraphQLInterfaceType) {
      return this.getInterfaceFields(type);
    }
    throw new PothosSchemaError(`Type ${type.name} does not have fields to resolve`);
  }
  getInputFields(type) {
    return this.buildInputFields(this.configStore.getFields(type.name, "InputObject"));
  }
  getType(ref) {
    if (ref instanceof BuiltinScalarRef) {
      return ref.type;
    }
    const typeConfig = this.configStore.getTypeConfig(ref);
    const type = this.types.get(typeConfig.name);
    if (!type) {
      this.buildTypeFromConfig(typeConfig);
      return this.types.get(typeConfig.name);
    }
    return type;
  }
  getOutputType(ref) {
    const type = this.getType(ref);
    if (type instanceof GraphQLInputObjectType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an output type but it was defined as an InputObject`);
    }
    return type;
  }
  getInputType(ref) {
    const type = this.getType(ref);
    if (!type) {
      throw new PothosSchemaError(`Missing implementation of for type ${String(ref)}`);
    }
    if (type instanceof GraphQLObjectType) {
      throw new PothosSchemaError(`Expected ${type.name} to be an input type but it was defined as a GraphQLObjectType`);
    }
    if (type instanceof GraphQLInterfaceType) {
      throw new PothosSchemaError(`Expected ${type.name} to be an input type but it was defined as a GraphQLInterfaceType`);
    }
    if (type instanceof GraphQLUnionType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an input type but it was defined as an GraphQLUnionType`);
    }
    return type;
  }
  getTypeOfKind(ref, kind) {
    const type = this.getType(ref);
    switch (kind) {
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        if (type instanceof GraphQLObjectType) {
          return type;
        }
        break;
      case "Interface":
        if (type instanceof GraphQLInterfaceType) {
          return type;
        }
        break;
      case "Union":
        if (type instanceof GraphQLUnionType) {
          return type;
        }
        break;
      case "Enum":
        if (type instanceof GraphQLEnumType) {
          return type;
        }
        break;
      case "Scalar":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      case "InputObject":
        if (type instanceof GraphQLScalarType) {
          return type;
        }
        break;
      default:
        break;
    }
    throw new PothosSchemaError(`Expected ${String(ref)} to be of type ${kind}`);
  }
  buildObject(config) {
    var _config_isTypeOf;
    const type = new GraphQLObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getFields(type),
      isTypeOf: config.kind === "Object" ? this.plugin.wrapIsTypeOf((_config_isTypeOf = config.isTypeOf) !== null && _config_isTypeOf !== void 0 ? _config_isTypeOf : void 0, config) : void 0,
      interfaces: config.kind === "Object" ? () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")) : void 0
    });
    return type;
  }
  buildInterface(config) {
    const resolveType = (parent, context, info) => {
      const typeBrand = getTypeBrand(parent);
      if (typeBrand) {
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      var _config_resolveType;
      const resolver = (_config_resolveType = config.resolveType) !== null && _config_resolveType !== void 0 ? _config_resolveType : defaultTypeResolver;
      return resolver(parent, context, info, type);
    };
    const type = new GraphQLInterfaceType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      interfaces: () => config.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")),
      fields: () => this.getFields(type),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
    return type;
  }
  buildUnion(config) {
    const resolveType = (parent, context, info, type) => {
      if (typeof parent === "object" && parent !== null && typeBrandKey in parent) {
        const typeBrand = parent[typeBrandKey];
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      if (!config.resolveType) {
        return defaultTypeResolver(parent, context, info, type);
      }
      const resultOrPromise = config.resolveType(parent, context, info, type);
      const getResult = (result) => {
        if (typeof result === "string" || !result) {
          return result;
        }
        if (result instanceof GraphQLObjectType) {
          return result.name;
        }
        try {
          const typeConfig = this.configStore.getTypeConfig(result);
          return typeConfig.name;
        } catch {
        }
        return result;
      };
      return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
    };
    return new GraphQLUnionType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      types: () => config.types.map((member) => this.getTypeOfKind(member, "Object")),
      resolveType: this.plugin.wrapResolveType(resolveType, config)
    });
  }
  buildInputObject(config) {
    const type = new GraphQLInputObjectType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      },
      fields: () => this.getInputFields(type)
    });
    return type;
  }
  buildScalar(config) {
    if (config.name === "ID") {
      return GraphQLID;
    }
    if (config.name === "Int") {
      return GraphQLInt;
    }
    if (config.name === "Float") {
      return GraphQLFloat;
    }
    if (config.name === "Boolean") {
      return GraphQLBoolean;
    }
    if (config.name === "String") {
      return GraphQLString;
    }
    return new GraphQLScalarType({
      ...config,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  buildEnum(config) {
    const values = {};
    for (const key of Object.keys(config.values)) {
      const original = config.values[key];
      if (!this.enumValueConfigs.has(original)) {
        this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
      }
      const valueConfig = this.enumValueConfigs.get(original);
      if (valueConfig) {
        values[key] = this.enumValueConfigs.get(original);
      }
    }
    return new GraphQLEnumType({
      ...config,
      values,
      extensions: {
        ...config.extensions,
        pothosOptions: config.pothosOptions,
        pothosConfig: config
      }
    });
  }
  constructor(builder2, options) {
    _define_property8(this, "types", /* @__PURE__ */ new Map());
    _define_property8(this, "builder", void 0);
    _define_property8(this, "plugin", void 0);
    _define_property8(this, "options", void 0);
    _define_property8(this, "configStore", void 0);
    _define_property8(this, "pluginMap", void 0);
    _define_property8(this, "pluginList", void 0);
    _define_property8(this, "implementers", /* @__PURE__ */ new Map());
    _define_property8(this, "typeConfigs", /* @__PURE__ */ new Map());
    _define_property8(this, "enumValueConfigs", /* @__PURE__ */ new Map());
    _define_property8(this, "outputFieldConfigs", /* @__PURE__ */ new Map());
    _define_property8(this, "inputFieldConfigs", /* @__PURE__ */ new Map());
    this.builder = builder2;
    this.configStore = builder2.configStore;
    this.options = options;
    const plugins = {};
    var _builder_options_plugins;
    this.pluginList = ((_builder_options_plugins = builder2.options.plugins) !== null && _builder_options_plugins !== void 0 ? _builder_options_plugins : []).map((pluginName) => {
      const Plugin = this.builder.constructor.plugins[pluginName];
      if (!Plugin) {
        throw new PothosError(`No plugin named ${pluginName} was registered`);
      }
      plugins[pluginName] = new Plugin(this, pluginName);
      return plugins[pluginName];
    });
    this.pluginMap = plugins;
    this.plugin = new MergedPlugins(this, this.pluginList);
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/config-store.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/input.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputShapeKey3 = inputShapeKey;
var InputTypeRef = class extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _define_property9(this, "kind", void 0);
    _define_property9(this, "$inferInput", void 0);
    _define_property9(this, _inputShapeKey3, void 0);
    this.kind = kind;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/output.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property10(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey3 = outputShapeKey;
var _parentShapeKey3 = parentShapeKey;
var OutputTypeRef = class extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _define_property10(this, "kind", void 0);
    _define_property10(this, "$inferType", void 0);
    _define_property10(this, _outputShapeKey3, void 0);
    _define_property10(this, _parentShapeKey3, void 0);
    this.kind = kind;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/config-store.js
function _define_property11(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ConfigStore = class {
  hasConfig(typeParam) {
    if (typeof typeParam === "string") {
      return this.typeConfigs.has(typeParam);
    }
    return this.refsToName.has(typeParam);
  }
  addUnionTypes(typeName, unionTypes) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Union") {
        throw new PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.types = [
        ...typeConfig.types,
        ...typeof unionTypes === "function" ? unionTypes() : unionTypes
      ];
    });
  }
  addInterfaces(typeName, interfaces) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
        throw new PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.interfaces = [
        ...typeConfig.interfaces,
        ...typeof interfaces === "function" ? interfaces() : interfaces
      ];
    });
  }
  addFieldRef(ref, typeParam, args, getConfig) {
    if (this.fieldRefs.has(ref)) {
      throw new PothosSchemaError(`FieldRef ${String(ref)} has already been added to config store`);
    }
    const typeRefOrName = unwrapListParam(typeParam);
    const argRefs = Object.keys(args).map((argName) => {
      const argRef = args[argName];
      argRef.fieldName = argName;
      argRef.argFor = ref;
      return argRef;
    });
    const checkArgs = () => {
      for (const arg of argRefs) {
        if (this.pendingFields.has(arg)) {
          const unresolvedArgType = this.pendingFields.get(arg);
          this.pendingFields.set(ref, unresolvedArgType);
          this.onTypeConfig(unresolvedArgType, checkArgs);
          return;
        }
      }
      this.pendingFields.delete(ref);
      this.fieldRefs.set(ref, getConfig);
    };
    if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
      checkArgs();
    } else {
      this.pendingFields.set(ref, typeRefOrName);
      this.onTypeConfig(typeRefOrName, () => {
        checkArgs();
      });
    }
  }
  createFieldConfig(ref, name, typeConfig, parentField, kind) {
    if (!this.fieldRefs.has(ref)) {
      if (this.pendingFields.has(ref)) {
        throw new PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))} used in field ${name} of ${typeConfig.name}`);
      }
      throw new PothosSchemaError(`Missing definition for ${String(ref)}`);
    }
    const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
    if (kind && config.graphqlKind !== kind) {
      throw new PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
    }
    return config;
  }
  associateRefWithName(ref, name) {
    if (!this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`${name} has not been implemented yet`);
    }
    this.refsToName.set(ref, name);
    if (this.pendingRefResolutions.has(ref)) {
      const cbs = this.pendingRefResolutions.get(ref);
      this.pendingRefResolutions.delete(ref);
      cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
    }
  }
  addTypeConfig(config, ref) {
    const { name } = config;
    if (this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
    }
    this.typeConfigs.set(config.name, config);
    if (ref) {
      this.associateRefWithName(ref, name);
    }
    if (this.pendingRefResolutions.has(name)) {
      const cbs = this.pendingRefResolutions.get(name);
      this.pendingRefResolutions.delete(name);
      cbs.forEach((cb) => void cb(config));
    }
  }
  getTypeConfig(ref, kind) {
    let config;
    if (typeof ref === "string") {
      if (!this.typeConfigs.has(ref)) {
        throw new PothosSchemaError(`Type ${String(ref)} has not been implemented`);
      }
      config = this.typeConfigs.get(ref);
    } else if (this.refsToName.has(ref)) {
      config = this.typeConfigs.get(this.refsToName.get(ref));
    } else if (ref instanceof ListRef || ref instanceof InputListRef) {
      throw new PothosSchemaError(`Expected a base type but got a ${ref.kind} of ${String(ref.listType)}`);
    } else {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    }
    if (kind && config.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
    }
    return config;
  }
  getInputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config = this.typeConfigs.get(ref);
        if (config.graphqlKind !== "InputObject" && config.graphqlKind !== "Enum" && config.graphqlKind !== "Scalar") {
          throw new PothosSchemaError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
        }
        const newRef = new InputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref;
  }
  getOutputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind === "InputObject" || ref.kind === "InputList") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
      }
      if (ref.kind === "List") {
        throw new PothosSchemaError(`Expected ${ref.name} to be a base type but got a ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config = this.typeConfigs.get(ref);
        if (config.graphqlKind === "InputObject") {
          throw new PothosSchemaError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
        }
        const newRef = new OutputTypeRef(config.graphqlKind, config.name);
        this.refsToName.set(newRef, config.name);
        return newRef;
      }
    }
    return ref;
  }
  onTypeConfig(ref, cb) {
    if (!ref) {
      throw new PothosSchemaError(`${String(ref)} is not a valid type ref`);
    }
    if (this.refsToName.has(ref)) {
      cb(this.getTypeConfig(ref));
    } else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
      cb(this.typeConfigs.get(ref));
    } else if (!this.pending) {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    } else if (this.pendingRefResolutions.has(ref)) {
      this.pendingRefResolutions.get(ref).push(cb);
    } else {
      this.pendingRefResolutions.set(ref, [
        cb
      ]);
    }
  }
  onFieldUse(ref, cb) {
    if (!this.fieldRefCallbacks.has(ref)) {
      this.fieldRefCallbacks.set(ref, []);
    }
    this.fieldRefCallbacks.get(ref).push(cb);
    if (this.fieldRefsToConfigs.has(ref)) {
      this.fieldRefsToConfigs.get(ref).forEach((config) => void cb(config));
    }
  }
  getFields(name, kind) {
    const typeConfig = this.getTypeConfig(name);
    if (!this.fields.has(name)) {
      this.fields.set(name, /* @__PURE__ */ new Map());
    }
    const fields = this.fields.get(name);
    if (kind && typeConfig.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
    }
    return fields;
  }
  prepareForBuild() {
    this.pending = false;
    const { pendingActions } = this;
    this.pendingActions = [];
    pendingActions.forEach((fn) => void fn());
    if (this.pendingRefResolutions.size > 0) {
      throw new PothosSchemaError(`Missing implementations for some references (${[
        ...this.pendingRefResolutions.keys()
      ].map((ref) => this.describeRef(ref)).join(", ")}).`);
    }
  }
  onPrepare(cb) {
    if (this.pending) {
      this.pendingActions.push(cb);
    } else {
      cb();
    }
  }
  addFields(typeRef, fields) {
    this.onPrepare(() => void this.onTypeConfig(typeRef, (config) => {
      this.buildFields(typeRef, typeof fields === "function" ? fields() : fields);
    }));
  }
  getImplementers(ref) {
    const typeConfig = this.getTypeConfig(ref, "Interface");
    const implementers = [
      ...this.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
    return implementers;
  }
  describeRef(ref) {
    var _find;
    if (typeof ref === "string") {
      return ref;
    }
    if (ref.toString !== {}.toString) {
      return String(ref);
    }
    const usedBy = (_find = [
      ...this.pendingFields.entries()
    ].find(([fieldRef, typeRef]) => typeRef === ref)) === null || _find === void 0 ? void 0 : _find[0];
    if (usedBy) {
      return `<unnamed ref or enum: used by ${usedBy}>`;
    }
    return `<unnamed ref or enum>`;
  }
  buildFields(typeRef, fields) {
    Object.keys(fields).forEach((fieldName) => {
      const fieldRef = fields[fieldName];
      fieldRef.fieldName = fieldName;
      if (this.pendingFields.has(fieldRef)) {
        this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
          this.buildField(typeRef, fieldRef, fieldName);
        });
      } else {
        this.buildField(typeRef, fieldRef, fieldName);
      }
    });
  }
  buildField(typeRef, field, fieldName) {
    const typeConfig = this.getTypeConfig(typeRef);
    const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
    const existingFields = this.getFields(typeConfig.name);
    if (existingFields.has(fieldName)) {
      throw new PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
    }
    if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
      throw new PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
    }
    existingFields.set(fieldName, fieldConfig);
    if (!this.fieldRefsToConfigs.has(field)) {
      this.fieldRefsToConfigs.set(field, []);
    }
    this.fieldRefsToConfigs.get(field).push(fieldConfig);
    if (this.fieldRefCallbacks.has(field)) {
      this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
    }
  }
  constructor() {
    _define_property11(this, "typeConfigs", /* @__PURE__ */ new Map());
    _define_property11(this, "fieldRefs", /* @__PURE__ */ new WeakMap());
    _define_property11(this, "fields", /* @__PURE__ */ new Map());
    _define_property11(this, "pendingActions", []);
    _define_property11(this, "refsToName", /* @__PURE__ */ new Map());
    _define_property11(this, "scalarsToRefs", /* @__PURE__ */ new Map());
    _define_property11(this, "fieldRefsToConfigs", /* @__PURE__ */ new Map());
    _define_property11(this, "pendingFields", /* @__PURE__ */ new Map());
    _define_property11(this, "pendingRefResolutions", /* @__PURE__ */ new Map());
    _define_property11(this, "fieldRefCallbacks", /* @__PURE__ */ new Map());
    _define_property11(this, "pending", true);
    const scalars = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars.forEach((scalar) => {
      const ref = new BuiltinScalarRef(scalar);
      this.scalarsToRefs.set(scalar.name, ref);
      this.refsToName.set(ref, scalar.name);
    });
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/input.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/input-field.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property12(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputFieldShapeKey = inputFieldShapeKey;
var InputFieldRef = class {
  toString() {
    var _this_argFor;
    if (this.kind !== "Arg") {
      if (this.fieldName) {
        return `${this.parentTypename}.${this.fieldName}`;
      }
      return this.parentTypename;
    }
    var _this_argFor_fieldName;
    const fieldName = (_this_argFor_fieldName = (_this_argFor = this.argFor) === null || _this_argFor === void 0 ? void 0 : _this_argFor.fieldName) !== null && _this_argFor_fieldName !== void 0 ? _this_argFor_fieldName : "[unnamed field]";
    var _this_fieldName;
    const argName = (_this_fieldName = this.fieldName) !== null && _this_fieldName !== void 0 ? _this_fieldName : "[unnamed argument]";
    return `${this.parentTypename}.${fieldName}(${argName})`;
  }
  constructor(kind, parentTypename) {
    _define_property12(this, "kind", void 0);
    _define_property12(this, "parentTypename", void 0);
    _define_property12(this, "fieldName", void 0);
    _define_property12(this, "argFor", void 0);
    _define_property12(this, "$inferInput", void 0);
    _define_property12(this, _inputFieldShapeKey, void 0);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/input.js
function _define_property13(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var InputFieldBuilder = class {
  argBuilder() {
    const builder2 = this.field.bind(this);
    const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key) => typeof this[key] === "function" && Function.prototype[key] === void 0);
    [
      ...Object.keys(this),
      ...protoKeys
    ].forEach((key) => {
      builder2[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
    });
    return builder2;
  }
  /**
  * Create in input field or argument for the current type
  * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
  */
  field(options) {
    const ref = new InputFieldRef(this.kind, this.typename);
    this.builder.configStore.addFieldRef(ref, options.type, {}, (name, parentField, typeConfig) => {
      var _options_required;
      return {
        name,
        parentField,
        kind: this.kind,
        graphqlKind: this.kind,
        parentType: typeConfig.name,
        type: inputTypeFromParam(options.type, this.builder.configStore, (_options_required = options.required) !== null && _options_required !== void 0 ? _options_required : this.builder.defaultInputFieldRequiredness),
        pothosOptions: options,
        description: options.description,
        deprecationReason: options.deprecationReason,
        defaultValue: options.defaultValue,
        extensions: options.extensions
      };
    });
    return ref;
  }
  helper(type) {
    return (...args) => {
      const [options = {}] = args;
      return this.field({
        ...options,
        type
      });
    };
  }
  constructor(builder2, kind, typename) {
    _define_property13(this, "builder", void 0);
    _define_property13(this, "kind", void 0);
    _define_property13(this, "typename", void 0);
    _define_property13(this, "boolean", this.helper("Boolean"));
    _define_property13(this, "float", this.helper("Float"));
    _define_property13(this, "id", this.helper("ID"));
    _define_property13(this, "int", this.helper("Int"));
    _define_property13(this, "string", this.helper("String"));
    _define_property13(this, "booleanList", this.helper([
      "Boolean"
    ]));
    _define_property13(this, "floatList", this.helper([
      "Float"
    ]));
    _define_property13(this, "idList", this.helper([
      "ID"
    ]));
    _define_property13(this, "intList", this.helper([
      "Int"
    ]));
    _define_property13(this, "stringList", this.helper([
      "String"
    ]));
    _define_property13(this, "listRef", (type, options) => {
      var _options_required;
      return new InputListRef(type, (_options_required = options === null || options === void 0 ? void 0 : options.required) !== null && _options_required !== void 0 ? _options_required : true);
    });
    this.builder = builder2;
    this.kind = kind;
    this.typename = typename;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/interface.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/builder.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/root.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/base.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/field.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property14(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputFieldShapeKey = outputFieldShapeKey;
var FieldRef = class {
  toString() {
    if (this.fieldName) {
      return `${this.parentTypename}.${this.fieldName}`;
    }
    return this.parentTypename;
  }
  constructor(kind, parentTypename) {
    _define_property14(this, "kind", void 0);
    _define_property14(this, "parentTypename", void 0);
    _define_property14(this, "fieldName", void 0);
    _define_property14(this, "$inferType", void 0);
    _define_property14(this, _outputFieldShapeKey, void 0);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/base.js
function _define_property15(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BaseFieldUtil = class {
  createField(options) {
    const ref = new FieldRef(this.kind, this.typename);
    var _options_args;
    this.builder.configStore.addFieldRef(ref, options.type, (_options_args = options.args) !== null && _options_args !== void 0 ? _options_args : {}, (name, parentField, typeConfig) => {
      var _options_extensions;
      const args = {};
      if (options.args) {
        Object.keys(options.args).forEach((argName) => {
          const argRef = options.args[argName];
          args[argName] = this.builder.configStore.createFieldConfig(argRef, argName, typeConfig, name, "Arg");
        });
      }
      var _options_resolve;
      let resolve = (_options_resolve = options.resolve) !== null && _options_resolve !== void 0 ? _options_resolve : () => {
        throw new PothosSchemaError(`Not implemented: No resolver found for ${this.typename}.${name}`);
      };
      if (((_options_extensions = options.extensions) === null || _options_extensions === void 0 ? void 0 : _options_extensions.pothosExposedField) === name) {
        resolve = defaultFieldResolver;
      }
      const { subscribe: subscribe3 } = options;
      var _options_nullable;
      return {
        kind: this.kind,
        graphqlKind: this.graphqlKind,
        parentType: typeConfig.name,
        name,
        args,
        type: typeFromParam(options.type, this.builder.configStore, (_options_nullable = options.nullable) !== null && _options_nullable !== void 0 ? _options_nullable : this.builder.defaultFieldNullability),
        pothosOptions: options,
        extensions: {
          pothosOriginalResolve: resolve,
          pothosOriginalSubscribe: subscribe3,
          ...options.extensions
        },
        description: options.description,
        deprecationReason: options.deprecationReason,
        resolve,
        subscribe: subscribe3
      };
    });
    return ref;
  }
  exposeField(name, { extensions, ...options }) {
    return this.createField({
      ...options,
      extensions: {
        pothosExposedField: name,
        ...extensions
      },
      resolve: (parent) => parent[name]
    });
  }
  constructor(name, builder2, kind, graphqlKind) {
    _define_property15(this, "typename", void 0);
    _define_property15(this, "builder", void 0);
    _define_property15(this, "kind", void 0);
    _define_property15(this, "graphqlKind", void 0);
    this.typename = name;
    this.builder = builder2;
    this.kind = kind;
    this.graphqlKind = graphqlKind;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/root.js
function _define_property16(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var RootFieldBuilder = class extends BaseFieldUtil {
  /**
  * Create a Boolean field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  boolean(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "Boolean"
    });
  }
  /**
  * Create a Float field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  float(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "Float"
    });
  }
  /**
  * Create a ID field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  id(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "ID"
    });
  }
  /**
  * Create a Int field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  int(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "Int"
    });
  }
  /**
  * Create a String field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  string(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: "String"
    });
  }
  /**
  * Create a Boolean list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  booleanList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  /**
  * Create a Float list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  floatList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "Float"
      ]
    });
  }
  /**
  * Create a ID list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  idList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "ID"
      ]
    });
  }
  /**
  * Create a Int list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  intList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "Int"
      ]
    });
  }
  /**
  * Create a String list field
  * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
  */
  stringList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: void 0,
      ...options,
      type: [
        "String"
      ]
    });
  }
  /**
  * create a new field for the current type
  * @param {PothosSchemaTypes.FieldOptions} options - options for this field
  */
  field(options) {
    return this.createField(options);
  }
  listRef(type, options) {
    var _options_nullable;
    return new ListRef(type, (_options_nullable = options === null || options === void 0 ? void 0 : options.nullable) !== null && _options_nullable !== void 0 ? _options_nullable : false);
  }
  constructor(...args) {
    super(...args);
    _define_property16(this, "arg", new InputFieldBuilder(this.builder, "Arg", this.typename).argBuilder());
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/builder.js
var FieldBuilder = class extends RootFieldBuilder {
  /**
  * Create a Boolean field from a boolean property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeBoolean(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Boolean"
    });
  }
  /**
  * Create a Float field from a numeric property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeFloat(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Float"
    });
  }
  /**
  * Create an ID field from a property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeID(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "ID"
    });
  }
  /**
  * Create an Int field from a numeric property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeInt(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Int"
    });
  }
  /**
  * Create a String field from a string property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeString(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "String"
    });
  }
  /**
  * Create a Boolean list field from a boolean[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeBooleanList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  /**
  * Create a Float list field from a number[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeFloatList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Float"
      ]
    });
  }
  /**
  * Create an ID list field from an id[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeIDList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "ID"
      ]
    });
  }
  /**
  * Create a Int list field from a number[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeIntList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Int"
      ]
    });
  }
  /**
  * Create a String list field from a string[] property on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  exposeStringList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "String"
      ]
    });
  }
  /**
  * Create a field that resolves to a property of the corresponding type on the parent object
  * @param {string} name - the name of the property on the source object (does not need to match the field name).
  * @param {object} [options={}] - Options for this field
  */
  expose(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, options);
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/interface.js
var InterfaceFieldBuilder = class extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Interface", "Interface");
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/mutation.js
init_checked_fetch();
init_modules_watch_stub();
var MutationFieldBuilder = class extends RootFieldBuilder {
  constructor(builder2) {
    super("Mutation", builder2, "Mutation", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/object.js
init_checked_fetch();
init_modules_watch_stub();
var ObjectFieldBuilder = class extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Object", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/query.js
init_checked_fetch();
init_modules_watch_stub();
var QueryFieldBuilder = class extends RootFieldBuilder {
  constructor(builder2) {
    super("Query", builder2, "Query", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/fieldUtils/subscription.js
init_checked_fetch();
init_modules_watch_stub();
var SubscriptionFieldBuilder = class extends RootFieldBuilder {
  constructor(builder2) {
    super("Subscription", builder2, "Subscription", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/enum.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property17(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey4 = outputShapeKey;
var _inputShapeKey4 = inputShapeKey;
var EnumRef = class extends BaseTypeRef {
  constructor(name) {
    super("Enum", name);
    _define_property17(this, "kind", "Enum");
    _define_property17(this, "$inferType", void 0);
    _define_property17(this, "$inferInput", void 0);
    _define_property17(this, _outputShapeKey4, void 0);
    _define_property17(this, _inputShapeKey4, void 0);
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/input-object.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property18(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _inputShapeKey5 = inputShapeKey;
var InputObjectRef = class extends BaseTypeRef {
  constructor(name) {
    super("InputObject", name);
    _define_property18(this, "kind", "InputObject");
    _define_property18(this, "$inferInput", void 0);
    _define_property18(this, _inputShapeKey5, void 0);
  }
};
var ImplementableInputObjectRef = class extends InputObjectRef {
  implement(options) {
    this.builder.inputType(this, options);
    return this;
  }
  constructor(builder2, name) {
    super(name);
    _define_property18(this, "builder", void 0);
    this.builder = builder2;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/interface.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property19(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey5 = outputShapeKey;
var _parentShapeKey4 = parentShapeKey;
var InterfaceRef = class extends BaseTypeRef {
  constructor(name) {
    super("Interface", name);
    _define_property19(this, "kind", "Interface");
    _define_property19(this, "$inferType", void 0);
    _define_property19(this, _outputShapeKey5, void 0);
    _define_property19(this, _parentShapeKey4, void 0);
  }
};
var ImplementableInterfaceRef = class extends InterfaceRef {
  implement(options) {
    return this.builder.interfaceType(this, options);
  }
  constructor(builder2, name) {
    super(name);
    _define_property19(this, "builder", void 0);
    this.builder = builder2;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/object.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property20(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey6 = outputShapeKey;
var _parentShapeKey5 = parentShapeKey;
var ObjectRef = class extends BaseTypeRef {
  constructor(name) {
    super("Object", name);
    _define_property20(this, "kind", "Object");
    _define_property20(this, "$inferType", void 0);
    _define_property20(this, _outputShapeKey6, void 0);
    _define_property20(this, _parentShapeKey5, void 0);
  }
};
var ImplementableObjectRef = class extends ObjectRef {
  implement(options) {
    return this.builder.objectType(this, options);
  }
  constructor(builder2, name) {
    super(name);
    _define_property20(this, "builder", void 0);
    this.builder = builder2;
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/refs/union.js
init_checked_fetch();
init_modules_watch_stub();
function _define_property21(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _outputShapeKey7 = outputShapeKey;
var _parentShapeKey6 = parentShapeKey;
var UnionRef = class extends BaseTypeRef {
  constructor(name) {
    super("Union", name);
    _define_property21(this, "kind", "Union");
    _define_property21(this, "$inferType", void 0);
    _define_property21(this, _outputShapeKey7, void 0);
    _define_property21(this, _parentShapeKey6, void 0);
  }
};

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/builder.js
function _define_property22(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SchemaBuilder = class {
  static registerPlugin(name, plugin) {
    if (!this.allowPluginReRegistration && this.plugins[name]) {
      throw new PothosError(`Received multiple implementations for plugin ${name}`);
    }
    this.plugins[name] = plugin;
  }
  objectType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
    if (name === "Query" || name === "Mutation" || name === "Subscription") {
      throw new PothosSchemaError(`Invalid object name ${name} use .create${name}Type() instead`);
    }
    const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
    const config = {
      kind: "Object",
      graphqlKind: "Object",
      name,
      interfaces: [],
      description: options.description,
      extensions: options.extensions,
      isTypeOf: options.isTypeOf,
      pothosOptions: options
    };
    this.configStore.addTypeConfig(config, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(name, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => {
        const t = new ObjectFieldBuilder(name, this);
        return options.fields(t);
      });
    }
    return ref;
  }
  objectFields(ref, fields) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
    });
  }
  objectField(ref, fieldName, field) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field(new ObjectFieldBuilder(name, this))
      }));
    });
  }
  queryType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Query",
      graphqlKind: "Object",
      name: "Query",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    const ref = new ObjectRef("Query");
    this.configStore.addTypeConfig(config, ref);
    if (fields) {
      this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Query", () => options.fields(new QueryFieldBuilder(this)));
    }
    return ref;
  }
  queryFields(fields) {
    this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
  }
  queryField(name, field) {
    this.configStore.addFields("Query", () => ({
      [name]: field(new QueryFieldBuilder(this))
    }));
  }
  mutationType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Mutation",
      graphqlKind: "Object",
      name: "Mutation",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields) {
      this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Mutation", () => options.fields(new MutationFieldBuilder(this)));
    }
  }
  mutationFields(fields) {
    this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
  }
  mutationField(name, field) {
    this.configStore.addFields("Mutation", () => ({
      [name]: field(new MutationFieldBuilder(this))
    }));
  }
  subscriptionType(...args) {
    const [options = {}, fields] = args;
    const config = {
      kind: "Subscription",
      graphqlKind: "Object",
      name: "Subscription",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config);
    if (fields) {
      this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Subscription", () => options.fields(new SubscriptionFieldBuilder(this)));
    }
  }
  subscriptionFields(fields) {
    this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
  }
  subscriptionField(name, field) {
    this.configStore.addFields("Subscription", () => ({
      [name]: field(new SubscriptionFieldBuilder(this))
    }));
  }
  args(fields) {
    return fields(new InputFieldBuilder(this, "Arg", "[unknown]"));
  }
  interfaceType(param, options, fields) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
    const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
    const typename = ref.name;
    const config = {
      kind: "Interface",
      graphqlKind: "Interface",
      name: typename,
      interfaces: [],
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions,
      resolveType: options.resolveType
    };
    this.configStore.addTypeConfig(config, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(typename, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(typename, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => options.fields(new InterfaceFieldBuilder(typename, this)));
    }
    return ref;
  }
  interfaceFields(ref, fields) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(name, this)));
    });
  }
  interfaceField(ref, fieldName, field) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field(new InterfaceFieldBuilder(name, this))
      }));
    });
  }
  unionType(name, options) {
    const ref = new UnionRef(name);
    if (Array.isArray(options.types)) {
      options.types.forEach((type) => {
        verifyRef(type);
      });
    }
    const config = {
      kind: "Union",
      graphqlKind: "Union",
      name,
      types: [],
      description: options.description,
      resolveType: options.resolveType,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    this.configStore.addUnionTypes(name, options.types);
    return ref;
  }
  enumType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : options.name;
    const ref = new EnumRef(name);
    const values = typeof param === "object" ? valuesFromEnum(
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      param,
      options === null || options === void 0 ? void 0 : options.values
    ) : normalizeEnumValues(options.values);
    const config = {
      kind: "Enum",
      graphqlKind: "Enum",
      name,
      values,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    if (typeof param !== "string") {
      this.configStore.associateRefWithName(param, name);
    }
    return ref;
  }
  scalarType(name, options) {
    const ref = new ScalarRef(name);
    const config = {
      kind: "Scalar",
      graphqlKind: "Scalar",
      name,
      description: options.description,
      parseLiteral: options.parseLiteral,
      parseValue: options.parseValue,
      serialize: options.serialize,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    return ref;
  }
  addScalarType(name, scalar, ...args) {
    const [options = {}] = args;
    const config = scalar.toConfig();
    return this.scalarType(name, {
      ...config,
      ...options,
      extensions: {
        ...config.extensions,
        ...options.extensions
      }
    });
  }
  inputType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : param.name;
    const ref = typeof param === "string" ? new InputObjectRef(name) : param;
    const config = {
      kind: "InputObject",
      graphqlKind: "InputObject",
      name,
      isOneOf: options.isOneOf,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config, ref);
    this.configStore.addFields(ref, () => options.fields(new InputFieldBuilder(this, "InputObject", name)));
    return ref;
  }
  inputRef(name) {
    return new ImplementableInputObjectRef(this, name);
  }
  objectRef(name) {
    return new ImplementableObjectRef(this, name);
  }
  interfaceRef(name) {
    return new ImplementableInterfaceRef(this, name);
  }
  toSchema(...args) {
    const [options = {}] = args;
    const { directives, extensions } = options;
    const scalars = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars.forEach((scalar) => {
      if (!this.configStore.hasConfig(scalar.name)) {
        this.addScalarType(scalar.name, scalar);
      }
    });
    const buildCache = new BuildCache(this, options);
    buildCache.plugin.beforeBuild();
    buildCache.buildAll();
    const builtTypes = [
      ...buildCache.types.values()
    ];
    const schema2 = new GraphQLSchema({
      query: buildCache.types.get("Query"),
      mutation: buildCache.types.get("Mutation"),
      subscription: buildCache.types.get("Subscription"),
      extensions: extensions !== null && extensions !== void 0 ? extensions : {},
      directives,
      types: builtTypes
    });
    const processedSchema = buildCache.plugin.afterBuild(schema2);
    return options.sortSchema === false ? processedSchema : lexicographicSortSchema(processedSchema);
  }
  constructor(options) {
    _define_property22(this, "configStore", void 0);
    _define_property22(this, "options", void 0);
    _define_property22(this, "defaultFieldNullability", void 0);
    _define_property22(this, "defaultInputFieldRequiredness", void 0);
    this.options = options;
    this.configStore = new ConfigStore();
    var _options_defaultFieldNullability;
    this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== void 0 ? _options_defaultFieldNullability : false;
    var _options_defaultInputFieldRequiredness;
    this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== void 0 ? _options_defaultInputFieldRequiredness : false;
  }
};
_define_property22(SchemaBuilder, "plugins", {});
_define_property22(SchemaBuilder, "allowPluginReRegistration", false);

// node_modules/.pnpm/@pothos+core@3.41.0_graphql@16.8.1/node_modules/@pothos/core/esm/index.js
var SchemaBuilder2 = SchemaBuilder;
var esm_default = SchemaBuilder2;

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/hono.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/hono-base.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/compose.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/context.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/utils/html.js
init_checked_fetch();
init_modules_watch_stub();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/context.js
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setHeaders = (headers, map = {}) => {
  Object.entries(map).forEach(([key, value]) => headers.set(key, value));
  return headers;
};
var _status;
var _executionCtx;
var _headers;
var _preparedHeaders;
var _res;
var _isFresh;
var Context = class {
  constructor(req, options) {
    this.env = {};
    this._var = {};
    this.finalized = false;
    this.error = void 0;
    __privateAdd2(this, _status, 200);
    __privateAdd2(this, _executionCtx, void 0);
    __privateAdd2(this, _headers, void 0);
    __privateAdd2(this, _preparedHeaders, void 0);
    __privateAdd2(this, _res, void 0);
    __privateAdd2(this, _isFresh, true);
    this.layout = void 0;
    this.renderer = (content) => this.html(content);
    this.notFoundHandler = () => new Response();
    this.render = (...args) => this.renderer(...args);
    this.setLayout = (layout) => this.layout = layout;
    this.getLayout = () => this.layout;
    this.setRenderer = (renderer) => {
      this.renderer = renderer;
    };
    this.header = (name, value, options2) => {
      if (value === void 0) {
        if (__privateGet2(this, _headers)) {
          __privateGet2(this, _headers).delete(name);
        } else if (__privateGet2(this, _preparedHeaders)) {
          delete __privateGet2(this, _preparedHeaders)[name.toLocaleLowerCase()];
        }
        if (this.finalized) {
          this.res.headers.delete(name);
        }
        return;
      }
      if (options2?.append) {
        if (!__privateGet2(this, _headers)) {
          __privateSet2(this, _isFresh, false);
          __privateSet2(this, _headers, new Headers(__privateGet2(this, _preparedHeaders)));
          __privateSet2(this, _preparedHeaders, {});
        }
        __privateGet2(this, _headers).append(name, value);
      } else {
        if (__privateGet2(this, _headers)) {
          __privateGet2(this, _headers).set(name, value);
        } else {
          __privateGet2(this, _preparedHeaders) ?? __privateSet2(this, _preparedHeaders, {});
          __privateGet2(this, _preparedHeaders)[name.toLowerCase()] = value;
        }
      }
      if (this.finalized) {
        if (options2?.append) {
          this.res.headers.append(name, value);
        } else {
          this.res.headers.set(name, value);
        }
      }
    };
    this.status = (status) => {
      __privateSet2(this, _isFresh, false);
      __privateSet2(this, _status, status);
    };
    this.set = (key, value) => {
      this._var ?? (this._var = {});
      this._var[key] = value;
    };
    this.get = (key) => {
      return this._var ? this._var[key] : void 0;
    };
    this.newResponse = (data, arg, headers) => {
      if (__privateGet2(this, _isFresh) && !headers && !arg && __privateGet2(this, _status) === 200) {
        return new Response(data, {
          headers: __privateGet2(this, _preparedHeaders)
        });
      }
      if (arg && typeof arg !== "number") {
        const headers2 = setHeaders(new Headers(arg.headers), __privateGet2(this, _preparedHeaders));
        return new Response(data, {
          headers: headers2,
          status: arg.status ?? __privateGet2(this, _status)
        });
      }
      const status = typeof arg === "number" ? arg : __privateGet2(this, _status);
      __privateGet2(this, _preparedHeaders) ?? __privateSet2(this, _preparedHeaders, {});
      __privateGet2(this, _headers) ?? __privateSet2(this, _headers, new Headers());
      setHeaders(__privateGet2(this, _headers), __privateGet2(this, _preparedHeaders));
      if (__privateGet2(this, _res)) {
        __privateGet2(this, _res).headers.forEach((v, k) => {
          __privateGet2(this, _headers)?.set(k, v);
        });
        setHeaders(__privateGet2(this, _headers), __privateGet2(this, _preparedHeaders));
      }
      headers ?? (headers = {});
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          __privateGet2(this, _headers).set(k, v);
        } else {
          __privateGet2(this, _headers).delete(k);
          for (const v2 of v) {
            __privateGet2(this, _headers).append(k, v2);
          }
        }
      }
      return new Response(data, {
        status,
        headers: __privateGet2(this, _headers)
      });
    };
    this.body = (data, arg, headers) => {
      return typeof arg === "number" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);
    };
    this.text = (text, arg, headers) => {
      if (!__privateGet2(this, _preparedHeaders)) {
        if (__privateGet2(this, _isFresh) && !headers && !arg) {
          return new Response(text);
        }
        __privateSet2(this, _preparedHeaders, {});
      }
      __privateGet2(this, _preparedHeaders)["content-type"] = TEXT_PLAIN;
      return typeof arg === "number" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);
    };
    this.json = (object, arg, headers) => {
      const body = JSON.stringify(object);
      __privateGet2(this, _preparedHeaders) ?? __privateSet2(this, _preparedHeaders, {});
      __privateGet2(this, _preparedHeaders)["content-type"] = "application/json; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);
    };
    this.html = (html, arg, headers) => {
      __privateGet2(this, _preparedHeaders) ?? __privateSet2(this, _preparedHeaders, {});
      __privateGet2(this, _preparedHeaders)["content-type"] = "text/html; charset=UTF-8";
      if (typeof html === "object") {
        if (!(html instanceof Promise)) {
          html = html.toString();
        }
        if (html instanceof Promise) {
          return html.then((html2) => resolveCallback(html2, HtmlEscapedCallbackPhase.Stringify, false, {})).then((html2) => {
            return typeof arg === "number" ? this.newResponse(html2, arg, headers) : this.newResponse(html2, arg);
          });
        }
      }
      return typeof arg === "number" ? this.newResponse(html, arg, headers) : this.newResponse(html, arg);
    };
    this.redirect = (location, status = 302) => {
      __privateGet2(this, _headers) ?? __privateSet2(this, _headers, new Headers());
      __privateGet2(this, _headers).set("Location", location);
      return this.newResponse(null, status);
    };
    this.notFound = () => {
      return this.notFoundHandler(this);
    };
    this.req = req;
    if (options) {
      __privateSet2(this, _executionCtx, options.executionCtx);
      this.env = options.env;
      if (options.notFoundHandler) {
        this.notFoundHandler = options.notFoundHandler;
      }
    }
  }
  get event() {
    if (__privateGet2(this, _executionCtx) && "respondWith" in __privateGet2(this, _executionCtx)) {
      return __privateGet2(this, _executionCtx);
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (__privateGet2(this, _executionCtx)) {
      return __privateGet2(this, _executionCtx);
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    __privateSet2(this, _isFresh, false);
    return __privateGet2(this, _res) || __privateSet2(this, _res, new Response("404 Not Found", { status: 404 }));
  }
  set res(_res2) {
    __privateSet2(this, _isFresh, false);
    if (__privateGet2(this, _res) && _res2) {
      __privateGet2(this, _res).headers.delete("content-type");
      for (const [k, v] of __privateGet2(this, _res).headers.entries()) {
        if (k === "set-cookie") {
          const cookies = __privateGet2(this, _res).headers.getSetCookie();
          _res2.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res2.headers.append("set-cookie", cookie);
          }
        } else {
          _res2.headers.set(k, v);
        }
      }
    }
    __privateSet2(this, _res, _res2);
    this.finalized = true;
  }
  get var() {
    return { ...this._var };
  }
};
_status = /* @__PURE__ */ new WeakMap();
_executionCtx = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_preparedHeaders = /* @__PURE__ */ new WeakMap();
_res = /* @__PURE__ */ new WeakMap();
_isFresh = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        if (context instanceof Context) {
          context.req.routeIndex = i;
        }
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (!handler) {
        if (context instanceof Context && context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      } else {
        try {
          res = await handler(context, () => {
            return dispatch(i + 1);
          });
        } catch (err) {
          if (err instanceof Error && context instanceof Context && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/http-exception.js
init_checked_fetch();
init_modules_watch_stub();
var HTTPException = class extends Error {
  constructor(status = 500, options) {
    super(options?.message);
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      return this.res;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/request.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/utils/body.js
init_checked_fetch();
init_modules_watch_stub();
var parseBody = async (request, options = { all: false }) => {
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (isFormDataContent(contentType)) {
    return parseFormData(request, options);
  }
  return {};
};
function isFormDataContent(contentType) {
  if (contentType === null) {
    return false;
  }
  return contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded");
}
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = {};
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] && isArrayField(form[key])) {
    appendToExistingArray(form[key], value);
  } else if (form[key]) {
    convertToNewArray(form, key, value);
  } else {
    form[key] = value;
  }
};
function isArrayField(field) {
  return Array.isArray(field);
}
var appendToExistingArray = (arr, value) => {
  arr.push(value);
};
var convertToNewArray = (form, key, value) => {
  form[key] = [form[key], value];
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/utils/url.js
init_checked_fetch();
init_modules_watch_stub();
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
var getPath = (request) => {
  const match = request.url.match(/^https?:\/\/[^/]+(\/[^?]*)/);
  return match ? match[1] : "";
};
var getQueryStrings = (url) => {
  const queryIndex = url.indexOf("?", 8);
  return queryIndex === -1 ? "" : "?" + url.slice(queryIndex + 1);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result[result.length - 1] === "/" ? result.slice(0, -1) : result;
};
var mergePath = (...paths) => {
  let p = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p[p.length - 1] === "/") {
      p = p.slice(0, -1);
      endsWithSlash = true;
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p = `${p}/`;
    } else if (path !== "/") {
      p = `${p}${path}`;
    }
    if (path === "/" && p === "") {
      p = "/";
    }
  }
  return p;
};
var checkOptionalParameter = (path) => {
  if (!path.match(/\:.+\?$/)) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return /%/.test(value) ? decodeURIComponent_(value) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ?? (encoded = /[%+]/.test(url));
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ?? (results[name] = value);
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/request.js
var __accessCheck3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet3 = (obj, member, getter) => {
  __accessCheck3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet3 = (obj, member, value, setter) => {
  __accessCheck3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _validatedData;
var _matchResult;
var HonoRequest = class {
  constructor(request, path = "/", matchResult = [[]]) {
    __privateAdd3(this, _validatedData, void 0);
    __privateAdd3(this, _matchResult, void 0);
    this.routeIndex = 0;
    this.bodyCache = {};
    this.cachedBody = (key) => {
      const { bodyCache, raw: raw2 } = this;
      const cachedBody = bodyCache[key];
      if (cachedBody) {
        return cachedBody;
      }
      if (bodyCache.arrayBuffer) {
        return (async () => {
          return await new Response(bodyCache.arrayBuffer)[key]();
        })();
      }
      return bodyCache[key] = raw2[key]();
    };
    this.raw = request;
    this.path = path;
    __privateSet3(this, _matchResult, matchResult);
    __privateSet3(this, _validatedData, {});
  }
  param(key) {
    return key ? this.getDecodedParam(key) : this.getAllDecodedParams();
  }
  getDecodedParam(key) {
    const paramKey = __privateGet3(this, _matchResult)[0][this.routeIndex][1][key];
    const param = this.getParamValue(paramKey);
    return param ? /\%/.test(param) ? decodeURIComponent_(param) : param : void 0;
  }
  getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(__privateGet3(this, _matchResult)[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.getParamValue(__privateGet3(this, _matchResult)[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? decodeURIComponent_(value) : value;
      }
    }
    return decoded;
  }
  getParamValue(paramKey) {
    return __privateGet3(this, _matchResult)[1] ? __privateGet3(this, _matchResult)[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name.toLowerCase()) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    if (this.bodyCache.parsedBody) {
      return this.bodyCache.parsedBody;
    }
    const parsedBody = await parseBody(this, options);
    this.bodyCache.parsedBody = parsedBody;
    return parsedBody;
  }
  json() {
    return this.cachedBody("json");
  }
  text() {
    return this.cachedBody("text");
  }
  arrayBuffer() {
    return this.cachedBody("arrayBuffer");
  }
  blob() {
    return this.cachedBody("blob");
  }
  formData() {
    return this.cachedBody("formData");
  }
  addValidatedData(target, data) {
    __privateGet3(this, _validatedData)[target] = data;
  }
  valid(target) {
    return __privateGet3(this, _validatedData)[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get matchedRoutes() {
    return __privateGet3(this, _matchResult)[0].map(([[, route]]) => route);
  }
  get routePath() {
    return __privateGet3(this, _matchResult)[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};
_validatedData = /* @__PURE__ */ new WeakMap();
_matchResult = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router.js
init_checked_fetch();
init_modules_watch_stub();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/hono-base.js
var __accessCheck4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet4 = (obj, member, getter) => {
  __accessCheck4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet4 = (obj, member, value, setter) => {
  __accessCheck4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var COMPOSED_HANDLER = Symbol("composedHandler");
function defineDynamicClass() {
  return class {
  };
}
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if (err instanceof HTTPException) {
    return err.getResponse();
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var _path;
var _Hono = class extends defineDynamicClass() {
  constructor(options = {}) {
    super();
    this._basePath = "/";
    __privateAdd4(this, _path, "/");
    this.routes = [];
    this.notFoundHandler = notFoundHandler;
    this.errorHandler = errorHandler;
    this.onError = (handler) => {
      this.errorHandler = handler;
      return this;
    };
    this.notFound = (handler) => {
      this.notFoundHandler = handler;
      return this;
    };
    this.fetch = (request, Env, executionCtx) => {
      return this.dispatch(request, executionCtx, Env, request.method);
    };
    this.request = (input, requestInit, Env, executionCtx) => {
      if (input instanceof Request) {
        if (requestInit !== void 0) {
          input = new Request(input, requestInit);
        }
        return this.fetch(input, Env, executionCtx);
      }
      input = input.toString();
      const path = /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`;
      const req = new Request(path, requestInit);
      return this.fetch(req, Env, executionCtx);
    };
    this.fire = () => {
      addEventListener("fetch", (event) => {
        event.respondWith(this.dispatch(event.request, event, void 0, event.request.method));
      });
    };
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.map((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          __privateSet4(this, _path, args1);
        } else {
          this.addRoute(method, __privateGet4(this, _path), args1);
        }
        args.map((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, __privateGet4(this, _path), handler);
          }
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      if (!method) {
        return this;
      }
      for (const p of [path].flat()) {
        __privateSet4(this, _path, p);
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.addRoute(m.toUpperCase(), __privateGet4(this, _path), handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        __privateSet4(this, _path, arg1);
      } else {
        __privateSet4(this, _path, "*");
        handlers.unshift(arg1);
      }
      handlers.map((handler) => {
        this.addRoute(METHOD_NAME_ALL, __privateGet4(this, _path), handler);
      });
      return this;
    };
    const strict = options.strict ?? true;
    delete options.strict;
    Object.assign(this, options);
    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;
  }
  clone() {
    const clone = new _Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  route(path, app2) {
    const subApp = this.basePath(path);
    if (!app2) {
      return subApp;
    }
    app2.routes.map((r) => {
      let handler;
      if (app2.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app2.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  mount(path, applicationHandler, optionHandler) {
    const mergedPath = mergePath(this._basePath, path);
    const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
    const handler = async (c, next) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      const options = optionHandler ? optionHandler(c) : [c.env, executionContext];
      const optionsArray = Array.isArray(options) ? options : [options];
      const queryStrings = getQueryStrings(c.req.url);
      const res = await applicationHandler(
        new Request(
          new URL((c.req.path.slice(pathPrefixLength) || "/") + queryStrings, c.req.url),
          c.req.raw
        ),
        ...optionsArray
      );
      if (res) {
        return res;
      }
      await next();
    };
    this.addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  matchRoute(method, path) {
    return this.router.match(method, path);
  }
  handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.matchRoute(method, path);
    const c = new Context(new HonoRequest(request, path, matchResult), {
      env,
      executionCtx,
      notFoundHandler: this.notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.notFoundHandler(c);
        });
      } catch (err) {
        return this.handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.notFoundHandler(c))
      ).catch((err) => this.handleError(err, c)) : res;
    }
    const composed = compose(matchResult[0], this.errorHandler, this.notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. You may forget returning Response object or `await next()`"
          );
        }
        return context.res;
      } catch (err) {
        return this.handleError(err, c);
      }
    })();
  }
};
var Hono = _Hono;
_path = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/reg-exp-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/reg-exp-router/router.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/reg-exp-router/node.js
init_checked_fetch();
init_modules_watch_stub();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  constructor() {
    this.children = {};
  }
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.children[regexpStr];
      if (!node) {
        if (Object.keys(this.children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[regexpStr] = new Node();
        if (name !== "") {
          node.varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.varIndex]);
      }
    } else {
      node = this.children[token];
      if (!node) {
        if (Object.keys(this.children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.children[k];
      return (typeof c.varIndex === "number" ? `(${k})@${c.varIndex}` : k) + c.buildRegExpStr();
    });
    if (typeof this.index === "number") {
      strList.unshift(`#${this.index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/reg-exp-router/trie.js
init_checked_fetch();
init_modules_watch_stub();
var Trie = class {
  constructor() {
    this.context = { varIndex: 0 };
    this.root = new Node();
  }
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.root.insert(tokens, index, paramAssoc, this.context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (typeof handlerIndex !== "undefined") {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (typeof paramIndex !== "undefined") {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], {}];
var wildcardRegExpCache = {};
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ?? (wildcardRegExpCache[path] = new RegExp(
    path === "*" ? "" : `^${path.replace(/\/\*/, "(?:|/.*)")}$`
  ));
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = {};
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = {};
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, {}]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = {};
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
var RegExpRouter = class {
  constructor() {
    this.name = "RegExpRouter";
    this.middleware = { [METHOD_NAME_ALL]: {} };
    this.routes = { [METHOD_NAME_ALL]: {} };
  }
  add(method, path, handler) {
    var _a;
    const { middleware, routes } = this;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = {};
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          var _a2;
          (_a2 = middleware[m])[path] || (_a2[path] = findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
        });
      } else {
        (_a = middleware[method])[path] || (_a[path] = findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        var _a2;
        if (method === METHOD_NAME_ALL || method === m) {
          (_a2 = routes[m])[path2] || (_a2[path2] = [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ]);
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  buildAllMatchers() {
    const matchers = {};
    [...Object.keys(this.routes), ...Object.keys(this.middleware)].forEach((method) => {
      matchers[method] || (matchers[method] = this.buildMatcher(method));
    });
    this.middleware = this.routes = void 0;
    return matchers;
  }
  buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.middleware, this.routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute || (hasOwnRoute = true);
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/smart-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/smart-router/router.js
init_checked_fetch();
init_modules_watch_stub();
var SmartRouter = class {
  constructor(init) {
    this.name = "SmartRouter";
    this.routers = [];
    this.routes = [];
    Object.assign(this, init);
  }
  add(method, path, handler) {
    if (!this.routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.routes) {
      throw new Error("Fatal error");
    }
    const { routers, routes } = this;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        routes.forEach((args) => {
          router.add(...args);
        });
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.routers = [router];
      this.routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.routers[0];
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/trie-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/trie-router/router.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/trie-router/node.js
init_checked_fetch();
init_modules_watch_stub();
var Node2 = class {
  constructor(method, handler, children) {
    this.order = 0;
    this.params = {};
    this.children = children || {};
    this.methods = [];
    this.name = "";
    if (method && handler) {
      const m = {};
      m[method] = { handler, possibleKeys: [], score: 0, name: this.name };
      this.methods = [m];
    }
    this.patterns = [];
  }
  insert(method, path, handler) {
    this.name = `${method} ${path}`;
    this.order = ++this.order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    const parentPatterns = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p = parts[i];
      if (Object.keys(curNode.children).includes(p)) {
        parentPatterns.push(...curNode.patterns);
        curNode = curNode.children[p];
        const pattern2 = getPattern(p);
        if (pattern2) {
          possibleKeys.push(pattern2[1]);
        }
        continue;
      }
      curNode.children[p] = new Node2();
      const pattern = getPattern(p);
      if (pattern) {
        curNode.patterns.push(pattern);
        parentPatterns.push(...curNode.patterns);
        possibleKeys.push(pattern[1]);
      }
      parentPatterns.push(...curNode.patterns);
      curNode = curNode.children[p];
    }
    if (!curNode.methods.length) {
      curNode.methods = [];
    }
    const m = {};
    const handlerSet = {
      handler,
      possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
      name: this.name,
      score: this.order
    };
    m[method] = handlerSet;
    curNode.methods.push(m);
    return curNode;
  }
  gHSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.methods.length; i < len; i++) {
      const m = node.methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = {};
        handlerSet.possibleKeys.forEach((key) => {
          const processed = processedSet[handlerSet.name];
          handlerSet.params[key] = params[key] && !processed ? params[key] : nodeParams[key] ?? params[key];
          processedSet[handlerSet.name] = true;
        });
        handlerSets.push(handlerSet);
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.params = {};
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.children[part];
        if (nextNode) {
          nextNode.params = node.params;
          if (isLast === true) {
            if (nextNode.children["*"]) {
              handlerSets.push(...this.gHSets(nextNode.children["*"], method, node.params, {}));
            }
            handlerSets.push(...this.gHSets(nextNode, method, node.params, {}));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {
          const pattern = node.patterns[k];
          const params = { ...node.params };
          if (pattern === "*") {
            const astNode = node.children["*"];
            if (astNode) {
              handlerSets.push(...this.gHSets(astNode, method, node.params, {}));
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "") {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp && matcher.test(restPathString)) {
            params[name] = restPathString;
            handlerSets.push(...this.gHSets(child, method, node.params, params));
            continue;
          }
          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {
            if (typeof key === "string") {
              params[name] = part;
              if (isLast === true) {
                handlerSets.push(...this.gHSets(child, method, params, node.params));
                if (child.children["*"]) {
                  handlerSets.push(...this.gHSets(child.children["*"], method, params, node.params));
                }
              } else {
                child.params = params;
                tempNodes.push(child);
              }
            }
          }
        }
      }
      curNodes = tempNodes;
    }
    const results = handlerSets.sort((a, b) => {
      return a.score - b.score;
    });
    return [results.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  constructor() {
    this.name = "TrieRouter";
    this.node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (const p of results) {
        this.node.insert(method, p, handler);
      }
      return;
    }
    this.node.insert(method, path, handler);
  }
  match(method, path) {
    return this.node.search(method, path);
  }
};

// node_modules/.pnpm/hono@4.0.10/node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// src/index.ts
var builder = new esm_default({});
builder.objectType("Point", {
  fields: (t) => ({
    lat: t.exposeFloat("lat", {}),
    lon: t.exposeFloat("lon", {}),
    hae: t.exposeFloat("hae", {})
    // Height above ellipsoid
  })
});
builder.objectType("Unit", {
  fields: (t) => ({
    uid: t.exposeString("uid", {}),
    name: t.exposeString("name", {}),
    type: t.exposeString("type", {})
  })
});
builder.objectType("Event", {
  fields: (t) => ({
    type: t.exposeString("type", {}),
    point: t.field({
      type: "Point",
      resolve: () => ({
        lat: 34.2101,
        lon: -77.8868,
        hae: 30.48
        // Example data
      })
    }),
    unit: t.field({
      type: "Unit",
      resolve: () => ({
        uid: "Unit123",
        name: "Alpha Team",
        type: "Infantry"
      })
    })
  })
});
builder.queryType({
  fields: (t) => ({
    event: t.field({
      type: "Event",
      args: {
        type: t.arg({ type: "String", required: true })
      },
      resolve: (_, args) => ({
        // Dummy resolver for demonstration
        type: args.type,
        unit: {
          // Example data
          uid: "Unit123",
          name: "Alpha Team",
          type: "Infantry"
        },
        point: {
          lat: 34.2101,
          lon: -77.8868,
          hae: 30.48
        }
      })
    })
  })
});
function convertJsonToCotXml(json) {
  const obj = {
    Event: {
      "@type": json.type,
      // Updated to correctly format XML attributes
      Point: {
        "@lat": json.point.lat.toString(),
        "@lon": json.point.lon.toString(),
        "@hae": json.point.hae.toString()
      },
      Unit: {
        "@uid": json.unit.uid,
        "@name": json.unit.name,
        "@type": json.unit.type
      }
    }
  };
  const doc = (0, import_xmlbuilder2.create)(obj);
  return doc.end({ prettyPrint: true });
}
var schema = builder.toSchema({});
var app = new Hono2();
function doYoga(reqRaw, env, executionCtx) {
  return createYoga({
    logging: "info",
    // `NODE_ENV` is under `c.env`
    maskedErrors: env.NODE_ENV == "production",
    // Keep as / so you're using just the hono route
    graphqlEndpoint: "/",
    schema
    // feed in your schema here normally
  }).fetch(reqRaw, env, executionCtx);
}
app.on(
  ["POST", "GET"],
  "/",
  async (c) => doYoga(c.req, c.env, c.executionCtx)
);
var src_default = app;

// node_modules/.pnpm/wrangler@3.31.0_@cloudflare+workers-types@4.20240222.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_checked_fetch();
init_modules_watch_stub();
var drainBody = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
};
var middleware_ensure_req_body_drained_default = drainBody;
var wrap2 = void 0;

// node_modules/.pnpm/wrangler@3.31.0_@cloudflare+workers-types@4.20240222.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_checked_fetch();
init_modules_watch_stub();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
var jsonError = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e) {
    const error = reduceError(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError;
var wrap3 = void 0;

// .wrangler/tmp/bundle-PqeCQB/middleware-insertion-facade.js
var envWrappers = [wrap2, wrap3].filter(Boolean);
var facade = {
  ...src_default,
  envWrappers,
  middleware: [
    middleware_ensure_req_body_drained_default,
    middleware_miniflare3_json_error_default,
    ...src_default.middleware ? src_default.middleware : []
  ].filter(Boolean)
};
var middleware_insertion_facade_default = facade;

// node_modules/.pnpm/wrangler@3.31.0_@cloudflare+workers-types@4.20240222.0/node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}

// .wrangler/tmp/bundle-PqeCQB/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
var __facade_modules_fetch__ = function(request, env, ctx) {
  if (middleware_insertion_facade_default.fetch === void 0)
    throw new Error("Handler does not export a fetch() function.");
  return middleware_insertion_facade_default.fetch(request, env, ctx);
};
function getMaskedEnv(rawEnv) {
  let env = rawEnv;
  if (middleware_insertion_facade_default.envWrappers && middleware_insertion_facade_default.envWrappers.length > 0) {
    for (const wrapFn of middleware_insertion_facade_default.envWrappers) {
      env = wrapFn(env);
    }
  }
  return env;
}
var registeredMiddleware = false;
var facade2 = {
  ...middleware_insertion_facade_default.tail && {
    tail: maskHandlerEnv(middleware_insertion_facade_default.tail)
  },
  ...middleware_insertion_facade_default.trace && {
    trace: maskHandlerEnv(middleware_insertion_facade_default.trace)
  },
  ...middleware_insertion_facade_default.scheduled && {
    scheduled: maskHandlerEnv(middleware_insertion_facade_default.scheduled)
  },
  ...middleware_insertion_facade_default.queue && {
    queue: maskHandlerEnv(middleware_insertion_facade_default.queue)
  },
  ...middleware_insertion_facade_default.test && {
    test: maskHandlerEnv(middleware_insertion_facade_default.test)
  },
  ...middleware_insertion_facade_default.email && {
    email: maskHandlerEnv(middleware_insertion_facade_default.email)
  },
  fetch(request, rawEnv, ctx) {
    const env = getMaskedEnv(rawEnv);
    if (middleware_insertion_facade_default.middleware && middleware_insertion_facade_default.middleware.length > 0) {
      if (!registeredMiddleware) {
        registeredMiddleware = true;
        for (const middleware of middleware_insertion_facade_default.middleware) {
          __facade_register__(middleware);
        }
      }
      const __facade_modules_dispatch__ = function(type, init) {
        if (type === "scheduled" && middleware_insertion_facade_default.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return middleware_insertion_facade_default.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__(
        request,
        env,
        ctx,
        __facade_modules_dispatch__,
        __facade_modules_fetch__
      );
    } else {
      return __facade_modules_fetch__(request, env, ctx);
    }
  }
};
function maskHandlerEnv(handler) {
  return (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);
}
var middleware_loader_entry_default = facade2;
export {
  convertJsonToCotXml,
  middleware_loader_entry_default as default,
  doYoga,
  schema
};
/*! Bundled license information:

xmlbuilder2/lib/xmlbuilder2.min.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <http://feross.org>
   * @license  MIT
   *)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
*/
//# sourceMappingURL=index.js.map
